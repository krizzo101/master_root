"""
Standardized Request Schemas

Universal schemas that can accommodate any type of request to the OAMAT Smart Decomposition system.
These schemas ensure the O3 master agent always receives consistent, complete information.
"""

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator


class RequestType(str, Enum):
    """High-level categorization of request types"""

    APPLICATION_DEVELOPMENT = "application_development"
    WEB_SERVICE = "web_service"
    SCRIPT_AUTOMATION = "script_automation"
    DATA_ANALYSIS = "data_analysis"
    SYSTEM_INTEGRATION = "system_integration"
    DOCUMENTATION = "documentation"
    RESEARCH_ANALYSIS = "research_analysis"
    TESTING_VALIDATION = "testing_validation"
    DEPLOYMENT_OPERATIONS = "deployment_operations"
    OTHER = "other"


class ComplexityLevel(str, Enum):
    """Assessed complexity of the request"""

    SIMPLE = "simple"  # Single component, straightforward implementation
    MODERATE = "moderate"  # Multiple components, some integration needed
    COMPLEX = "complex"  # Multi-system, significant architecture required
    ADVANCED = "advanced"  # Novel solutions, research-level complexity


class PlatformTarget(str, Enum):
    """Target deployment platforms"""

    WEB = "web"
    DESKTOP = "desktop"
    MOBILE = "mobile"
    SERVER = "server"
    CLOUD = "cloud"
    EMBEDDED = "embedded"
    CLI = "cli"
    LIBRARY = "library"
    MULTIPLE = "multiple"
    UNSPECIFIED = "unspecified"


class QualityLevel(str, Enum):
    """Expected quality and production readiness"""

    PROTOTYPE = "prototype"  # Quick proof of concept
    DEVELOPMENT = "development"  # Development-ready code
    PRODUCTION = "production"  # Production-ready, robust implementation
    ENTERPRISE = "enterprise"  # Enterprise-grade with full compliance


class ProjectType(Enum):
    """Project classification types"""

    WEB_APPLICATION = "web_application"
    API_SERVICE = "api_service"
    CLI_TOOL = "cli_tool"
    LIBRARY = "library"
    MOBILE_APP = "mobile_app"
    DESKTOP_APP = "desktop_app"
    DATA_PIPELINE = "data_pipeline"
    ML_MODEL = "ml_model"
    DOCUMENTATION = "documentation"
    CONFIGURATION = "configuration"
    OTHER = "other"


class Priority(Enum):
    """Priority levels for requirements"""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class SubdivisionMetadata(BaseModel):
    """Dynamic subdivision analysis metadata - ALL VALUES O3-GENERATED AT RUNTIME"""

    # NO HARDCODED DEFAULTS - All values dynamically generated by O3
    complexity_score: Optional[float] = Field(
        default=None,
        description="O3-calculated complexity score (dynamically determined range)",
    )
    requires_subdivision: Optional[bool] = Field(
        default=None, description="O3-determined subdivision flag"
    )
    subdivision_reasoning: Optional[str] = Field(
        default=None, description="AI-generated reasoning for subdivision decision"
    )
    suggested_sub_roles: Optional[list[str]] = Field(
        default=None, description="Dynamically generated specialized roles"
    )
    parallelization_potential: Optional[float] = Field(
        default=None, description="O3-calculated parallel execution opportunity"
    )
    integration_requirements: Optional[List[str]] = Field(
        default=None, description="Dynamic integration needs between subdivisions"
    )
    max_subdivision_depth: Optional[int] = Field(
        default=None, description="O3-determined maximum recursion depth"
    )
    estimated_sub_agents: Optional[int] = Field(
        default=None, description="Dynamic count estimation of sub-agents needed"
    )
    complexity_factors: Optional[Dict[str, float]] = Field(
        default=None, description="O3-generated breakdown of complexity factors"
    )
    subdivision_benefits: Optional[List[str]] = Field(
        default=None, description="O3-identified benefits from subdivision"
    )
    coordination_overhead: Optional[float] = Field(
        default=None, description="O3-estimated coordination overhead"
    )

    # Dynamic thresholds and criteria - NO HARDCODED VALUES
    decision_thresholds: Optional[Dict[str, float]] = Field(
        default=None, description="O3-generated decision thresholds for subdivision"
    )
    recommendation_categories: Optional[List[str]] = Field(
        default=None, description="O3-generated recommendation categories"
    )


class DomainSpecialization(BaseModel):
    """Domain-specific specialization requirements - ALL O3-GENERATED"""

    # NO HARDCODED FIELDS - All dynamically determined
    domain_name: Optional[str] = Field(
        default=None, description="O3-identified domain name"
    )
    expertise_level: Optional[str] = Field(
        default=None, description="O3-determined expertise level"
    )
    key_technologies: Optional[List[str]] = Field(
        default=None, description="O3-identified core technologies"
    )
    integration_points: Optional[List[str]] = Field(
        default=None, description="O3-identified integration requirements"
    )
    specialization_benefits: Optional[List[str]] = Field(
        default=None, description="O3-identified specialization benefits"
    )


class RequestClassification(BaseModel):
    """High-level classification and categorization"""

    request_type: RequestType = Field(..., description="Primary type of request")
    complexity_level: ComplexityLevel = Field(..., description="Assessed complexity")
    domain_category: str = Field(
        ..., description="Specific domain (e.g., 'web-development', 'data-science')"
    )
    platform_target: PlatformTarget = Field(
        default=PlatformTarget.UNSPECIFIED, description="Target platform"
    )
    quality_level: QualityLevel = Field(
        default=QualityLevel.DEVELOPMENT, description="Expected quality level"
    )
    estimated_effort: str = Field(
        ..., description="Estimated effort (e.g., 'hours', 'days', 'weeks')"
    )


class TechnicalSpecification(BaseModel):
    """Technical requirements and constraints"""

    programming_languages: List[str] = Field(
        default_factory=list, description="Required or preferred languages"
    )
    frameworks: List[str] = Field(
        default_factory=list, description="Specific frameworks to use"
    )
    platforms: List[str] = Field(
        default_factory=list, description="Target platforms or environments"
    )
    databases: List[str] = Field(
        default_factory=list, description="Database technologies needed"
    )
    external_services: List[str] = Field(
        default_factory=list, description="Third-party services to integrate"
    )
    technology_constraints: List[str] = Field(
        default_factory=list, description="Technology limitations or requirements"
    )
    performance_requirements: List[str] = Field(
        default_factory=list, description="Performance criteria"
    )
    security_requirements: List[str] = Field(
        default_factory=list, description="Security standards needed"
    )


class FunctionalRequirement(BaseModel):
    """Individual functional requirement"""

    requirement_id: str = Field(..., description="Unique identifier")
    description: str = Field(..., description="Clear description of the requirement")
    priority: str = Field(
        ..., description="Priority level (critical, high, medium, low)"
    )
    acceptance_criteria: List[str] = Field(
        default_factory=list, description="Criteria for completion"
    )


class DeliverableSpecification(BaseModel):
    """What needs to be delivered"""

    file_types: List[str] = Field(
        default_factory=list, description="Types of files to generate"
    )
    directory_structure: List[str] = Field(
        default_factory=list, description="Required directory organization"
    )
    documentation_requirements: List[str] = Field(
        default_factory=list, description="Documentation needed"
    )
    configuration_files: List[str] = Field(
        default_factory=list, description="Config files to create"
    )
    test_requirements: List[str] = Field(
        default_factory=list, description="Testing artifacts needed"
    )
    deployment_artifacts: List[str] = Field(
        default_factory=list, description="Deployment-related files"
    )


class ContextInformation(BaseModel):
    """Environmental and contextual details"""

    user_environment: Dict[str, str] = Field(
        default_factory=dict, description="User's development environment"
    )
    existing_systems: List[str] = Field(
        default_factory=list, description="Systems to integrate with"
    )
    user_preferences: Dict[str, str] = Field(
        default_factory=dict, description="User coding/style preferences"
    )
    constraints: List[str] = Field(
        default_factory=list, description="Any limitations or constraints"
    )
    assumptions: List[str] = Field(
        default_factory=list, description="Assumptions made about the request"
    )


class SuccessCriteria(BaseModel):
    """How to measure successful completion"""

    primary_objectives: List[str] = Field(
        default_factory=list, description="Main goals to achieve"
    )
    success_metrics: List[str] = Field(
        default_factory=list, description="Measurable success criteria"
    )
    validation_steps: List[str] = Field(
        default_factory=list, description="Steps to validate completion"
    )
    user_acceptance_criteria: List[str] = Field(
        default_factory=list, description="User acceptance requirements"
    )


class ConfidenceScoring(BaseModel):
    """Confidence levels for filled information"""

    classification_confidence: float = Field(
        default=1.0, ge=0.0, le=1.0, description="Confidence in classification"
    )
    technical_confidence: float = Field(
        default=1.0, ge=0.0, le=1.0, description="Confidence in technical specs"
    )
    requirements_confidence: float = Field(
        default=1.0, ge=0.0, le=1.0, description="Confidence in requirements"
    )
    overall_confidence: float = Field(
        default=1.0, ge=0.0, le=1.0, description="Overall confidence score"
    )


class StandardizedRequest(BaseModel):
    """
    Universal standardized format for any request to OAMAT Smart Decomposition.

    This schema ensures the O3 master agent always receives complete, structured
    information regardless of how the user originally phrased their request.
    """

    # Core identification
    original_request: str = Field(..., description="Original user request text")
    processed_timestamp: str = Field(
        default_factory=lambda: datetime.now().isoformat(),
        description="When preprocessing occurred (ISO format)",
    )

    # Structured analysis
    classification: RequestClassification = Field(
        ..., description="Request classification and categorization"
    )
    technical_specification: TechnicalSpecification = Field(
        ..., description="Technical requirements and constraints"
    )

    # Requirements breakdown
    functional_requirements: List[FunctionalRequirement] = Field(
        default_factory=list, description="Specific functional requirements"
    )
    non_functional_requirements: List[str] = Field(
        default_factory=list, description="Quality, performance, security requirements"
    )

    # Delivery specifications
    deliverables: DeliverableSpecification = Field(
        ..., description="What needs to be delivered"
    )

    # Context and environment
    context: ContextInformation = Field(
        ..., description="Environmental and contextual information"
    )

    # Success definition
    success_criteria: SuccessCriteria = Field(
        ..., description="How to measure successful completion"
    )

    # Preprocessing metadata
    confidence_scores: ConfidenceScoring = Field(
        ..., description="Confidence in filled information"
    )
    clarification_needed: List[str] = Field(
        default_factory=list, description="Areas needing user clarification"
    )
    preprocessing_notes: List[str] = Field(
        default_factory=list, description="Notes from preprocessing analysis"
    )

    subdivision_metadata: Optional[SubdivisionMetadata] = Field(
        default=None, description="Dynamic subdivision analysis metadata"
    )

    # NEW: Domain-specific specialization analysis
    domain_specializations: List[DomainSpecialization] = Field(
        default_factory=list,
        description="Identified domain specializations for subdivision",
    )

    # NEW: Enhanced complexity analysis fields
    estimated_delivery_complexity: str = Field(
        default="unknown", description="Overall delivery complexity assessment"
    )

    parallel_work_opportunities: List[str] = Field(
        default_factory=list, description="Identified opportunities for parallel work"
    )

    cross_domain_dependencies: List[str] = Field(
        default_factory=list, description="Dependencies that cross technical domains"
    )

    @field_validator("functional_requirements", mode="before")
    @classmethod
    def ensure_functional_requirements_list(cls, v):
        """Ensure functional requirements is always a list"""
        if not isinstance(v, list):
            return []
        return v

    @property
    def summary(self) -> str:
        """Generate a concise summary of the standardized request"""
        return f"{self.classification.request_type.value} ({self.classification.complexity_level.value}): {self.original_request[:100]}..."

    @property
    def is_well_defined(self) -> bool:
        """Check if the request is well-defined based on confidence scores"""
        return (
            self.confidence_scores.overall_confidence >= 0.7
            and len(self.clarification_needed) == 0
        )

    @property
    def key_technologies(self) -> List[str]:
        """Get the key technologies involved in this request"""
        return (
            self.technical_specification.programming_languages
            + self.technical_specification.frameworks
            + self.technical_specification.platforms
        )

    @property
    def requires_subdivision(self) -> bool:
        """Check if this request requires subdivision based on analysis"""
        if self.subdivision_metadata:
            return self.subdivision_metadata.requires_subdivision
        return False

    @property
    def subdivision_complexity_score(self) -> float:
        """Get the subdivision complexity score"""
        if self.subdivision_metadata:
            return self.subdivision_metadata.complexity_score
        return 0.0

    @property
    def suggested_subdivision_roles(self) -> List[str]:
        """Get suggested roles for subdivision"""
        if self.subdivision_metadata:
            return self.subdivision_metadata.suggested_sub_roles
        return []

    def get_domain_specializations_summary(self) -> Dict[str, List[str]]:
        """Get summary of domain specializations"""
        summary = {}
        for domain in self.domain_specializations:
            summary[domain.domain_name] = domain.key_technologies
        return summary

    def estimate_subdivision_benefits(self) -> Dict[str, Any]:
        """Estimate benefits vs overhead of subdivision"""
        if not self.subdivision_metadata:
            return {"benefits": [], "overhead": 0.0, "recommendation": "no_subdivision"}

        benefits = self.subdivision_metadata.subdivision_benefits
        overhead = self.subdivision_metadata.coordination_overhead
        complexity = self.subdivision_metadata.complexity_score

        # Simple decision logic - O3 will provide more sophisticated analysis
        if complexity > 7.0 and overhead < 0.5:
            recommendation = "highly_recommended"
        elif complexity > 5.0 and overhead < 0.7:
            recommendation = "recommended"
        elif complexity > 3.0:
            recommendation = "consider"
        else:
            recommendation = "not_recommended"

        return {
            "benefits": benefits,
            "overhead": overhead,
            "complexity": complexity,
            "recommendation": recommendation,
            "parallel_potential": self.subdivision_metadata.parallelization_potential,
        }


class PreprocessingResult(BaseModel):
    """Result of the preprocessing operation"""

    success: bool = Field(..., description="Whether preprocessing succeeded")
    standardized_request: Optional[StandardizedRequest] = Field(
        None, description="The standardized request"
    )
    error_message: Optional[str] = Field(
        None, description="Error message if preprocessing failed"
    )
    processing_time_ms: float = Field(..., description="Time taken for preprocessing")
    model_used: str = Field(..., description="AI model used for preprocessing")
