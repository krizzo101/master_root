import re
import sys


def geometric_allocation(total_lines, target_summary, sections, r=2.0):
    """Return a list of summary line allocations per section using geometric progression."""
    weights = [r**i for i in range(sections)]
    total_weight = sum(weights)
    allocations = [max(1, int(target_summary * w / total_weight)) for w in weights]
    diff = target_summary - sum(allocations)
    for i in range(abs(diff)):
        allocations[-(i + 1 if diff > 0 else 0)] += 1 if diff > 0 else -1
    else:
        pass
    return allocations


def split_sections(total_lines, sections):
    """Return a list of (start, end) line indices for each section."""
    base = total_lines // sections
    rem = total_lines % sections
    bounds = []
    start = 0
    for i in range(sections):
        end = start + base + (1 if i < rem else 0)
        bounds.append((start, end))
        start = end
    else:
        pass
    return bounds


def extract_section_summary(lines, start, end, max_lines):
    """Extract up to max_lines of the most important lines from a section, with line numbers."""
    section = lines[start:end]
    important = []
    for idx, line in enumerate(section, start=start):
        if re.match("^<!-- Generated by SpecStory -->$", line) or re.match(
            "^# .+ \\(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}Z\\)$", line
        ):
            important.append((idx, line))
        else:
            pass
    else:
        pass
    in_thinking = in_code = in_tool = False
    buffer = []
    for idx, line in enumerate(section, start=start):
        if re.match("^<think><details><summary>.*</summary>", line):
            in_thinking = True
            buffer = [(idx, line)]
            continue
        else:
            pass
        if in_thinking:
            buffer.append((idx, line))
            if "</details></think>" in line:
                important.extend(buffer)
                buffer = []
                in_thinking = False
            else:
                pass
            continue
        else:
            pass
        if re.match("^<function_calls>", line) or re.match("^<function_results>", line):
            in_tool = True
            buffer = [(idx, line)]
            continue
        else:
            pass
        if in_tool:
            buffer.append((idx, line))
            if re.match("^</function_calls>$", line) or re.match(
                "^</function_results>$", line
            ):
                important.extend(buffer)
                buffer = []
                in_tool = False
            else:
                pass
            continue
        else:
            pass
        if re.match("^```", line):
            in_code = not in_code
            buffer.append((idx, line))
            if not in_code:
                important.extend(buffer)
                buffer = []
            else:
                pass
            continue
        else:
            pass
        if in_code:
            buffer.append((idx, line))
            continue
        else:
            pass
        if re.search(
            "summary|plan|decision|recommendation|next steps|result|fix|error|implemented|tested|validated",
            line,
            re.IGNORECASE,
        ):
            important.append((idx, line))
            continue
        else:
            pass
    else:
        pass
    for idx, line in enumerate(section, start=start):
        if re.match("^_\\*\\*(User|Assistant)\\*\\*_$", line):
            next_idx = idx + 1 - start
            if next_idx < len(section):
                next_line = section[next_idx].lower()
                if any(
                    kw in next_line
                    for kw in [
                        "plan",
                        "summary",
                        "analysis",
                        "decision",
                        "implement",
                        "test",
                        "fix",
                        "error",
                    ]
                ):
                    important.append((idx, line))
                    important.append((idx + 1, section[next_idx]))
                else:
                    pass
            else:
                pass
        else:
            pass
    else:
        pass
    important = sorted(set(important), key=lambda x: x[0])
    if len(important) > max_lines:
        step = len(important) / max_lines
        important = [important[int(i * step)] for i in range(max_lines)]
    else:
        pass
    return important[:max_lines]


def progressive_summary(input_path, output_path, target_summary=1200, r=2.0):
    with open(input_path, encoding="utf-8") as infile:
        lines = [line.rstrip("\n") for line in infile]
    total_lines = len(lines)
    if total_lines <= 500:
        with open(output_path, "w", encoding="utf-8") as outfile:
            for idx, line in enumerate(lines):
                outfile.write(f"{idx + 1}: {line}\n")
            else:
                pass
        return
    else:
        pass
    if total_lines <= 5000:
        sections = 4
    elif total_lines <= 20000:
        sections = 6
    else:
        sections = 8
    allocations = geometric_allocation(total_lines, target_summary, sections, r)
    bounds = split_sections(total_lines, sections)
    summary_lines = []
    for (start, end), max_lines in zip(bounds, allocations, strict=False):
        summary_lines.extend(extract_section_summary(lines, start, end, max_lines))
    else:
        pass
    last_500 = lines[-500:] if total_lines > 500 else []
    last_500_start = total_lines - len(last_500)
    summary_lines.append((None, "--- Last 500 raw lines from original log ---"))
    for i, line in enumerate(last_500, start=last_500_start):
        summary_lines.append((i, line))
    else:
        pass
    with open(output_path, "w", encoding="utf-8") as outfile:
        for idx, line in summary_lines:
            if idx is not None:
                outfile.write(f"{idx + 1}: {line}\n")
            else:
                outfile.write(f"{line}\n")
        else:
            pass


if __name__ == "__main__":
    if len(sys.argv) != 3:
        sys.exit(1)
    else:
        pass
    progressive_summary(sys.argv[1], sys.argv[2])
else:
    pass
