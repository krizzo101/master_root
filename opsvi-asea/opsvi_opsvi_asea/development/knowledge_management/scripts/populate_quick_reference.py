#!/usr/bin/env python3\n\"\"\"\nQuick Reference System Population Script\n=======================================\n\nCreates immediate access quick reference for common decisions and patterns.\nProvides instant knowledge access without search overhead for frequent operations.\n\"\"\"\n\nimport asyncio\nimport json\nfrom typing import Dict, List, Any\nfrom datetime import datetime\n\nclass QuickReferencePopulator:\n    \"\"\"\n    Creates quick reference entries for immediate access to common knowledge.\n    \n    Enables instant decision support and pattern access without database queries.\n    \"\"\"\n    \n    def __init__(self):\n        self.quick_reference_categories = {\n            \"tool_hierarchy\": {\n                \"priority\": 1,\n                \"description\": \"Tool usage hierarchy and standards\",\n                \"entries\": [\n                    {\n                        \"key\": \"database_operations\",\n                        \"title\": \"Database Operation Tool Priority\",\n                        \"quick_answer\": \"mcp_cognitive_tools_arango_* (primary) → mcp_multi_modal_db_arango_* (fallback) → direct AQL (last resort)\",\n                        \"context\": \"When performing database operations\",\n                        \"rationale\": \"Cognitive tools eliminate AQL errors, provide operation-based routing, reduce complexity\"\n                    },\n                    {\n                        \"key\": \"file_operations\", \n                        \"title\": \"File Operation Tool Priority\",\n                        \"quick_answer\": \"mcp_filesystem_* with absolute paths (/home/opsvi/asea/...) → native tools (deprecated)\",\n                        \"context\": \"When performing file operations\",\n                        \"rationale\": \"MCP filesystem tools more reliable, native Cursor tools have known issues\"\n                    },\n                    {\n                        \"key\": \"shell_operations\",\n                        \"title\": \"Shell Command Tool Priority\", \n                        \"quick_answer\": \"mcp_shell_shell_exec (primary) → run_terminal_cmd (fallback) → manual alternatives\",\n                        \"context\": \"When executing shell commands\",\n                        \"rationale\": \"MCP shell more efficient, native terminal broken in some contexts\"\n                    }\n                ]\n            },\n            \"behavioral_protocols\": {\n                \"priority\": 2,\n                \"description\": \"Core behavioral patterns and compliance\",\n                \"entries\": [\n                    {\n                        \"key\": \"evidence_based_operation\",\n                        \"title\": \"Evidence-Based Operation Standard\",\n                        \"quick_answer\": \"NEVER report performance improvements without measurement methodology. Test before claiming.\",\n                        \"context\": \"When making performance or improvement claims\",\n                        \"rationale\": \"Fabricated metrics undermine credibility and decision quality\"\n                    },\n                    {\n                        \"key\": \"failure_recognition\",\n                        \"title\": \"Immediate Failure Response Protocol\",\n                        \"quick_answer\": \"STOP immediately → Investigate root cause → Correct systematically → Validate fix → Document pattern\",\n                        \"context\": \"When tool failures or errors detected\",\n                        \"rationale\": \"Immediate response prevents cascading failures and captures learning\"\n                    },\n                    {\n                        \"key\": \"rule_consultation\",\n                        \"title\": \"Rule Consultation Requirement\",\n                        \"quick_answer\": \"Use fetch_rules before complex operations, reference loaded rules, document compliance\",\n                        \"context\": \"Before significant operations or decisions\",\n                        \"rationale\": \"Rules contain essential guidance that prevents operational mistakes\"\n                    }\n                ]\n            },\n            \"database_patterns\": {\n                \"priority\": 3,\n                \"description\": \"ArangoDB operation patterns and standards\",\n                \"entries\": [\n                    {\n                        \"key\": \"aql_syntax_order\",\n                        \"title\": \"AQL Query Syntax Order\",\n                        \"quick_answer\": \"FOR → FILTER → SORT → LIMIT → RETURN (MANDATORY ORDER)\",\n                        \"context\": \"When writing AQL queries\",\n                        \"rationale\": \"Incorrect order causes syntax errors, this order is required by ArangoDB\"\n                    },\n                    {\n                        \"key\": \"connection_parameters\",\n                        \"title\": \"Database Connection Parameters\",\n                        \"quick_answer\": \"Host: http://127.0.0.1:8531 (NEVER localhost), DB: asea_prod_db, User: root, Pass: arango_production_password\",\n                        \"context\": \"When connecting to database\",\n                        \"rationale\": \"Exact parameters required, localhost causes HTTP 404 errors\"\n                    },\n                    {\n                        \"key\": \"validation_pattern\",\n                        \"title\": \"Operation Validation Pattern\",\n                        \"quick_answer\": \"Check _id field exists in response (success indicator), detect empty [] when data expected\",\n                        \"context\": \"After database operations\",\n                        \"rationale\": \"Silent failures common, _id presence confirms successful operation\"\n                    }\n                ]\n            },\n            \"cognitive_operations\": {\n                \"priority\": 4,\n                \"description\": \"Cognitive enhancement and reasoning patterns\",\n                \"entries\": [\n                    {\n                        \"key\": \"thinking_tool_usage\",\n                        \"title\": \"When to Use Thinking Tool\",\n                        \"quick_answer\": \"Use for complex problems, uncertain situations, multi-step planning, or when user says 'think'\",\n                        \"context\": \"When facing complex decisions or analysis\",\n                        \"rationale\": \"Thinking tool provides structured cognitive enhancement for better outcomes\"\n                    },\n                    {\n                        \"key\": \"cognitive_operations_sequence\",\n                        \"title\": \"Cognitive Operations Sequence\",\n                        \"quick_answer\": \"CLARIFY → DECOMPOSE → FILTER → RECOGNIZE → INTEGRATE → VALIDATE\",\n                        \"context\": \"When applying cognitive enhancement\",\n                        \"rationale\": \"Systematic cognitive operations improve reasoning quality and outcomes\"\n                    },\n                    {\n                        \"key\": \"knowledge_capture\",\n                        \"title\": \"Knowledge Capture Trigger\",\n                        \"quick_answer\": \"Use 'remember' keyword → automatic knowledge capture protocol → store with quality validation\",\n                        \"context\": \"When user wants information remembered\",\n                        \"rationale\": \"Systematic capture prevents knowledge loss across sessions\"\n                    }\n                ]\n            },\n            \"workflow_patterns\": {\n                \"priority\": 5,\n                \"description\": \"Workflow execution and orchestration patterns\",\n                \"entries\": [\n                    {\n                        \"key\": \"keyword_workflow_mapping\",\n                        \"title\": \"Keyword to Workflow Mapping\",\n                        \"quick_answer\": \"startup→00-startup.yml, research→02-research.yml, implement→11-implement.yml, think→99-intelligent-thinking.yml\",\n                        \"context\": \"When keywords detected in user input\",\n                        \"rationale\": \"Automatic workflow loading provides structured approach to common tasks\"\n                    },\n                    {\n                        \"key\": \"parallel_tool_execution\",\n                        \"title\": \"Parallel Tool Execution Standard\",\n                        \"quick_answer\": \"Execute multiple read-only operations simultaneously, avoid sequential when parallel possible\",\n                        \"context\": \"When performing multiple operations\",\n                        \"rationale\": \"Parallel execution 3-5x faster, significantly improves user experience\"\n                    },\n                    {\n                        \"key\": \"git_commit_pattern\",\n                        \"title\": \"Git Commit Requirements\",\n                        \"quick_answer\": \"Commit BEFORE major changes → make modifications → commit AFTER. Use mcp_shell_shell_exec for git.\",\n                        \"context\": \"Before significant modifications\",\n                        \"rationale\": \"Pre-change commits enable safe rollback, post-change commits capture progress\"\n                    }\n                ]\n            },\n            \"decision_frameworks\": {\n                \"priority\": 6,\n                \"description\": \"Decision-making frameworks and choice patterns\",\n                \"entries\": [\n                    {\n                        \"key\": \"tool_selection_criteria\",\n                        \"title\": \"Tool Selection Decision Framework\",\n                        \"quick_answer\": \"Reliability > Feature completeness > Performance > Convenience. Choose tools that prevent mistakes over tools with more features.\",\n                        \"context\": \"When choosing between tool alternatives\",\n                        \"rationale\": \"Mistake prevention more valuable than convenience, reliability enables autonomous operation\"\n                    },\n                    {\n                        \"key\": \"quality_vs_speed_tradeoff\",\n                        \"title\": \"Quality vs Speed Decision Framework\",\n                        \"quick_answer\": \"Choose quality over speed for: evidence-based claims, operational standards, mistake prevention. Choose speed for: routine operations, iteration cycles.\",\n                        \"context\": \"When balancing quality and speed\",\n                        \"rationale\": \"High-quality foundations enable faster long-term progress\"\n                    },\n                    {\n                        \"key\": \"autonomous_vs_guided_operation\",\n                        \"title\": \"Autonomous vs Guided Operation Choice\",\n                        \"quick_answer\": \"Choose autonomous: clear requirements, established patterns, low-risk operations. Choose guided: unclear requirements, new patterns, high-risk operations.\",\n                        \"context\": \"When deciding operation approach\",\n                        \"rationale\": \"Autonomous operation maximizes efficiency, guided operation prevents mistakes in uncertain situations\"\n                    }\n                ]\n            }\n        }\n    \n    def create_quick_reference_entry(self, category: str, entry: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Create a structured quick reference entry\"\"\"\n        \n        return {\n            \"type\": \"quick_reference\",\n            \"category\": category,\n            \"key\": entry[\"key\"],\n            \"title\": entry[\"title\"],\n            \"quick_answer\": entry[\"quick_answer\"],\n            \"context\": entry[\"context\"],\n            \"rationale\": entry[\"rationale\"],\n            \"access_pattern\": \"immediate\",\n            \"usage_frequency\": \"high\" if category in [\"tool_hierarchy\", \"behavioral_protocols\"] else \"medium\",\n            \"priority_level\": self.quick_reference_categories[category][\"priority\"],\n            \"keywords\": self._extract_keywords(entry),\n            \"related_domains\": self._map_to_domains(category),\n            \"operational_impact\": \"high\",\n            \"created\": datetime.now().isoformat(),\n            \"updated\": datetime.now().isoformat()\n        }\n    \n    def _extract_keywords(self, entry: Dict[str, Any]) -> List[str]:\n        \"\"\"Extract keywords from entry for fast lookup\"\"\"\n        text = f\"{entry['title']} {entry['context']} {entry['quick_answer']}\".lower()\n        \n        # Common important keywords\n        important_keywords = [\n            \"tool\", \"database\", \"file\", \"shell\", \"mcp\", \"arango\", \"aql\",\n            \"evidence\", \"failure\", \"rule\", \"quality\", \"performance\", \n            \"cognitive\", \"thinking\", \"workflow\", \"parallel\", \"git\",\n            \"decision\", \"autonomous\", \"standard\", \"protocol\", \"pattern\"\n        ]\n        \n        found_keywords = []\n        for keyword in important_keywords:\n            if keyword in text:\n                found_keywords.append(keyword)\n        \n        # Add specific keywords from content\n        if \"hierarchy\" in text or \"priority\" in text:\n            found_keywords.append(\"hierarchy\")\n        if \"commit\" in text:\n            found_keywords.append(\"commit\")\n        if \"validation\" in text or \"validate\" in text:\n            found_keywords.append(\"validation\")\n        \n        return list(set(found_keywords))\n    \n    def _map_to_domains(self, category: str) -> List[str]:\n        \"\"\"Map quick reference category to knowledge domains\"\"\"\n        domain_mapping = {\n            \"tool_hierarchy\": [\"tool_evolution\", \"behavioral_patterns\"],\n            \"behavioral_protocols\": [\"behavioral_patterns\"],\n            \"database_patterns\": [\"database_operations\", \"behavioral_patterns\"],\n            \"cognitive_operations\": [\"cognitive_research\"],\n            \"workflow_patterns\": [\"workflow_orchestration\", \"behavioral_patterns\"],\n            \"decision_frameworks\": [\"cognitive_research\", \"behavioral_patterns\"]\n        }\n        return domain_mapping.get(category, [\"general\"])\n    \n    def populate_quick_reference(self) -> Dict[str, Any]:\n        \"\"\"Populate the quick reference collection\"\"\"\n        \n        results = {\n            \"categories_processed\": 0,\n            \"entries_created\": 0,\n            \"errors\": [],\n            \"category_details\": []\n        }\n        \n        print(\"⚡ Creating Quick Reference System...\")\n        \n        # Create quick reference entries by category\n        for category_name, category_info in self.quick_reference_categories.items():\n            try:\n                print(f\"\\nProcessing category: {category_name}\")\n                print(f\"  Priority: {category_info['priority']}\")\n                print(f\"  Description: {category_info['description']}\")\n                \n                category_entries = 0\n                \n                for entry in category_info[\"entries\"]:\n                    try:\n                        quick_ref_entry = self.create_quick_reference_entry(category_name, entry)\n                        \n                        print(f\"  Creating entry: {entry['key']}\")\n                        print(f\"    Title: {entry['title']}\")\n                        print(f\"    Keywords: {len(quick_ref_entry['keywords'])} keywords\")\n                        \n                        # Store result for verification (simulated)\n                        category_entries += 1\n                        results[\"entries_created\"] += 1\n                        \n                        # In real implementation, would use:\n                        # mcp_cognitive_tools_arango_modify(\n                        #     operation=\"insert\",\n                        #     collection=\"quick_reference\",\n                        #     document=quick_ref_entry\n                        # )\n                        \n                    except Exception as e:\n                        error_msg = f\"Failed to create entry {entry['key']}: {str(e)}\"\n                        results[\"errors\"].append(error_msg)\n                        print(f\"    ❌ {error_msg}\")\n                \n                results[\"categories_processed\"] += 1\n                results[\"category_details\"].append({\n                    \"category\": category_name,\n                    \"priority\": category_info[\"priority\"],\n                    \"entries_count\": category_entries,\n                    \"description\": category_info[\"description\"]\n                })\n                \n                print(f\"  ✅ Created {category_entries} entries for {category_name}\")\n                \n            except Exception as e:\n                error_msg = f\"Failed to process category {category_name}: {str(e)}\"\n                results[\"errors\"].append(error_msg)\n                print(f\"❌ {error_msg}\")\n        \n        return results\n    \n    def create_quick_access_index(self) -> Dict[str, Any]:\n        \"\"\"Create quick access index for fast lookup\"\"\"\n        \n        index = {\n            \"type\": \"quick_reference_index\",\n            \"keyword_map\": {},\n            \"category_map\": {},\n            \"context_map\": {},\n            \"priority_map\": {},\n            \"created\": datetime.now().isoformat()\n        }\n        \n        print(\"\\n📇 Creating Quick Access Index...\")\n        \n        for category_name, category_info in self.quick_reference_categories.items():\n            # Category mapping\n            index[\"category_map\"][category_name] = {\n                \"priority\": category_info[\"priority\"],\n                \"description\": category_info[\"description\"],\n                \"entry_count\": len(category_info[\"entries\"])\n            }\n            \n            # Priority mapping\n            priority = category_info[\"priority\"]\n            if priority not in index[\"priority_map\"]:\n                index[\"priority_map\"][priority] = []\n            index[\"priority_map\"][priority].append(category_name)\n            \n            for entry in category_info[\"entries\"]:\n                entry_key = entry[\"key\"]\n                \n                # Context mapping\n                context_words = entry[\"context\"].lower().split()\n                for word in context_words:\n                    if len(word) > 3:  # Skip short words\n                        if word not in index[\"context_map\"]:\n                            index[\"context_map\"][word] = []\n                        index[\"context_map\"][word].append({\n                            \"category\": category_name,\n                            \"key\": entry_key,\n                            \"title\": entry[\"title\"]\n                        })\n                \n                # Keyword mapping\n                quick_ref_entry = self.create_quick_reference_entry(category_name, entry)\n                for keyword in quick_ref_entry[\"keywords\"]:\n                    if keyword not in index[\"keyword_map\"]:\n                        index[\"keyword_map\"][keyword] = []\n                    index[\"keyword_map\"][keyword].append({\n                        \"category\": category_name,\n                        \"key\": entry_key,\n                        \"title\": entry[\"title\"],\n                        \"priority\": category_info[\"priority\"]\n                    })\n        \n        print(f\"  Keywords indexed: {len(index['keyword_map'])}\")\n        print(f\"  Context words indexed: {len(index['context_map'])}\")\n        print(f\"  Categories indexed: {len(index['category_map'])}\")\n        \n        return index\n    \n    def generate_usage_examples(self) -> List[Dict[str, Any]]:\n        \"\"\"Generate usage examples for quick reference system\"\"\"\n        \n        examples = [\n            {\n                \"scenario\": \"Database Operation Needed\",\n                \"user_context\": \"Need to query cognitive_concepts collection\",\n                \"quick_reference_lookup\": \"keyword: database → tool_hierarchy/database_operations\",\n                \"immediate_answer\": \"Use mcp_cognitive_tools_arango_search (primary) for operation-based routing\",\n                \"rationale\": \"Eliminates AQL syntax errors, provides validated operations\"\n            },\n            {\n                \"scenario\": \"Tool Choice Decision\",\n                \"user_context\": \"Choosing between mcp_filesystem and native file tools\",\n                \"quick_reference_lookup\": \"keyword: file → tool_hierarchy/file_operations\",\n                \"immediate_answer\": \"Use mcp_filesystem_* with absolute paths (/home/opsvi/asea/...)\",\n                \"rationale\": \"More reliable than native tools, avoids known Cursor tool issues\"\n            },\n            {\n                \"scenario\": \"Performance Claim Validation\",\n                \"user_context\": \"Want to report performance improvement\",\n                \"quick_reference_lookup\": \"keyword: performance → behavioral_protocols/evidence_based_operation\",\n                \"immediate_answer\": \"NEVER report improvements without measurement methodology\",\n                \"rationale\": \"Prevents fabricated metrics, maintains credibility\"\n            },\n            {\n                \"scenario\": \"Complex Problem Analysis\",\n                \"user_context\": \"Facing multi-step analytical task\",\n                \"quick_reference_lookup\": \"keyword: thinking → cognitive_operations/thinking_tool_usage\",\n                \"immediate_answer\": \"Use thinking tool for structured cognitive enhancement\",\n                \"rationale\": \"Provides systematic reasoning approach for better outcomes\"\n            },\n            {\n                \"scenario\": \"AQL Query Writing\",\n                \"user_context\": \"Writing database query\",\n                \"quick_reference_lookup\": \"keyword: aql → database_patterns/aql_syntax_order\",\n                \"immediate_answer\": \"FOR → FILTER → SORT → LIMIT → RETURN (mandatory order)\",\n                \"rationale\": \"Prevents syntax errors, required by ArangoDB\"\n            }\n        ]\n        \n        return examples\n    \n    def generate_summary_report(self, results: Dict[str, Any], index: Dict[str, Any]) -> str:\n        \"\"\"Generate summary report of quick reference population\"\"\"\n        \n        examples = self.generate_usage_examples()\n        \n        report = f\"\"\"\n# Quick Reference System Population Results\n\n## Summary\n- **Categories Processed**: {results['categories_processed']}\n- **Entries Created**: {results['entries_created']}\n- **Keywords Indexed**: {len(index['keyword_map'])}\n- **Context Words Indexed**: {len(index['context_map'])}\n- **Errors**: {len(results['errors'])}\n\n## Category Breakdown\n\"\"\"\n        \n        # Sort by priority\n        sorted_categories = sorted(results[\"category_details\"], key=lambda x: x[\"priority\"])\n        \n        for category in sorted_categories:\n            report += f\"\"\"\n### {category['category'].replace('_', ' ').title()} (Priority {category['priority']})\n- **Description**: {category['description']}\n- **Entries**: {category['entries_count']}\n\"\"\"\n        \n        report += \"\\n## Usage Examples\\n\"\n        \n        for i, example in enumerate(examples, 1):\n            report += f\"\"\"\n### Example {i}: {example['scenario']}\n- **Context**: {example['user_context']}\n- **Lookup**: {example['quick_reference_lookup']}\n- **Answer**: {example['immediate_answer']}\n- **Rationale**: {example['rationale']}\n\"\"\"\n        \n        if results[\"errors\"]:\n            report += \"\\n## Errors\\n\"\n            for error in results[\"errors\"]:\n                report += f\"- {error}\\n\"\n        \n        report += f\"\"\"\n\n## Impact\n- **Immediate Access**: No database queries needed for common decisions\n- **Consistent Standards**: Standardized answers prevent operational variation\n- **Mistake Prevention**: Built-in rationale prevents common errors\n- **Efficiency**: Instant answers for frequent operations\n- **Learning Support**: Rationale helps build understanding\n\n## Integration Points\n- **Context Detection**: Keywords and context words enable automatic loading\n- **Domain Mapping**: Links to knowledge domains for deeper context\n- **Priority System**: Ensures critical information prioritized\n- **Workflow Integration**: Supports automated decision-making\n\n## Next Steps\n1. Populate context_relevance_map collection\n2. Enhance knowledge inventory automation\n3. Test quick reference integration with workflows\n4. Create automatic quick reference updates\n\"\"\"\n        \n        return report\n\ndef main():\n    \"\"\"Main execution function\"\"\"\n    print(\"🚀 Starting Quick Reference System Population...\\n\")\n    \n    populator = QuickReferencePopulator()\n    results = populator.populate_quick_reference()\n    \n    # Create quick access index\n    index = populator.create_quick_access_index()\n    \n    # Generate and save results\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    \n    # Save results\n    results_file = f\"/home/opsvi/asea/development/knowledge_management/results/quick_reference_results_{timestamp}.json\"\n    with open(results_file, 'w') as f:\n        json.dump(results, f, indent=2)\n    \n    # Save index\n    index_file = f\"/home/opsvi/asea/development/knowledge_management/results/quick_reference_index_{timestamp}.json\"\n    with open(index_file, 'w') as f:\n        json.dump(index, f, indent=2)\n    \n    # Generate summary report\n    summary_report = populator.generate_summary_report(results, index)\n    print(\"\\n\" + \"=\"*60)\n    print(summary_report)\n    print(\"=\"*60)\n    \n    # Save summary report\n    report_file = f\"/home/opsvi/asea/development/knowledge_management/results/quick_reference_summary_{timestamp}.md\"\n    with open(report_file, 'w') as f:\n        f.write(summary_report)\n    \n    print(f\"\\n✅ Results saved to: {results_file}\")\n    print(f\"✅ Index saved to: {index_file}\") \n    print(f\"✅ Summary saved to: {report_file}\")\n    \n    return results, index\n\nif __name__ == \"__main__\":\n    main()\n"
