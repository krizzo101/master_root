"""Result processing pipeline for task execution results."""

import asyncio
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timezone
from uuid import UUID

from memory.graph.client import Neo4jClient
from auto_forge.config.models import TaskRecord, Result, Critique

logger = logging.getLogger(__name__)


class ResultProcessor:
    """Processes and stores task execution results.

    This class handles the collection, processing, and storage of
    task execution results, including status updates and lineage tracking.
    """

    def __init__(self, neo4j_client: Neo4jClient):
        self.neo4j_client = neo4j_client
        self.processed_results: Dict[str, Dict[str, Any]] = {}

    async def process_task_result(
        self,
        task_id: str,
        result: Dict[str, Any],
        project_id: str,
        run_id: str,
        agent_type: str
    ) -> Dict[str, Any]:
        """Process and store a task result.

        Args:
            task_id: Task ID
            result: Task execution result
            project_id: Project ID
            run_id: Run ID
            agent_type: Type of agent that executed the task

        Returns:
            Processed result data
        """
        try:
            logger.info(f"Processing result for task {task_id}")

            # Create result record
            result_record = Result(
                status=result.get("status", "unknown"),
                score=result.get("score", 0.0),
                metrics=result.get("metrics", {}),
                errors=result.get("errors", []),
                warnings=result.get("warnings", []),
                execution_time_seconds=result.get("execution_time_seconds", 0.0)
            )

            # Store result in Neo4j
            result_id = await self._store_result_in_neo4j(
                task_id=task_id,
                result_record=result_record,
                project_id=project_id,
                run_id=run_id,
                agent_type=agent_type
            )

            # Update task status
            await self._update_task_status(
                task_id=task_id,
                status=result.get("status", "unknown"),
                result_id=result_id
            )

            # Process lineage tracking
            await self._process_lineage(
                task_id=task_id,
                result=result,
                project_id=project_id,
                run_id=run_id
            )

            # Store processed result
            processed_result = {
                "result_id": result_id,
                "status": result.get("status"),
                "score": result.get("score", 0.0),
                "metrics": result.get("metrics", {}),
                "agent_type": agent_type,
                "processed_at": datetime.now(timezone.utc).isoformat()
            }

            self.processed_results[task_id] = processed_result

            logger.info(f"Result processed successfully for task {task_id}")
            return processed_result

        except Exception as e:
            logger.error(f"Failed to process result for task {task_id}: {e}")
            raise

    async def process_pipeline_results(
        self,
        run_id: str,
        results: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Process results for an entire pipeline run.

        Args:
            run_id: Run ID
            results: Dictionary of task results

        Returns:
            Pipeline summary
        """
        logger.info(f"Processing pipeline results for run {run_id}")

        summary = {
            "total_tasks": len(results),
            "completed_tasks": 0,
            "failed_tasks": 0,
            "average_score": 0.0,
            "total_cost": 0.0,
            "total_tokens": 0,
            "total_execution_time": 0.0,
            "agent_performance": {},
            "task_results": {}
        }

        scores = []
        agent_stats = {}

        for task_id, result in results.items():
            # Update counters
            if result.get("status") == "ok":
                summary["completed_tasks"] += 1
                scores.append(result.get("score", 0.0))
                summary["total_cost"] += result.get("cost", 0.0)
                summary["total_tokens"] += result.get("tokens_used", 0)
                summary["total_execution_time"] += result.get("execution_time_seconds", 0.0)
            else:
                summary["failed_tasks"] += 1

            # Track agent performance
            agent_type = result.get("agent_type", "unknown")
            if agent_type not in agent_stats:
                agent_stats[agent_type] = {
                    "total_tasks": 0,
                    "successful_tasks": 0,
                    "total_score": 0.0,
                    "total_cost": 0.0,
                    "total_tokens": 0
                }

            agent_stats[agent_type]["total_tasks"] += 1
            if result.get("status") == "ok":
                agent_stats[agent_type]["successful_tasks"] += 1
                agent_stats[agent_type]["total_score"] += result.get("score", 0.0)
                agent_stats[agent_type]["total_cost"] += result.get("cost", 0.0)
                agent_stats[agent_type]["total_tokens"] += result.get("tokens_used", 0)

            # Store individual task result
            summary["task_results"][task_id] = {
                "status": result.get("status"),
                "score": result.get("score", 0.0),
                "agent_type": agent_type,
                "execution_time": result.get("execution_time_seconds", 0.0),
                "cost": result.get("cost", 0.0),
                "tokens_used": result.get("tokens_used", 0)
            }

        # Calculate averages
        if scores:
            summary["average_score"] = sum(scores) / len(scores)

        # Calculate agent performance metrics
        for agent_type, stats in agent_stats.items():
            if stats["total_tasks"] > 0:
                summary["agent_performance"][agent_type] = {
                    "total_tasks": stats["total_tasks"],
                    "success_rate": stats["successful_tasks"] / stats["total_tasks"],
                    "average_score": stats["total_score"] / stats["successful_tasks"] if stats["successful_tasks"] > 0 else 0.0,
                    "total_cost": stats["total_cost"],
                    "total_tokens": stats["total_tokens"]
                }

        # Store pipeline summary
        await self._store_pipeline_summary(run_id, summary)

        logger.info(f"Pipeline results processed for run {run_id}")
        return summary

    async def _store_result_in_neo4j(
        self,
        task_id: str,
        result_record: Result,
        project_id: str,
        run_id: str,
        agent_type: str
    ) -> str:
        """Store result in Neo4j database.

        Args:
            task_id: Task ID
            result_record: Result record to store
            project_id: Project ID
            run_id: Run ID
            agent_type: Agent type

        Returns:
            Result ID
        """
        result_id = f"result_{task_id}_{datetime.now().isoformat()}"

        # Create result node
        result_query = """
        CREATE (r:Result {
            id: $result_id,
            task_id: $task_id,
            status: $status,
            score: $score,
            metrics: $metrics,
            errors: $errors,
            warnings: $warnings,
            execution_time_seconds: $execution_time,
            created_at: datetime()
        })
        """

        await self.neo4j_client.execute_query(
            result_query,
            {
                "result_id": result_id,
                "task_id": task_id,
                "status": result_record.status,
                "score": result_record.score,
                "metrics": result_record.metrics,
                "errors": result_record.errors,
                "warnings": result_record.warnings,
                "execution_time": result_record.execution_time_seconds
            }
        )

        # Create relationships
        relationships_query = """
        MATCH (t:TaskRecord {id: $task_id})
        MATCH (r:Result {id: $result_id})
        MATCH (p:Project {id: $project_id})
        MATCH (run:Run {id: $run_id})

        CREATE (t)-[:RESULTED_IN]->(r)
        CREATE (r)-[:BELONGS_TO_PROJECT]->(p)
        CREATE (r)-[:BELONGS_TO_RUN]->(run)

        WITH t, r
        MATCH (a:Agent {type: $agent_type})
        CREATE (a)-[:EXECUTED]->(r)
        """

        await self.neo4j_client.execute_query(
            relationships_query,
            {
                "task_id": task_id,
                "result_id": result_id,
                "project_id": project_id,
                "run_id": run_id,
                "agent_type": agent_type
            }
        )

        return result_id

    async def _update_task_status(
        self,
        task_id: str,
        status: str,
        result_id: str
    ) -> None:
        """Update task status in Neo4j.

        Args:
            task_id: Task ID
            status: New status
            result_id: Result ID
        """
        update_query = """
        MATCH (t:TaskRecord {id: $task_id})
        SET t.status = $status,
            t.result_id = $result_id,
            t.completed_at = datetime()
        """

        await self.neo4j_client.execute_query(
            update_query,
            {
                "task_id": task_id,
                "status": status,
                "result_id": result_id
            }
        )

    async def _process_lineage(
        self,
        task_id: str,
        result: Dict[str, Any],
        project_id: str,
        run_id: str
    ) -> None:
        """Process lineage tracking for task result.

        Args:
            task_id: Task ID
            result: Task result
            project_id: Project ID
            run_id: Run ID
        """
        # Create lineage relationships
        lineage_query = """
        MATCH (t:TaskRecord {id: $task_id})
        MATCH (p:Project {id: $project_id})
        MATCH (run:Run {id: $run_id})

        CREATE (t)-[:PART_OF_RUN]->(run)
        CREATE (run)-[:BELONGS_TO_PROJECT]->(p)

        WITH t, run
        MATCH (prev:TaskRecord)-[:PART_OF_RUN]->(run)
        WHERE prev.id <> $task_id
        CREATE (prev)-[:PRECEDES]->(t)
        """

        await self.neo4j_client.execute_query(
            lineage_query,
            {
                "task_id": task_id,
                "project_id": project_id,
                "run_id": run_id
            }
        )

    async def _store_pipeline_summary(
        self,
        run_id: str,
        summary: Dict[str, Any]
    ) -> None:
        """Store pipeline summary in Neo4j.

        Args:
            run_id: Run ID
            summary: Pipeline summary
        """
        summary_query = """
        MATCH (r:Run {id: $run_id})
        SET r.summary = $summary,
            r.completed_at = datetime(),
            r.total_tasks = $total_tasks,
            r.completed_tasks = $completed_tasks,
            r.successful_tasks = $successful_tasks,
            r.failed_tasks = $failed_tasks,
            r.total_tokens = $total_tokens,
            r.total_cost = $total_cost
        """

        await self.neo4j_client.execute_query(
            summary_query,
            {
                "run_id": run_id,
                "summary": summary,
                "total_tasks": summary["total_tasks"],
                "completed_tasks": summary["completed_tasks"],
                "successful_tasks": summary["completed_tasks"],
                "failed_tasks": summary["failed_tasks"],
                "total_tokens": summary["total_tokens"],
                "total_cost": summary["total_cost"]
            }
        )

    async def get_task_result(self, task_id: str) -> Optional[Dict[str, Any]]:
        """Get processed result for a task.

        Args:
            task_id: Task ID

        Returns:
            Processed result or None if not found
        """
        return self.processed_results.get(task_id)

    async def get_pipeline_summary(self, run_id: str) -> Optional[Dict[str, Any]]:
        """Get pipeline summary for a run.

        Args:
            run_id: Run ID

        Returns:
            Pipeline summary or None if not found
        """
        query = """
        MATCH (r:Run {id: $run_id})
        RETURN r.summary as summary
        """

        result = await self.neo4j_client.execute_query(query, {"run_id": run_id})

        if result:
            return result[0]["summary"]
        return None

    def get_processed_results_count(self) -> int:
        """Get count of processed results.

        Returns:
            Number of processed results
        """
        return len(self.processed_results)

    def clear_processed_results(self) -> None:
        """Clear processed results from memory."""
        self.processed_results.clear()
        logger.info("Cleared processed results from memory")