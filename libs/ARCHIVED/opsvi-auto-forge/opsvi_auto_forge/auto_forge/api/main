"""Main FastAPI application for the autonomous software factory."""

import logging
import time
from contextlib import asynccontextmanager
from typing import Dict, Any
from datetime import datetime, timezone

from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.staticfiles import StaticFiles
from prometheus_client import Counter, Histogram, Gauge, make_asgi_app
import structlog
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import traceback
from fastapi.exception_handlers import RequestValidationError
from fastapi.exceptions import RequestValidationError as FastAPIRequestValidationError
from starlette.middleware.base import BaseHTTPMiddleware

from auto_forge.config.settings import settings
from .routes import health, runs, tasks, projects, websockets, debug, decisions
from memory.graph.client import Neo4jClient
from auto_forge.application.orchestrator.registry import TaskRegistryManager
from monitoring.metrics.decision_metrics import (
    ro_evidence_retrieval_success_total,
    ro_evidence_retrieval_failure_total
)

# Configure structured logging
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer(),
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

logger = structlog.get_logger()

# Prometheus metrics
REQUEST_COUNT = Counter(
    "http_requests_total", "Total HTTP requests", ["method", "endpoint", "status"]
)

REQUEST_LATENCY = Histogram(
    "http_request_duration_seconds", "HTTP request latency", ["method", "endpoint"]
)

ACTIVE_REQUESTS = Gauge(
    "http_requests_in_progress",
    "Number of HTTP requests in progress",
    ["method", "endpoint"],
)

# Global state
neo4j_client: Neo4jClient = None
task_registry: TaskRegistryManager = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager."""
    global neo4j_client, task_registry

    # Startup
    logger.info("Starting Autonomous Software Factory API")

    try:
        # Initialize Neo4j client
        neo4j_client = Neo4jClient()
        await neo4j_client.connect()
        logger.info("Connected to Neo4j database")

        # Set up schema
        from memory.graph.schema import setup_schema

        await setup_schema(neo4j_client)
        logger.info("Neo4j schema setup completed")

        # Initialize task registry
        task_registry = TaskRegistryManager(neo4j_client)
        await task_registry.load_default_tasks()
        logger.info("Task registry initialized")

    except Exception as e:
        logger.error(f"Failed to initialize application: {e}")
        raise

    yield

    # Shutdown
    logger.info("Shutting down Autonomous Software Factory API")

    if neo4j_client:
        await neo4j_client.disconnect()
        logger.info("Disconnected from Neo4j database")


# Create FastAPI application
app = FastAPI(
    title=settings.app_name,
    version=settings.app_version,
    description="Autonomous software factory with critic-gated loops and full lineage tracking",
    docs_url="/docs" if settings.debug else None,
    redoc_url="/redoc" if settings.debug else None,
    lifespan=lifespan,
)

# Add middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(GZipMiddleware, minimum_size=1000)


@app.middleware("http")
async def metrics_middleware(request: Request, call_next):
    """Middleware to collect Prometheus metrics."""
    method = request.method
    endpoint = request.url.path

    # Track active requests
    ACTIVE_REQUESTS.labels(method=method, endpoint=endpoint).inc()

    # Track request latency
    with REQUEST_LATENCY.labels(method=method, endpoint=endpoint).time():
        response = await call_next(request)

    # Track request count
    REQUEST_COUNT.labels(
        method=method, endpoint=endpoint, status=response.status_code
    ).inc()

    # Decrease active requests
    ACTIVE_REQUESTS.labels(method=method, endpoint=endpoint).dec()

    return response


@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    """Middleware for structured logging."""
    start_time = time.time()

    # Log request
    logger.info(
        "HTTP request started",
        method=request.method,
        url=str(request.url),
        client_ip=request.client.host if request.client else None,
        user_agent=request.headers.get("user-agent"),
    )

    response = await call_next(request)

    # Log response
    process_time = time.time() - start_time
    logger.info(
        "HTTP request completed",
        method=request.method,
        url=str(request.url),
        status_code=response.status_code,
        process_time=process_time,
    )

    return response


class LogRequestBodyMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        if request.method == "POST" and (
            request.url.path.startswith("/projects")
            or request.url.path.startswith("/runs")
        ):
            body = await request.body()
            logger = logging.getLogger("uvicorn.error")
            logger.error(f"INCOMING {request.method} {request.url.path} BODY: {body}")
        response = await call_next(request)
        return response


app.add_middleware(LogRequestBodyMiddleware)


# Mount Prometheus metrics
if settings.prometheus_enabled:
    metrics_app = make_asgi_app()
    app.mount("/metrics", metrics_app)
    logger.info("Prometheus metrics endpoint mounted at /metrics")


# Mount static files
app.mount("/static", StaticFiles(directory="api/static"), name="static")

# Include routers
app.include_router(health.router, prefix="/health", tags=["health"])
app.include_router(projects.router, prefix="/projects", tags=["projects"])
app.include_router(runs.router, prefix="/runs", tags=["runs"])
app.include_router(tasks.router, prefix="/tasks", tags=["tasks"])
app.include_router(websockets.router, tags=["websockets"])
app.include_router(debug.router, prefix="/debug", tags=["debug"])
app.include_router(decisions.router, tags=["decisions"])

# Include authentication router
from .auth import auth_router
app.include_router(auth_router, prefix="/auth", tags=["authentication"])


# Override the create_project route with a debug version
@app.post("/projects/")
async def create_project_override(project: Any):
    """Override route to accept any payload and log it."""
    import logging

    logger = logging.getLogger("uvicorn.error")
    logger.error(f"OVERRIDE ROUTE CALLED: {project}")
    logger.error(f"OVERRIDE ROUTE TYPE: {type(project)}")
    return {"echo": str(project), "type": str(type(project))}


@app.post("/test-projects")
async def test_projects(project: Any):
    """Test route to verify FastAPI behavior."""
    import logging

    logger = logging.getLogger("uvicorn.error")
    logger.error(f"TEST ROUTE CALLED: {project}")
    logger.error(f"TEST ROUTE TYPE: {type(project)}")
    return {"echo": str(project), "type": str(type(project))}


@app.get("/")
async def root() -> Dict[str, Any]:
    """Root endpoint."""
    return {
        "name": settings.app_name,
        "version": settings.app_version,
        "status": "running",
        "docs": "/docs" if settings.debug else None,
        "metrics": "/metrics" if settings.prometheus_enabled else None,
        "ui": "/ui" if settings.debug else None,
    }


@app.get("/ui")
async def ui():
    """Serve the operator UI."""
    from fastapi.responses import FileResponse

    return FileResponse("api/static/index.html")


@app.get("/health")
async def health_check() -> Dict[str, Any]:
    """Health check endpoint."""
    health_status = {
        "status": "healthy",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "version": settings.app_version,
        "services": {},
    }

    # Check Neo4j connection
    try:
        if neo4j_client:
            await neo4j_client.execute_query("RETURN 1 as test")
            health_status["services"]["neo4j"] = "healthy"
        else:
            health_status["services"]["neo4j"] = "not_initialized"
    except Exception as e:
        health_status["services"]["neo4j"] = f"unhealthy: {e}"
        health_status["status"] = "unhealthy"

    return health_status


# Error handlers
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler."""
    logger.error(
        "Unhandled exception",
        method=request.method,
        url=str(request.url),
        error=str(exc),
        exc_info=True,
    )

    return JSONResponse(
        content={"detail": "Internal server error"},
        status_code=500,
    )


@app.exception_handler(FastAPIRequestValidationError)
async def validation_exception_handler(
    request: Request, exc: FastAPIRequestValidationError
):
    """Validation exception handler."""
    logger.error(f"VALIDATION ERROR: {exc}")
    logger.error(traceback.format_exc())
    return JSONResponse(
        status_code=422,
        content={"detail": exc.errors(), "body": exc.body},
    )


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "api.main:app",
        host=settings.api_host,
        port=settings.api_port,
        reload=settings.debug,
        workers=1 if settings.debug else settings.api_workers,
    )
