<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Software Factory - Operator Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #00ff88;
            font-size: 2rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #00ff88;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            min-height: 400px;
        }

        .panel h2 {
            color: #00ff88;
            margin-bottom: 15px;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #cccccc;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a1a;
            color: #ffffff;
            font-size: 14px;
        }

        .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .btn {
            background: #00ff88;
            color: #1a1a1a;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #00cc6a;
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #666;
        }

        .btn-secondary:hover {
            background: #555;
        }

        .log-container {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }

        .log-entry.info {
            background: #1a3a1a;
            color: #00ff88;
        }

        .log-entry.error {
            background: #3a1a1a;
            color: #ff4444;
        }

        .log-entry.warning {
            background: #3a3a1a;
            color: #ffff44;
        }

        .log-entry.debug {
            background: #1a1a3a;
            color: #4444ff;
        }

        .dag-container {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            height: 300px;
            overflow: auto;
        }

        .dag-node {
            background: #2d2d2d;
            border: 2px solid #444;
            border-radius: 6px;
            padding: 10px;
            margin: 10px;
            display: inline-block;
            min-width: 120px;
            text-align: center;
        }

        .dag-node.running {
            border-color: #00ff88;
            background: #1a3a1a;
        }

        .dag-node.completed {
            border-color: #00ff88;
            background: #1a3a1a;
        }

        .dag-node.failed {
            border-color: #ff4444;
            background: #3a1a1a;
        }

        .dag-node.pending {
            border-color: #ffff44;
            background: #3a3a1a;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            text-align: center;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ff88;
        }

        .metric-label {
            color: #cccccc;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Autonomous Software Factory</h1>
            <div class="status-indicator">
                <span id="connection-status">Disconnected</span>
                <div id="status-dot" class="status-dot"></div>
            </div>
        </div>

        <div class="metrics">
            <div class="metric-card">
                <div id="active-runs" class="metric-value">0</div>
                <div class="metric-label">Active Runs</div>
            </div>
            <div class="metric-card">
                <div id="total-tasks" class="metric-value">0</div>
                <div class="metric-label">Total Tasks</div>
            </div>
            <div class="metric-card">
                <div id="completed-tasks" class="metric-value">0</div>
                <div class="metric-label">Completed</div>
            </div>
            <div class="metric-card">
                <div id="failed-tasks" class="metric-value">0</div>
                <div class="metric-label">Failed</div>
            </div>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>üöÄ Start New Run</h2>
                <form id="run-form">
                    <div class="form-group">
                        <label for="project-name">Project Name:</label>
                        <input type="text" id="project-name" name="project_name" required
                               placeholder="Enter project name">
                    </div>
                    <div class="form-group">
                        <label for="project-description">Description:</label>
                        <textarea id="project-description" name="description"
                                  placeholder="Enter project description"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="pipeline-type">Pipeline Type:</label>
                        <select id="pipeline-type" name="pipeline_type">
                            <option value="software_factory_v1">Software Factory v1</option>
                            <option value="simple_api">Simple API</option>
                            <option value="web_app">Web Application</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="requirements">Requirements:</label>
                        <textarea id="requirements" name="requirements"
                                  placeholder="Enter project requirements"></textarea>
                    </div>
                    <div class="controls">
                        <button type="submit" class="btn" id="start-run-btn">Start Run</button>
                        <button type="button" class="btn btn-secondary" id="clear-form-btn">Clear</button>
                    </div>
                </form>
            </div>

            <div class="panel">
                <h2>üìä DAG Visualization</h2>
                <div class="controls">
                    <button class="btn btn-secondary" id="refresh-dag-btn">Refresh</button>
                    <button class="btn btn-secondary" id="auto-refresh-btn">Auto Refresh</button>
                </div>
                <div style="display: flex; height: 400px;">
                    <div id="dag-container" class="dag-container" style="flex: 1; overflow-y: auto;">
                        <p style="text-align: center; color: #666; margin-top: 100px;">
                            No active runs to display
                        </p>
                    </div>
                    <div id="debug-log" style="width: 350px; background: #1a1a1a; border-left: 1px solid #333; padding: 10px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px;">
                        <div style="color: #00ff88; font-weight: bold; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px;">üîç Debug Log</div>
                        <div id="debug-log-content" style="color: #ccc; line-height: 1.4;">
                            <div style="color: #666;">Waiting for activity...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üîÑ Pipeline Flow Visualization</h2>
            <div class="controls">
                <button class="btn btn-secondary" id="refresh-pipeline-btn">Refresh</button>
                <button class="btn btn-secondary" id="auto-refresh-pipeline-btn">Auto Refresh</button>
                <select id="run-selector" style="margin-left: 10px; padding: 5px; background: #1a1a1a; color: #ffffff; border: 1px solid #444; border-radius: 4px;">
                    <option value="">Select a run...</option>
                </select>
            </div>
            <div id="pipeline-container" class="pipeline-container">
                <div class="pipeline-header">
                    <div class="pipeline-title">Pipeline Status</div>
                    <div class="pipeline-stats">
                        <div class="pipeline-stat">
                            <div class="pipeline-stat-value" id="total-stages">0</div>
                            <div class="pipeline-stat-label">Total Stages</div>
                        </div>
                        <div class="pipeline-stat">
                            <div class="pipeline-stat-value" id="completed-stages">0</div>
                            <div class="pipeline-stat-label">Completed</div>
                        </div>
                        <div class="pipeline-stat">
                            <div class="pipeline-stat-value" id="running-stages">0</div>
                            <div class="pipeline-stat-label">Running</div>
                        </div>
                        <div class="pipeline-stat">
                            <div class="pipeline-stat-value" id="failed-stages">0</div>
                            <div class="pipeline-stat-label">Failed</div>
                        </div>
                    </div>
                </div>
                <div id="pipeline-visualization" style="height: 600px; overflow: hidden;">
                    <p style="text-align: center; color: #666; margin-top: 200px;">
                        Select a run to view pipeline visualization
                    </p>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üìù Real-time Logs</h2>
            <div class="controls">
                <button class="btn btn-secondary" id="clear-logs-btn">Clear Logs</button>
                <button class="btn btn-secondary" id="export-logs-btn">Export</button>
                <label>
                    <input type="checkbox" id="auto-scroll" checked> Auto-scroll
                </label>
            </div>
            <div id="log-container" class="log-container"></div>
        </div>
    </div>

    <script src="/static/pipeline-visualization.js"></script>
    <script>
        class AutonomousFactoryUI {
            constructor() {
                this.ws = null;
                this.connected = false;
                this.autoRefresh = false;
                this.autoRefreshInterval = null;
                this.logContainer = document.getElementById('log-container');
                this.debugLogContent = document.getElementById('debug-log-content');
                this.connectionStatus = document.getElementById('connection-status');
                this.statusDot = document.getElementById('status-dot');
                this.runningJobs = new Set(); // Track running jobs for status updates
                this.pipelineVisualization = null; // Pipeline visualization instance
                this.autoRefreshPipeline = false;
                this.autoRefreshPipelineInterval = null;

                this.initializeWebSocket();
                this.bindEvents();
                this.updateMetrics();
                this.updateRunSelector();

                // Set up status polling for running jobs (inspired by code_gen)
                setInterval(() => {
                    this.pollRunningJobStatus();
                }, 2000); // Poll every 2 seconds for real-time updates
            }

            initializeWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;

                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    this.connected = true;
                    this.updateConnectionStatus();
                    this.log('Connected to Autonomous Software Factory', 'info');
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleWebSocketMessage(message);
                };

                this.ws.onclose = () => {
                    this.connected = false;
                    this.updateConnectionStatus();
                    this.log('Disconnected from server', 'error');

                    // Attempt to reconnect after 5 seconds
                    setTimeout(() => {
                        if (!this.connected) {
                            this.initializeWebSocket();
                        }
                    }, 5000);
                };

                this.ws.onerror = (error) => {
                    this.log(`WebSocket error: ${error}`, 'error');
                };
            }

            updateConnectionStatus() {
                if (this.connected) {
                    this.connectionStatus.textContent = 'Connected';
                    this.statusDot.classList.add('connected');
                } else {
                    this.connectionStatus.textContent = 'Disconnected';
                    this.statusDot.classList.remove('connected');
                }
            }

            handleWebSocketMessage(message) {
                this.debugLog(`WS: ${message.type}`, 'info');

                switch (message.type) {
                    case 'connection_established':
                        this.debugLog(`Client ID: ${message.data.client_id}`, 'info');
                        this.log(`Connected with client ID: ${message.data.client_id}`, 'info');
                        break;
                    case 'run_started':
                        this.debugLog(`Run started: ${message.data.run_id}`, 'info');
                        this.log(`Run started: ${message.data.run_id}`, 'info');
                        this.runningJobs.add(message.data.run_id);
                        this.updateDAG();
                        break;
                    case 'task_started':
                        this.debugLog(`Task: ${message.data.task_name} (${message.data.task_id})`, 'info');
                        this.log(`Task started: ${message.data.task_name} (${message.data.task_id})`, 'info');
                        this.updateDAG();
                        break;
                    case 'task_completed':
                        this.debugLog(`Task completed: ${message.data.task_name}`, 'info');
                        this.log(`Task completed: ${message.data.task_name} (${message.data.task_id})`, 'info');
                        this.updateDAG();
                        break;
                    case 'task_failed':
                        this.debugLog(`Task failed: ${message.data.task_name}: ${message.data.error}`, 'error');
                        this.log(`Task failed: ${message.data.task_name} (${message.data.task_id}): ${message.data.error}`, 'error');
                        this.updateDAG();
                        break;
                    case 'run_completed':
                        this.debugLog(`Run completed: ${message.data.run_id}`, 'info');
                        this.log(`Run completed: ${message.data.run_id}`, 'info');
                        this.runningJobs.delete(message.data.run_id);
                        this.updateDAG();
                        break;
                    case 'run_failed':
                        this.debugLog(`Run failed: ${message.data.run_id}: ${message.data.error}`, 'error');
                        this.log(`Run failed: ${message.data.run_id}: ${message.data.error}`, 'error');
                        this.runningJobs.delete(message.data.run_id);
                        this.updateDAG();
                        break;
                    default:
                        this.debugLog(`Unknown WS type: ${message.type}`, 'warning');
                        this.log(`Received message: ${JSON.stringify(message)}`, 'debug');
                }

                this.updateMetrics();
            }

            log(message, level = 'info') {
                const timestamp = new Date().toISOString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${level}`;
                logEntry.textContent = `[${timestamp}] ${message}`;

                this.logContainer.appendChild(logEntry);

                if (document.getElementById('auto-scroll').checked) {
                    this.logContainer.scrollTop = this.logContainer.scrollHeight;
                }
            }

            debugLog(message, level = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.style.cssText = `
                    margin: 2px 0;
                    padding: 2px 0;
                    border-bottom: 1px solid #333;
                    font-size: 10px;
                `;

                const levelColor = level === 'error' ? '#ff4444' : level === 'warning' ? '#ffaa00' : '#00ff88';
                logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> <span style="color: ${levelColor};">[${level.toUpperCase()}]</span> <span style="color: #ccc;">${message}</span>`;

                this.debugLogContent.appendChild(logEntry);

                // Auto-scroll debug log
                this.debugLogContent.scrollTop = this.debugLogContent.scrollHeight;

                // Keep only last 100 entries to prevent memory issues
                const entries = this.debugLogContent.children;
                if (entries.length > 100) {
                    this.debugLogContent.removeChild(entries[0]);
                }
            }

            async startRun(formData) {
                try {
                    this.debugLog('Starting new run...', 'info');

                    // Generate UUID (fallback for older browsers)
                    const generateUUID = () => {
                        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                            const r = Math.random() * 16 | 0;
                            const v = c == 'x' ? r : (r & 0x3 | 0x8);
                            return v.toString(16);
                        });
                    };

                    // Convert requirements string to array
                    const requirementsArray = formData.requirements
                        .split('\n')
                        .map(req => req.trim())
                        .filter(req => req.length > 0);

                    this.debugLog(`Requirements: ${requirementsArray.length} items`, 'info');

                    // First, create a project
                    const projectData = {
                        name: formData.project_name,
                        description: formData.description,
                        requirements: requirementsArray,
                        target_framework: formData.pipeline_type || 'FastAPI',
                        metadata_json: {
                            project_name: formData.project_name,
                            description: formData.description,
                            requirements: formData.requirements
                        }
                    };

                    this.debugLog('Creating project...', 'info');
                    const projectResponse = await fetch('/projects/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(projectData)
                    });

                    if (!projectResponse.ok) {
                        const errorData = await projectResponse.json();
                        let errorMessage = 'Unknown error';
                        if (errorData.detail) {
                            if (Array.isArray(errorData.detail)) {
                                errorMessage = errorData.detail.map(e => `${e.loc?.join('.')}: ${e.msg}`).join(', ');
                            } else {
                                errorMessage = errorData.detail;
                            }
                        } else {
                            errorMessage = JSON.stringify(errorData);
                        }
                        this.debugLog(`Project creation failed: ${errorMessage}`, 'error');
                        throw new Error(`Failed to create project: ${errorMessage}`);
                    }

                    const projectResult = await projectResponse.json();
                    const projectId = projectResult.id;
                    this.debugLog(`Project created: ${projectId}`, 'info');

                    // Then, create a run
                    this.debugLog('Creating run...', 'info');
                    const runData = {
                        project_id: projectId,
                        pipeline_name: formData.pipeline_type || 'software_factory_v1',
                        metadata_json: {
                            project_name: formData.project_name,
                            description: formData.description,
                            requirements: formData.requirements
                        }
                    };

                    const response = await fetch('/runs/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(runData)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        this.debugLog(`Run created: ${result.run_id}`, 'info');
                        this.log(`Run started successfully: ${result.run_id}`, 'info');
                        this.updateDAG();
                    } else {
                        const error = await response.json();
                        let errorMessage = 'Unknown error';
                        if (error.detail) {
                            if (Array.isArray(error.detail)) {
                                errorMessage = error.detail.map(e => `${e.loc?.join('.')}: ${e.msg}`).join(', ');
                            } else {
                                errorMessage = error.detail;
                            }
                        } else {
                            errorMessage = JSON.stringify(error);
                        }
                        this.debugLog(`Run creation failed: ${errorMessage}`, 'error');
                        this.log(`Failed to start run: ${errorMessage}`, 'error');
                    }
                } catch (error) {
                    this.debugLog(`Run error: ${error.message}`, 'error');
                    this.log(`Error starting run: ${error.message}`, 'error');
                }
            }

            async updateDAG() {
                try {
                    this.debugLog('Updating DAG...', 'info');
                    const response = await fetch('/runs/');
                    if (response.ok) {
                        const runs = await response.json();
                        this.debugLog(`Found ${runs.length} runs`, 'info');
                        this.renderDAG(runs);

                        // Track running jobs for status polling (inspired by code_gen)
                        this.runningJobs.clear();
                        for (const run of runs) {
                            if (run.status === 'running') {
                                this.runningJobs.add(run.id);
                                this.debugLog(`Tracking running job: ${run.id}`, 'info');
                            }
                        }
                    } else {
                        this.debugLog(`Failed to fetch runs: ${response.status}`, 'error');
                    }
                } catch (error) {
                    this.debugLog(`DAG update error: ${error.message}`, 'error');
                    this.log(`Error updating DAG: ${error.message}`, 'error');
                }
            }

            async updateRunStatus(runId) {
                try {
                    const response = await fetch(`/runs/${runId}/status`);
                    if (response.ok) {
                        const status = await response.json();
                        this.debugLog(`Status update for ${runId}: ${status.phase} - ${status.progress}%`, 'info');

                        // Update the specific run's status in the UI
                        this.updateRunStatusInUI(runId, status);
                    }
                } catch (error) {
                    this.debugLog(`Failed to get status for ${runId}: ${error}`, 'error');
                }
            }

            updateRunStatusInUI(runId, status) {
                // Find the run element and update its status
                const runElements = document.querySelectorAll('[data-run-id]');
                for (const element of runElements) {
                    if (element.getAttribute('data-run-id') === runId) {
                        // Update progress bar
                        const progressBar = element.querySelector('.progress-fill');
                        if (progressBar) {
                            progressBar.style.width = `${status.progress}%`;
                        }

                        // Update phase description
                        const phaseDesc = element.querySelector('.phase-description');
                        if (phaseDesc) {
                            phaseDesc.textContent = status.message;
                        }

                        // Update current phase indicator
                        const currentPhase = element.querySelector('.current-phase');
                        if (currentPhase) {
                            currentPhase.textContent = `${status.phase_icon} ${status.phase}`;
                        }

                        break;
                    }
                }
            }

            async pollRunningJobStatus() {
                // Poll status for all running jobs
                for (const runId of this.runningJobs) {
                    try {
                        const response = await fetch(`/runs/${runId}/status`);
                        if (response.ok) {
                            const status = await response.json();
                            this.updateRunStatusInUI(runId, status);

                            // Remove from running jobs if completed or failed
                            if (status.status === 'completed' || status.status === 'failed') {
                                this.runningJobs.delete(runId);
                                this.debugLog(`Job ${runId} finished: ${status.status}`, 'info');
                            }
                        }
                    } catch (error) {
                        this.debugLog(`Failed to poll status for ${runId}: ${error}`, 'error');
                    }
                }
            }

                                    renderDAG(runs) {
                const container = document.getElementById('dag-container');
                container.innerHTML = '';

                if (!runs || runs.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; margin-top: 100px;">No active runs to display</p>';
                    return;
                }

                // Create real-time status dashboard
                const statusDashboard = document.createElement('div');
                statusDashboard.style.cssText = `
                    padding: 20px;
                    font-family: 'Courier New', monospace;
                `;

                // Development pipeline stages (inspired by code_gen)
                const stages = [
                    { name: 'PLAN', icon: 'üìã', color: '#00ff88', description: 'Requirements Analysis' },
                    { name: 'SPEC', icon: 'üìù', color: '#00ff88', description: 'Technical Specification' },
                    { name: 'ARCH', icon: 'üèóÔ∏è', color: '#00ff88', description: 'System Architecture' },
                    { name: 'CODE', icon: 'üíª', color: '#00ff88', description: 'Code Generation' },
                    { name: 'TEST', icon: 'üß™', color: '#00ff88', description: 'Testing & Validation' },
                    { name: 'DEPLOY', icon: 'üöÄ', color: '#00ff88', description: 'Deployment Ready' }
                ];

                // Show most recent runs (up to 3)
                const recentRuns = runs.slice(0, 3);

                recentRuns.forEach((run, runIndex) => {
                    const runSection = this.createStatusSection(run, stages, runIndex);
                    statusDashboard.appendChild(runSection);
                });

                container.appendChild(statusDashboard);
            }

            createStatusSection(run, stages, runIndex) {
                const section = document.createElement('div');
                section.style.cssText = `
                    margin-bottom: 25px;
                    border: 2px solid #333;
                    border-radius: 12px;
                    padding: 20px;
                    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
                    position: relative;
                    overflow: hidden;
                `;
                section.setAttribute('data-run-id', run.id || 'unknown');

                const shortId = (run.id || 'unknown').substring(0, 8);
                const status = run.status || 'unknown';
                const statusColor = status === 'running' ? '#00ff88' : status === 'failed' ? '#ff4444' : '#00ff88';

                // Calculate progress through stages (inspired by code_gen)
                const progress = this.calculateProgress(run);
                const currentStageIndex = Math.min(Math.floor(progress * stages.length), stages.length - 1);

                // Create header with enhanced styling
                const header = document.createElement('div');
                header.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 20px;
                    padding-bottom: 15px;
                    border-bottom: 2px solid #333;
                `;
                header.innerHTML = `
                    <div>
                        <div style="color: #ffffff; font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                            ${run.pipeline_name || 'Unknown Pipeline'}
                        </div>
                        <div style="color: #ccc; font-size: 12px;">
                            ID: ${shortId} | Status: <span style="color: ${statusColor}; font-weight: bold;">${status.toUpperCase()}</span>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #666; font-size: 11px; margin-bottom: 2px;">Tasks: ${run.total_tasks || 0}</div>
                        <div style="color: ${statusColor}; font-size: 12px; font-weight: bold;">Progress: ${Math.round(progress * 100)}%</div>
                    </div>
                `;
                section.appendChild(header);

                // Create progress bar (inspired by code_gen consciousness-progress)
                const progressContainer = document.createElement('div');
                progressContainer.style.cssText = `
                    margin-bottom: 20px;
                `;
                progressContainer.innerHTML = `
                    <div style="
                        width: 100%;
                        height: 8px;
                        background: rgba(0, 0, 17, 0.8);
                        border: 1px solid ${statusColor};
                        border-radius: 4px;
                        overflow: hidden;
                        margin-bottom: 10px;
                    ">
                        <div class="progress-fill" style="
                            background: linear-gradient(90deg, ${statusColor}, #00ff88);
                            height: 100%;
                            width: ${Math.round(progress * 100)}%;
                            transition: width 0.3s ease;
                            border-radius: 4px;
                        "></div>
                    </div>
                    <div class="phase-description" style="color: #666; font-size: 11px; text-align: center;">
                        ${stages[currentStageIndex]?.description || 'Processing...'}
                    </div>
                    <div class="current-phase" style="color: ${statusColor}; font-size: 12px; text-align: center; margin-top: 5px; font-weight: bold;">
                        ${stages[currentStageIndex]?.icon || '‚è≥'} ${stages[currentStageIndex]?.name || 'PENDING'}
                    </div>
                `;
                section.appendChild(progressContainer);

                // Create stage indicators (inspired by code_gen consciousness-status)
                const stagesContainer = document.createElement('div');
                stagesContainer.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    position: relative;
                `;

                stages.forEach((stage, stageIndex) => {
                    const stageNode = this.createEnhancedStageNode(stage, stageIndex, currentStageIndex, status);
                    stagesContainer.appendChild(stageNode);
                });

                section.appendChild(stagesContainer);

                // Add hover effects and click handler
                section.addEventListener('mouseenter', () => {
                    section.style.borderColor = statusColor;
                    section.style.transform = 'scale(1.02)';
                });

                section.addEventListener('mouseleave', () => {
                    section.style.borderColor = '#333';
                    section.style.transform = 'scale(1)';
                });

                section.addEventListener('click', () => {
                    this.showRunDetails(run);
                });
                section.style.cursor = 'pointer';
                section.style.transition = 'all 0.3s ease';

                return section;
            }

            createEnhancedStageNode(stage, stageIndex, currentStageIndex, status) {
                const node = document.createElement('div');
                node.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 8px;
                    flex: 1;
                    position: relative;
                `;

                const isActive = stageIndex === currentStageIndex && status === 'running';
                const isCompleted = stageIndex < currentStageIndex;
                const isPending = stageIndex > currentStageIndex;

                let nodeColor = '#666';
                let nodeIcon = stage.icon;
                let nodeStatus = 'PENDING';
                let nodeGlow = 'none';

                if (isActive) {
                    nodeColor = '#ff8800';
                    nodeIcon = 'üîÑ';
                    nodeStatus = 'ACTIVE';
                    nodeGlow = `0 0 20px ${nodeColor}`;
                } else if (isCompleted) {
                    nodeColor = '#00ff88';
                    nodeIcon = '‚úÖ';
                    nodeStatus = 'DONE';
                    nodeGlow = `0 0 15px ${nodeColor}`;
                }

                // Add connecting lines between stages
                if (stageIndex < 5) { // Don't add line after last stage
                    const connector = document.createElement('div');
                    connector.style.cssText = `
                        position: absolute;
                        top: 20px;
                        right: -50%;
                        width: 100%;
                        height: 2px;
                        background: ${isCompleted ? nodeColor : '#333'};
                        z-index: 1;
                    `;
                    node.appendChild(connector);
                }

                node.innerHTML = `
                    <div style="
                        width: 50px;
                        height: 50px;
                        border-radius: 50%;
                        border: 3px solid ${nodeColor};
                        background: ${isActive ? nodeColor + '20' : 'transparent'};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 20px;
                        margin-bottom: 8px;
                        position: relative;
                        z-index: 2;
                        box-shadow: ${nodeGlow};
                        transition: all 0.3s ease;
                        ${isActive ? 'animation: pulse 2s infinite;' : ''}
                    ">${nodeIcon}</div>
                    <div style="color: ${nodeColor}; font-size: 11px; font-weight: bold; text-align: center; margin-bottom: 2px;">
                        ${stage.name}
                    </div>
                    <div style="color: #666; font-size: 9px; text-align: center;">
                        ${nodeStatus}
                    </div>
                `;

                // Add hover effects
                node.addEventListener('mouseenter', () => {
                    const iconDiv = node.querySelector('div');
                    if (iconDiv) {
                        iconDiv.style.transform = 'scale(1.1)';
                        iconDiv.style.boxShadow = `0 0 25px ${nodeColor}`;
                    }
                });

                node.addEventListener('mouseleave', () => {
                    const iconDiv = node.querySelector('div');
                    if (iconDiv) {
                        iconDiv.style.transform = 'scale(1)';
                        iconDiv.style.boxShadow = nodeGlow;
                    }
                });

                return node;
            }

                        calculateProgress(run) {
                // Calculate progress based on run data
                if (!run.started_at) {
                    return 0.0; // No start time, no progress
                }

                const startTime = new Date(run.started_at);
                const now = new Date();
                const elapsed = now - startTime;

                // Simulate progress through phases
                if (run.status === 'failed') {
                    return Math.min(Math.random() * 0.8, 0.95); // Random progress up to 80%
                } else if (run.status === 'completed') {
                    return 1.0; // 100% complete
                } else {
                    // Running - simulate progress based on time
                    const maxTime = 5 * 60 * 1000; // 5 minutes max
                    return Math.min(elapsed / maxTime, 0.95); // Cap at 95% while running
                }
            }

            showRunDetails(run) {
                const details = `
Pipeline: ${run.pipeline_name}
Project ID: ${run.project_id}
Run ID: ${run.id}
Status: ${run.status}
Started: ${new Date(run.started_at).toLocaleString()}
Tasks: ${run.total_tasks || 0} total, ${run.completed_tasks || 0} completed, ${run.failed_tasks || 0} failed
Tokens: ${run.total_tokens || 0}
Cost: $${(run.total_cost || 0).toFixed(4)}
Latency: ${run.total_latency_ms || 0}ms
                `;

                this.log(`Run Details:\n${details}`, 'info');
            }

            async updateMetrics() {
                try {
                    const response = await fetch('/runs/');
                    if (response.ok) {
                        const runs = await response.json();

                        const activeRuns = runs.filter(r => r.status === 'running').length;
                        const totalTasks = runs.reduce((sum, run) => sum + (run.task_count || 0), 0);
                        const completedTasks = runs.reduce((sum, run) => sum + (run.completed_tasks || 0), 0);
                        const failedTasks = runs.reduce((sum, run) => sum + (run.failed_tasks || 0), 0);

                        document.getElementById('active-runs').textContent = activeRuns;
                        document.getElementById('total-tasks').textContent = totalTasks;
                        document.getElementById('completed-tasks').textContent = completedTasks;
                        document.getElementById('failed-tasks').textContent = failedTasks;
                    }
                } catch (error) {
                    this.log(`Error updating metrics: ${error.message}`, 'error');
                }
            }

            bindEvents() {
                // Form submission
                document.getElementById('run-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    const formData = new FormData(e.target);
                    const data = Object.fromEntries(formData.entries());

                    if (this.connected) {
                        this.startRun(data);
                    } else {
                        this.log('Not connected to server', 'error');
                    }
                });

                // Clear form
                document.getElementById('clear-form-btn').addEventListener('click', () => {
                    document.getElementById('run-form').reset();
                });

                // Clear logs
                document.getElementById('clear-logs-btn').addEventListener('click', () => {
                    this.logContainer.innerHTML = '';
                });

                // Export logs
                document.getElementById('export-logs-btn').addEventListener('click', () => {
                    const logs = Array.from(this.logContainer.children)
                        .map(entry => entry.textContent)
                        .join('\n');

                    const blob = new Blob([logs], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `factory-logs-${new Date().toISOString().split('T')[0]}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                });

                // Refresh DAG
                document.getElementById('refresh-dag-btn').addEventListener('click', () => {
                    this.updateDAG();
                });

                // Auto refresh
                document.getElementById('auto-refresh-btn').addEventListener('click', () => {
                    this.autoRefresh = !this.autoRefresh;
                    const btn = document.getElementById('auto-refresh-btn');

                    if (this.autoRefresh) {
                        btn.textContent = 'Stop Auto Refresh';
                        btn.classList.add('btn');
                        btn.classList.remove('btn-secondary');
                        this.autoRefreshInterval = setInterval(() => {
                            this.updateDAG();
                            this.updateMetrics();
                        }, 5000);
                    } else {
                        btn.textContent = 'Auto Refresh';
                        btn.classList.remove('btn');
                        btn.classList.add('btn-secondary');
                        if (this.autoRefreshInterval) {
                            clearInterval(this.autoRefreshInterval);
                            this.autoRefreshInterval = null;
                        }
                    }
                });

                // Pipeline visualization events
                document.getElementById('refresh-pipeline-btn').addEventListener('click', () => {
                    this.refreshPipelineVisualization();
                });

                document.getElementById('auto-refresh-pipeline-btn').addEventListener('click', () => {
                    this.autoRefreshPipeline = !this.autoRefreshPipeline;
                    const btn = document.getElementById('auto-refresh-pipeline-btn');

                    if (this.autoRefreshPipeline) {
                        btn.textContent = 'Stop Auto Refresh';
                        btn.classList.add('btn');
                        btn.classList.remove('btn-secondary');
                        this.autoRefreshPipelineInterval = setInterval(() => {
                            this.refreshPipelineVisualization();
                        }, 10000);
                    } else {
                        btn.textContent = 'Auto Refresh';
                        btn.classList.remove('btn');
                        btn.classList.add('btn-secondary');
                        if (this.autoRefreshPipelineInterval) {
                            clearInterval(this.autoRefreshPipelineInterval);
                            this.autoRefreshPipelineInterval = null;
                        }
                    }
                });

                document.getElementById('run-selector').addEventListener('change', (e) => {
                    const runId = e.target.value;
                    if (runId) {
                        this.loadPipelineVisualization(runId);
                    } else {
                        this.clearPipelineVisualization();
                    }
                });
            }

            async updateRunSelector() {
                try {
                    const response = await fetch('/runs/');
                    if (response.ok) {
                        const runs = await response.json();
                        const selector = document.getElementById('run-selector');

                        // Clear existing options except the first one
                        selector.innerHTML = '<option value="">Select a run...</option>';

                        // Add runs to selector
                        runs.forEach(run => {
                            const option = document.createElement('option');
                            option.value = run.id;
                            option.textContent = `${run.project_name} (${run.status}) - ${new Date(run.created_at).toLocaleString()}`;
                            selector.appendChild(option);
                        });
                    }
                } catch (error) {
                    this.log(`Error updating run selector: ${error.message}`, 'error');
                }
            }

            async loadPipelineVisualization(runId) {
                try {
                    // Destroy existing visualization if any
                    if (this.pipelineVisualization) {
                        this.pipelineVisualization.destroy();
                    }

                    // Create new pipeline visualization
                    this.pipelineVisualization = new PipelineVisualization('pipeline-visualization', runId);

                    // Update stats
                    this.updatePipelineStats();
                } catch (error) {
                    this.log(`Error loading pipeline visualization: ${error.message}`, 'error');
                    this.showPipelineError('Failed to load pipeline visualization');
                }
            }

            clearPipelineVisualization() {
                if (this.pipelineVisualization) {
                    this.pipelineVisualization.destroy();
                    this.pipelineVisualization = null;
                }

                const container = document.getElementById('pipeline-visualization');
                container.innerHTML = '<p style="text-align: center; color: #666; margin-top: 200px;">Select a run to view pipeline visualization</p>';

                // Reset stats
                document.getElementById('total-stages').textContent = '0';
                document.getElementById('completed-stages').textContent = '0';
                document.getElementById('running-stages').textContent = '0';
                document.getElementById('failed-stages').textContent = '0';
            }

            async refreshPipelineVisualization() {
                const runId = document.getElementById('run-selector').value;
                if (runId) {
                    await this.loadPipelineVisualization(runId);
                }
            }

            async updatePipelineStats() {
                try {
                    const runId = document.getElementById('run-selector').value;
                    if (!runId) return;

                    const response = await fetch(`/runs/${runId}/pipeline-visualization`);
                    if (response.ok) {
                        const data = await response.json();

                        document.getElementById('total-stages').textContent = data.total_stages;
                        document.getElementById('completed-stages').textContent = data.completed_stages;
                        document.getElementById('running-stages').textContent = data.running_stages;
                        document.getElementById('failed-stages').textContent = data.failed_stages;
                    }
                } catch (error) {
                    this.log(`Error updating pipeline stats: ${error.message}`, 'error');
                }
            }

            showPipelineError(message) {
                const container = document.getElementById('pipeline-visualization');
                container.innerHTML = `
                    <div class="pipeline-error">
                        <h3>Pipeline Visualization Error</h3>
                        <p>${message}</p>
                        <button onclick="location.reload()">Retry</button>
                    </div>
                `;
            }
        }

        // Initialize the UI when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new AutonomousFactoryUI();
        });
    </script>
</body>
</html>
