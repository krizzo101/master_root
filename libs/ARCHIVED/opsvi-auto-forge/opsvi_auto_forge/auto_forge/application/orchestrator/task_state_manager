"""Task State Manager - Centralized task state tracking and management."""

import json
import logging
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, List, Optional, Union
from uuid import UUID

from auto_forge.config.models import TaskStatus
from memory.graph.client import Neo4jClient

logger = logging.getLogger(__name__)


class TaskStateManager:
    """Centralized task state tracking and management.

    This component provides the missing centralized state management
    for task execution, implementing the critical functionality identified
    in the gap analysis.
    """

    def __init__(self, neo4j_client: Neo4jClient, redis_client: Any):
        """Initialize the Task State Manager.

        Args:
            neo4j_client: Neo4j client for persistent storage
            redis_client: Redis client for caching and real-time access
        """
        self.neo4j_client = neo4j_client
        self.redis_client = redis_client
        self.state_cache: Dict[UUID, Dict[str, Any]] = {}  # In-memory cache for active tasks

        logger.info("TaskStateManager initialized successfully")

    async def update_state(
        self,
        task_id: UUID,
        status: TaskStatus,
        **metadata
    ) -> None:
        """Update task state with metadata.

        Args:
            task_id: Task ID to update
            status: New task status
            **metadata: Additional metadata to store
        """
        try:
            current_time = datetime.now(timezone.utc)

            # Prepare state data
            state_data = {
                'task_id': str(task_id),
                'status': status.value if hasattr(status, 'value') else str(status),
                'updated_at': current_time.isoformat(),
                **metadata
            }

            # Update in-memory cache
            self.state_cache[task_id] = state_data

            # Persist to Neo4j
            await self._persist_state_to_neo4j(task_id, status, metadata)

            # Update Redis for real-time access
            await self._update_redis_state(task_id, state_data)

            logger.debug(f"Updated state for task {task_id}: {status}")

        except Exception as e:
            logger.error(f"Failed to update state for task {task_id}: {e}")
            raise

    async def get_state(self, task_id: UUID) -> Optional[Dict[str, Any]]:
        """Get current task state.

        Args:
            task_id: Task ID to get state for

        Returns:
            Task state data or None if not found
        """
        try:
            # Check in-memory cache first
            if task_id in self.state_cache:
                return self.state_cache[task_id]

            # Check Redis
            redis_state = await self._get_redis_state(task_id)
            if redis_state:
                return redis_state

            # Fallback to Neo4j
            neo4j_state = await self._get_neo4j_state(task_id)
            if neo4j_state:
                # Cache the result
                self.state_cache[task_id] = neo4j_state
                return neo4j_state

            return None

        except Exception as e:
            logger.error(f"Failed to get state for task {task_id}: {e}")
            return None

    async def get_dependencies_ready(self, task_id: UUID) -> bool:
        """Check if all dependencies are ready for execution.

        Args:
            task_id: Task ID to check dependencies for

        Returns:
            True if all dependencies are ready, False otherwise
        """
        try:
            # Get task execution record
            task_execution = await self._get_task_execution(task_id)
            if not task_execution:
                return False

            # Check each dependency
            for dep_id in task_execution.get('dependencies', []):
                dep_state = await self.get_state(UUID(dep_id))
                if not dep_state:
                    return False

                dep_status = dep_state.get('status')
                if dep_status not in ['completed', 'success']:
                    return False

            return True

        except Exception as e:
            logger.error(f"Failed to check dependencies for task {task_id}: {e}")
            return False

    async def get_tasks_by_status(self, status: TaskStatus) -> List[Dict[str, Any]]:
        """Get all tasks with a specific status.

        Args:
            status: Status to filter by

        Returns:
            List of task states with the specified status
        """
        try:
            # Query Neo4j for tasks with specific status
            query = """
            MATCH (t:TaskExecution)
            WHERE t.status = $status
            RETURN t
            ORDER BY t.updated_at DESC
            """

            result = await self.neo4j_client.run_query(
                query,
                parameters={'status': status.value if hasattr(status, 'value') else str(status)}
            )

            tasks = []
            for record in result:
                task_data = record['t']
                tasks.append({
                    'task_id': task_data.get('id'),
                    'status': task_data.get('status'),
                    'updated_at': task_data.get('updated_at'),
                    'project_id': task_data.get('project_id'),
                    'run_id': task_data.get('run_id')
                })

            return tasks

        except Exception as e:
            logger.error(f"Failed to get tasks by status {status}: {e}")
            return []

    async def get_active_tasks(self) -> List[Dict[str, Any]]:
        """Get all currently active tasks.

        Returns:
            List of active task states
        """
        active_statuses = [TaskStatus.PENDING, TaskStatus.RUNNING]
        active_tasks = []

        for status in active_statuses:
            tasks = await self.get_tasks_by_status(status)
            active_tasks.extend(tasks)

        return active_tasks

    async def cleanup_completed_tasks(self, max_age_hours: int = 24) -> int:
        """Clean up completed tasks older than specified age.

        Args:
            max_age_hours: Maximum age in hours for completed tasks

        Returns:
            Number of tasks cleaned up
        """
        try:
            cutoff_time = datetime.now(timezone.utc) - timedelta(hours=max_age_hours)

            # Query for old completed tasks
            query = """
            MATCH (t:TaskExecution)
            WHERE t.status IN ['completed', 'failed', 'cancelled']
            AND t.updated_at < $cutoff_time
            RETURN t.id as task_id
            """

            result = await self.neo4j_client.run_query(
                query,
                parameters={'cutoff_time': cutoff_time.isoformat()}
            )

            cleaned_count = 0
            for record in result:
                task_id = record['task_id']

                # Remove from Neo4j
                await self._delete_from_neo4j(task_id)

                # Remove from Redis
                await self._delete_from_redis(task_id)

                # Remove from cache
                if UUID(task_id) in self.state_cache:
                    del self.state_cache[UUID(task_id)]

                cleaned_count += 1

            logger.info(f"Cleaned up {cleaned_count} completed tasks older than {max_age_hours} hours")
            return cleaned_count

        except Exception as e:
            logger.error(f"Failed to cleanup completed tasks: {e}")
            return 0

    async def _persist_state_to_neo4j(
        self,
        task_id: UUID,
        status: TaskStatus,
        metadata: Dict[str, Any]
    ) -> None:
        """Persist task state to Neo4j."""
        try:
            # Prepare data for Neo4j
            neo4j_data = {
                'id': str(task_id),
                'status': status.value if hasattr(status, 'value') else str(status),
                'updated_at': datetime.now(timezone.utc).isoformat(),
                **metadata
            }

            # Upsert task state
            query = """
            MERGE (t:TaskExecution {id: $id})
            SET t += $data
            """

            await self.neo4j_client.run_query(
                query,
                parameters={'id': str(task_id), 'data': neo4j_data}
            )

        except Exception as e:
            logger.error(f"Failed to persist state to Neo4j for task {task_id}: {e}")
            raise

    async def _update_redis_state(self, task_id: UUID, state_data: Dict[str, Any]) -> None:
        """Update task state in Redis for real-time access."""
        try:
            if self.redis_client:
                key = f"task_state:{task_id}"
                await self.redis_client.set(
                    key,
                    json.dumps(state_data),
                    ex=3600  # Expire after 1 hour
                )
        except Exception as e:
            logger.error(f"Failed to update Redis state for task {task_id}: {e}")
            # Don't raise - Redis is optional for caching

    async def _get_redis_state(self, task_id: UUID) -> Optional[Dict[str, Any]]:
        """Get task state from Redis."""
        try:
            if self.redis_client:
                key = f"task_state:{task_id}"
                data = await self.redis_client.get(key)
                if data:
                    return json.loads(data)
        except Exception as e:
            logger.error(f"Failed to get Redis state for task {task_id}: {e}")

        return None

    async def _get_neo4j_state(self, task_id: UUID) -> Optional[Dict[str, Any]]:
        """Get task state from Neo4j."""
        try:
            query = """
            MATCH (t:TaskExecution {id: $task_id})
            RETURN t
            """

            result = await self.neo4j_client.run_query(
                query,
                parameters={'task_id': str(task_id)}
            )

            if result:
                return dict(result[0]['t'])

            return None

        except Exception as e:
            logger.error(f"Failed to get Neo4j state for task {task_id}: {e}")
            return None

    async def _get_task_execution(self, task_id: UUID) -> Optional[Dict[str, Any]]:
        """Get task execution record from Neo4j."""
        try:
            query = """
            MATCH (t:TaskExecution {id: $task_id})
            RETURN t
            """

            result = await self.neo4j_client.run_query(
                query,
                parameters={'task_id': str(task_id)}
            )

            if result:
                return dict(result[0]['t'])

            return None

        except Exception as e:
            logger.error(f"Failed to get task execution for task {task_id}: {e}")
            return None

    async def _delete_from_neo4j(self, task_id: str) -> None:
        """Delete task state from Neo4j."""
        try:
            query = """
            MATCH (t:TaskExecution {id: $task_id})
            DELETE t
            """

            await self.neo4j_client.run_query(
                query,
                parameters={'task_id': task_id}
            )

        except Exception as e:
            logger.error(f"Failed to delete from Neo4j for task {task_id}: {e}")

    async def _delete_from_redis(self, task_id: str) -> None:
        """Delete task state from Redis."""
        try:
            if self.redis_client:
                key = f"task_state:{task_id}"
                await self.redis_client.delete(key)
        except Exception as e:
            logger.error(f"Failed to delete from Redis for task {task_id}: {e}")


class TaskStateError(Exception):
    """Exception raised for task state management errors."""
    pass
