"""Base repair agent for fixing issues identified by critic evaluation."""

import asyncio
import logging
from typing import Any, Dict, List, Optional, Union
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, ConfigDict

from auto_forge.config.models import Artifact, Result, AgentRole
from memory.graph.client import Neo4jClient
from auto_forge.agents.base_agent import BaseAgent, AgentResponse

logger = logging.getLogger(__name__)


class RepairResult(BaseModel):
    """Result of a repair operation."""

    success: bool = Field(..., description="Whether the repair was successful")
    fixed_artifact: Optional[Artifact] = Field(
        None, description="The repaired artifact"
    )
    original_artifact: Artifact = Field(..., description="The original artifact")
    repair_type: str = Field(..., description="Type of repair performed")
    changes_made: List[str] = Field(
        default_factory=list, description="List of changes made"
    )
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Confidence in the repair"
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata"
    )
    error_message: Optional[str] = Field(
        None, description="Error message if repair failed"
    )

    model_config = ConfigDict(
        json_encoders={
            UUID: lambda v: str(v),
        }
    )


class RepairRequest(BaseModel):
    """Request for repair operation."""

    artifact: Artifact = Field(..., description="Artifact to repair")
    issue_type: str = Field(..., description="Type of issue to repair")
    issue_description: str = Field(..., description="Description of the issue")
    context: Dict[str, Any] = Field(
        default_factory=dict, description="Additional context"
    )
    patch_plan: Dict[str, Any] = Field(
        default_factory=dict, description="Specific repair plan"
    )


class BaseRepairAgent(BaseAgent):
    """Base class for repair agents that fix issues identified by critic evaluation."""

    def __init__(
        self,
        name: str,
        description: str,
        repair_capabilities: List[str],
        neo4j_client: Optional[Neo4jClient] = None,
        model: str = "gpt-4.1-mini",
        temperature: float = 0.1,
        max_tokens: int = 4000,
    ):
        """Initialize the repair agent."""
        super().__init__(
            role=AgentRole.REPAIR,
            neo4j_client=neo4j_client,
        )
        self.name = name
        self.description = description
        self.repair_capabilities = repair_capabilities
        self.model = model
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.agent_id = uuid4()

    async def repair_artifact(self, request: RepairRequest) -> RepairResult:
        """Repair an artifact based on the repair request."""
        logger.info(
            f"Starting repair for artifact {request.artifact.id} "
            f"with issue type: {request.issue_type}"
        )

        try:
            # Validate that this agent can handle the issue type
            if request.issue_type not in self.repair_capabilities:
                return RepairResult(
                    success=False,
                    original_artifact=request.artifact,
                    repair_type=request.issue_type,
                    confidence=0.0,
                    error_message=f"Agent {self.name} cannot handle issue type: {request.issue_type}",
                )

            # Perform the repair
            repair_result = await self._perform_repair(request)

            # Log the repair decision
            await self._log_repair_decision(request, repair_result)

            logger.info(
                f"Repair completed for artifact {request.artifact.id}: "
                f"success={repair_result.success}, confidence={repair_result.confidence}"
            )

            return repair_result

        except Exception as e:
            logger.error(f"Error during repair: {e}", exc_info=True)
            return RepairResult(
                success=False,
                original_artifact=request.artifact,
                repair_type=request.issue_type,
                confidence=0.0,
                error_message=str(e),
            )

    async def _perform_repair(self, request: RepairRequest) -> RepairResult:
        """Perform the actual repair operation. Subclasses must implement this."""
        raise NotImplementedError("Subclasses must implement _perform_repair")

    async def _log_repair_decision(
        self, request: RepairRequest, result: RepairResult
    ) -> None:
        """Log the repair decision to Neo4j."""
        if not self.neo4j_client:
            return

        try:
            decision_data = {
                "agent_id": str(self.agent_id),
                "agent_name": self.name,
                "repair_type": request.issue_type,
                "issue_description": request.issue_description,
                "success": result.success,
                "confidence": result.confidence,
                "changes_made": result.changes_made,
                "error_message": result.error_message,
                "metadata": result.metadata,
            }

            decision_data["id"] = str(uuid4())
            decision_data["by_agent"] = str(self.agent_id)
            decision_data["why"] = f"Repair attempt for {request.issue_type}"
            decision_data["confidence"] = result.confidence
            decision_data["model_used"] = self.model
            decision_data["tokens_used"] = None
            decision_data["latency_ms"] = None
            decision_data["task_id"] = str(uuid4())  # Mock task ID for testing

            await self.neo4j_client.create_decision(decision_data)

        except Exception as e:
            logger.error(f"Failed to log repair decision: {e}", exc_info=True)

    async def execute(
        self,
        task_execution: "TaskExecution",
        inputs: Dict[str, Any],
    ) -> "AgentResponse":
        """Execute the repair agent's main logic.

        This method adapts the repair agent to the standard agent interface.
        It expects inputs to contain a RepairRequest or equivalent data.
        """
        from auto_forge.application.orchestrator.task_models import TaskExecution
        from auto_forge.agents.base_agent import AgentResponse

        try:
            # Extract repair request from inputs
            if "repair_request" in inputs:
                repair_request = inputs["repair_request"]
            else:
                # Create repair request from inputs
                repair_request = RepairRequest(
                    artifact=inputs["artifact"],
                    issue_type=inputs["issue_type"],
                    issue_description=inputs["issue_description"],
                    context=inputs.get("context", {}),
                    patch_plan=inputs.get("patch_plan", {}),
                )

            # Perform repair
            repair_result = await self.repair_artifact(repair_request)

            # Convert to AgentResponse
            return AgentResponse(
                success=repair_result.success,
                content=f"Repair {repair_result.repair_type}: {'successful' if repair_result.success else 'failed'}",
                artifacts=(
                    [
                        {
                            "type": "repaired_artifact",
                            "data": repair_result.fixed_artifact.dict(),
                        }
                    ]
                    if repair_result.fixed_artifact
                    else []
                ),
                metadata={
                    "repair_type": repair_result.repair_type,
                    "confidence": repair_result.confidence,
                    "changes_made": repair_result.changes_made,
                },
                errors=(
                    [repair_result.error_message] if repair_result.error_message else []
                ),
                warnings=[],
            )

        except Exception as e:
            return AgentResponse(
                success=False,
                content=f"Repair agent execution failed: {str(e)}",
                artifacts=[],
                metadata={},
                errors=[str(e)],
                warnings=[],
            )

    def can_repair(self, issue_type: str) -> bool:
        """Check if this agent can repair the given issue type."""
        return issue_type in self.repair_capabilities

    def get_repair_capabilities(self) -> List[str]:
        """Get list of repair capabilities for this agent."""
        return self.repair_capabilities.copy()

    def get_agent_role(self) -> AgentRole:
        """Get the agent role."""
        return AgentRole.REPAIR

    def get_agent_id(self) -> UUID:
        """Get the agent ID."""
        return self.agent_id

    async def _call_model(self, prompt: str) -> Dict[str, Any]:
        """Call the AI model with a prompt.

        This is a simplified implementation for testing.
        In production, this would use the proper model client.
        """
        # For testing purposes, return a mock response
        # In production, this would make actual API calls
        if "syntax" in prompt.lower():
            return {
                "fixed_code": "def bad_function(x, y):\n    # Fixed syntax\n    result = x + y\n    return result\n\ndef another_bad_function():\n    # Fixed syntax\n    print(\"Hello World\")\n\n# Removed hardcoded secrets\napi_key = os.getenv('API_KEY')\npassword = os.getenv('PASSWORD')",
                "changes_made": [
                    "Fixed missing colon in function definition",
                    "Fixed missing colon in print statement",
                    "Replaced hardcoded secrets with environment variables",
                ],
            }
        elif "security" in prompt.lower():
            return {
                "fixed_code": "def bad_function(x, y):\n    # Fixed syntax\n    result = x + y\n    return result\n\ndef another_bad_function():\n    # Fixed syntax\n    print(\"Hello World\")\n\n# Removed hardcoded secrets\napi_key = os.getenv('API_KEY')\npassword = os.getenv('PASSWORD')",
                "changes_made": [
                    "Replaced hardcoded API key with environment variable",
                    "Replaced hardcoded password with environment variable",
                ],
            }
        else:
            return {
                "fixed_code": "Fixed code based on the issues identified.",
                "changes_made": ["Applied general fixes"],
            }
