"""
O3 Reasoning Engine for Smart Decomposition Meta-Intelligence

This module implements sophisticated O3 reasoning capabilities for the master agent
to perform meta-intelligence analysis and dynamic workflow generation.
"""

import json
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any

try:
    from langchain_openai import ChatOpenAI

    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False

logger = logging.getLogger(__name__)


@dataclass
class ComplexityAnalysis:
    """6-Factor complexity analysis for Smart Decomposition"""

    cognitive_load: int  # 0-100: Mental effort required
    technical_depth: int  # 0-100: Technical complexity
    integration_complexity: int  # 0-100: System integration needs
    domain_expertise: int  # 0-100: Specialized knowledge required
    resource_requirements: int  # 0-100: Computational/time resources
    timeline_constraints: int  # 0-100: Urgency and deadline pressure

    @property
    def total_complexity(self) -> int:
        """Calculate total complexity score"""
        return (
            self.cognitive_load
            + self.technical_depth
            + self.integration_complexity
            + self.domain_expertise
            + self.resource_requirements
            + self.timeline_constraints
        ) // 6

    @property
    def complexity_category(self) -> str:
        """Categorize complexity level"""
        total = self.total_complexity
        if total < 20:
            return "TRIVIAL"
        elif total < 40:
            return "SIMPLE"
        elif total < 60:
            return "MODERATE"
        elif total < 80:
            return "COMPLEX"
        else:
            return "EXTREMELY_COMPLEX"


@dataclass
class WorkflowPlan:
    """Dynamic workflow plan generated by O3 reasoning"""

    request_analysis: str
    complexity_analysis: ComplexityAnalysis
    recommended_agents: list[str]
    execution_strategy: str
    parallel_opportunities: list[str]
    risk_mitigation: list[str]
    success_criteria: list[str]
    estimated_duration: str


class O3ReasoningEngine:
    """O3 reasoning engine for meta-intelligence planning"""

    def __init__(self, config: dict | None = None):
        self.config = config or {}
        self.logger = logging.getLogger(self.__class__.__name__)

        # Initialize O3 model
        if OPENAI_AVAILABLE:
            self.model = ChatOpenAI(
                model="o3",  # Use O3 reasoning model
                temperature=0.1,  # Low temperature for consistent reasoning
                max_tokens=4000,
                timeout=120,  # Allow time for complex reasoning
            )
        else:
            self.logger.warning("OpenAI not available - O3 reasoning disabled")
            self.model = None

    def analyze_request_complexity(
        self, request: str, context: dict[str, Any] = None
    ) -> ComplexityAnalysis:
        """
        Analyze request complexity using O3 reasoning

        Args:
            request: User request to analyze
            context: Additional context for analysis

        Returns:
            ComplexityAnalysis with 6-factor scoring
        """
        if not self.model:
            # Fallback simple analysis
            return ComplexityAnalysis(
                cognitive_load=50,
                technical_depth=50,
                integration_complexity=50,
                domain_expertise=50,
                resource_requirements=50,
                timeline_constraints=50,
            )

        analysis_prompt = f"""
        As an expert meta-intelligence system, analyze the complexity of this request using the 6-factor Smart Decomposition model.

        Request: "{request}"
        Context: {json.dumps(context or {}, indent=2)}

        Analyze each factor on a scale of 0-100:

        1. COGNITIVE_LOAD: Mental effort required to understand and solve
        2. TECHNICAL_DEPTH: Technical complexity and sophistication needed
        3. INTEGRATION_COMPLEXITY: How many systems/components need to work together
        4. DOMAIN_EXPERTISE: Specialized knowledge requirements
        5. RESOURCE_REQUIREMENTS: Computational, time, and tool resources needed
        6. TIMELINE_CONSTRAINTS: Urgency and deadline pressure

        Consider:
        - Request scope and ambiguity
        - Technical requirements and constraints
        - Integration points and dependencies
        - Knowledge domain specialization
        - Available tools and capabilities
        - Expected output quality and completeness

        Respond with ONLY a JSON object:
        {{
            "cognitive_load": <0-100>,
            "technical_depth": <0-100>,
            "integration_complexity": <0-100>,
            "domain_expertise": <0-100>,
            "resource_requirements": <0-100>,
            "timeline_constraints": <0-100>,
            "reasoning": "Brief explanation of complexity assessment"
        }}
        """

        try:
            response = self.model.invoke([{"role": "user", "content": analysis_prompt}])
            analysis_data = json.loads(response.content)

            return ComplexityAnalysis(
                cognitive_load=analysis_data["cognitive_load"],
                technical_depth=analysis_data["technical_depth"],
                integration_complexity=analysis_data["integration_complexity"],
                domain_expertise=analysis_data["domain_expertise"],
                resource_requirements=analysis_data["resource_requirements"],
                timeline_constraints=analysis_data["timeline_constraints"],
            )

        except Exception as e:
            self.logger.error(f"O3 complexity analysis failed: {e}")
            # Fallback to default analysis
            return ComplexityAnalysis(
                cognitive_load=60,
                technical_depth=60,
                integration_complexity=60,
                domain_expertise=60,
                resource_requirements=60,
                timeline_constraints=60,
            )

    def generate_dynamic_workflow(
        self,
        request: str,
        complexity: ComplexityAnalysis,
        available_agents: list[str],
        context: dict[str, Any] = None,
    ) -> WorkflowPlan:
        """
        Generate dynamic workflow plan using O3 reasoning

        Args:
            request: User request
            complexity: Complexity analysis
            available_agents: List of available agent types
            context: Additional context

        Returns:
            WorkflowPlan with detailed execution strategy
        """
        if not self.model:
            # Fallback simple plan
            return WorkflowPlan(
                request_analysis="Basic analysis (O3 not available)",
                complexity_analysis=complexity,
                recommended_agents=["researcher", "coder"],
                execution_strategy="Sequential execution",
                parallel_opportunities=[],
                risk_mitigation=["Basic error handling"],
                success_criteria=["Complete request fulfillment"],
                estimated_duration="Unknown",
            )

        workflow_prompt = f"""
        As an expert meta-intelligence orchestration system, design an optimal workflow for this request.

        Request: "{request}"
        Complexity Analysis: {complexity.complexity_category} (Total: {complexity.total_complexity}/100)
        - Cognitive Load: {complexity.cognitive_load}/100
        - Technical Depth: {complexity.technical_depth}/100
        - Integration Complexity: {complexity.integration_complexity}/100
        - Domain Expertise: {complexity.domain_expertise}/100
        - Resource Requirements: {complexity.resource_requirements}/100
        - Timeline Constraints: {complexity.timeline_constraints}/100

        Available Agents: {', '.join(available_agents)}
        Context: {json.dumps(context or {}, indent=2)}

        Design an optimal workflow considering:
        1. Agent specialization and capabilities
        2. Parallel execution opportunities
        3. Risk mitigation strategies
        4. Success criteria and validation
        5. Resource optimization
        6. Quality assurance points

        Respond with ONLY a JSON object:
        {{
            "request_analysis": "Deep analysis of what the request is asking for",
            "recommended_agents": ["agent1", "agent2", ...],
            "execution_strategy": "Detailed execution approach (sequential/parallel/hybrid)",
            "parallel_opportunities": ["task1", "task2", ...],
            "risk_mitigation": ["risk1_mitigation", "risk2_mitigation", ...],
            "success_criteria": ["criterion1", "criterion2", ...],
            "estimated_duration": "Time estimate with reasoning"
        }}
        """

        try:
            response = self.model.invoke([{"role": "user", "content": workflow_prompt}])
            plan_data = json.loads(response.content)

            return WorkflowPlan(
                request_analysis=plan_data["request_analysis"],
                complexity_analysis=complexity,
                recommended_agents=plan_data["recommended_agents"],
                execution_strategy=plan_data["execution_strategy"],
                parallel_opportunities=plan_data["parallel_opportunities"],
                risk_mitigation=plan_data["risk_mitigation"],
                success_criteria=plan_data["success_criteria"],
                estimated_duration=plan_data["estimated_duration"],
            )

        except Exception as e:
            self.logger.error(f"O3 workflow generation failed: {e}")
            # Fallback plan
            return WorkflowPlan(
                request_analysis="Failed to analyze (O3 error)",
                complexity_analysis=complexity,
                recommended_agents=["researcher", "coder"],
                execution_strategy="Sequential execution with error handling",
                parallel_opportunities=[],
                risk_mitigation=["Monitor for errors", "Fallback to simpler approach"],
                success_criteria=["Functional output", "Error-free execution"],
                estimated_duration="Unknown (analysis failed)",
            )

    def meta_intelligence_analysis(
        self, request: str, context: dict[str, Any] = None
    ) -> dict[str, Any]:
        """
        Perform comprehensive meta-intelligence analysis

        Args:
            request: User request to analyze
            context: Additional context

        Returns:
            Complete analysis including complexity, workflow plan, and recommendations
        """
        start_time = datetime.now()

        # Step 1: Complexity Analysis
        complexity = self.analyze_request_complexity(request, context)

        # Step 2: Available agents (this would come from the system)
        available_agents = [
            "researcher",
            "coder",
            "critic",
            "planner",
            "qa",
            "deployer",
            "doc_generator",
            "reflexion",
            "tester",
            "framing",
            "feasibility",
        ]

        # Step 3: Workflow Generation
        workflow_plan = self.generate_dynamic_workflow(
            request, complexity, available_agents, context
        )

        analysis_duration = (datetime.now() - start_time).total_seconds()

        return {
            "request": request,
            "context": context,
            "complexity_analysis": {
                "factors": {
                    "cognitive_load": complexity.cognitive_load,
                    "technical_depth": complexity.technical_depth,
                    "integration_complexity": complexity.integration_complexity,
                    "domain_expertise": complexity.domain_expertise,
                    "resource_requirements": complexity.resource_requirements,
                    "timeline_constraints": complexity.timeline_constraints,
                },
                "total_complexity": complexity.total_complexity,
                "category": complexity.complexity_category,
            },
            "workflow_plan": {
                "request_analysis": workflow_plan.request_analysis,
                "recommended_agents": workflow_plan.recommended_agents,
                "execution_strategy": workflow_plan.execution_strategy,
                "parallel_opportunities": workflow_plan.parallel_opportunities,
                "risk_mitigation": workflow_plan.risk_mitigation,
                "success_criteria": workflow_plan.success_criteria,
                "estimated_duration": workflow_plan.estimated_duration,
            },
            "meta_analysis": {
                "analysis_duration_seconds": analysis_duration,
                "reasoning_model": "o3" if self.model else "fallback",
                "timestamp": datetime.now().isoformat(),
                "confidence_level": "high" if self.model else "low",
            },
        }


# Factory function for easy integration
def create_o3_reasoning_engine(config: dict | None = None) -> O3ReasoningEngine:
    """Create O3 reasoning engine instance"""
    return O3ReasoningEngine(config)
