
2025-08-08 04:55:55.584 [info] Successfully called tool 'consult'
2025-08-08 05:42:48.338 [info] Handling CallTool action for tool 'consult'
2025-08-08 05:42:48.338 [info] Calling tool 'consult' with toolCallId: tool_8dec7ea4-1f90-40a3-98d3-cce39290bbb
2025-08-08 05:42:48.392 [error] 2025-08-08 05:42:48,389 [INFO] mcp.server.lowlevel.server: Processing request of type CallToolRequest

2025-08-08 05:42:48.392 [error] 2025-08-08 05:42:48,389 [INFO] mcp.server.lowlevel.server: Processing request of type CallToolRequest

2025-08-08 05:42:48.411 [error] 2025-08-08 05:42:48,410 [INFO] accf.shared.mcp.mcp_server_template: Tool call requested: consult with arguments: {'prompt': 'Create a production-ready microservice for user authentication with the following requirements:\n\n1. REST API with FastAPI for user registration, login, and token refresh\n2. JWT token authentication with proper expiration and refresh logic\n3. Password hashing using bcrypt with salt rounds\n4. SQLite database with SQLAlchemy ORM for user storage\n5. Input validation using Pydantic models\n6. Rate limiting to prevent brute force attacks\n7. Logging with proper error handling and audit trails\n8. Health check endpoint for monitoring\n9. Docker containerization with proper security practices\n10. Unit tests with pytest covering all endpoints\n\nThe service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.', 'session_id': 'baseline_test_001', 'artifact_type': 'code', 'iterate': 3, 'critic_enabled': True, 'model': 'gpt-5-nano', 'auto_attach_project_intelligence': False, 'response_format': 'json'}

2025-08-08 05:42:48.411 [error] 2025-08-08 05:42:48,410 [INFO] accf.shared.mcp.mcp_server_template: Tool call requested: consult with arguments: {'prompt': 'Create a production-ready microservice for user authentication with the following requirements:\n\n1. REST API with FastAPI for user registration, login, and token refresh\n2. JWT token authentication with proper expiration and refresh logic\n3. Password hashing using bcrypt with salt rounds\n4. SQLite database with SQLAlchemy ORM for user storage\n5. Input validation using Pydantic models\n6. Rate limiting to prevent brute force attacks\n7. Logging with proper error handling and audit trails\n8. Health check endpoint for monitoring\n9. Docker containerization with proper security practices\n10. Unit tests with pytest covering all endpoints\n\nThe service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.', 'session_id': 'baseline_test_001', 'artifact_type': 'code', 'iterate': 3, 'critic_enabled': True, 'model': 'gpt-5-nano', 'auto_attach_project_intelligence': False, 'response_format': 'json'}

2025-08-08 05:42:48.413 [error] 2025-08-08 05:42:48,413 [INFO] __main__: All parameters explicitly provided by user

2025-08-08 05:42:48.413 [error] 2025-08-08 05:42:48,413 [INFO] __main__: All parameters explicitly provided by user

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,414 [INFO] ConsultAgent: Started new session: baseline_test_001

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,414 [INFO] ConsultAgent: Started new session: baseline_test_001

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [INFO] ConsultAgent: Using user-specified model: gpt-5-nano

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [INFO] ConsultAgent: Using user-specified model: gpt-5-nano

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [INFO] ConsultAgent: === CRITIC INITIALIZATION START ===

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [INFO] ConsultAgent: === CRITIC INITIALIZATION START ===

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [DEBUG] ConsultAgent: Current working directory: /home/opsvi/master_root

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [DEBUG] ConsultAgent: Current working directory: /home/opsvi/master_root

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [DEBUG] ConsultAgent: Python path: ['/home/opsvi/master_root', '/home/opsvi/ACCF/src', '/home/opsvi/miniconda/lib/python312.zip', '/home/opsvi/miniconda/lib/python3.12', '/home/opsvi/miniconda/lib/python3.12/lib-dynload', '/home/opsvi/.local/lib/python3.12/site-packages', '/home/opsvi/miniconda/lib/python3.12/site-packages', '/home/opsvi/agent_world/src', '/home/opsvi/asea/asea_orchestrator/src', '/home/opsvi/genFileMap/src', '/home/opsvi/master_root/apps/proj-mapper/src', '/home/opsvi/master/projects/nested-workflow-architecture/mcp-servers/mcp-atlassian/src', '/home/opsvi/project-intelligence/src']

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [DEBUG] ConsultAgent: Python path: ['/home/opsvi/master_root', '/home/opsvi/ACCF/src', '/home/opsvi/miniconda/lib/python312.zip', '/home/opsvi/miniconda/lib/python3.12', '/home/opsvi/miniconda/lib/python3.12/lib-dynload', '/home/opsvi/.local/lib/python3.12/site-packages', '/home/opsvi/miniconda/lib/python3.12/site-packages', '/home/opsvi/agent_world/src', '/home/opsvi/asea/asea_orchestrator/src', '/home/opsvi/genFileMap/src', '/home/opsvi/master_root/apps/proj-mapper/src', '/home/opsvi/master/projects/nested-workflow-architecture/mcp-servers/mcp-atlassian/src', '/home/opsvi/project-intelligence/src']

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [DEBUG] ConsultAgent: Current file location: /home/opsvi/ACCF/src/accf/agents/consult_agent_comprehensive.py

2025-08-08 05:42:48.415 [error] 2025-08-08 05:42:48,415 [DEBUG] ConsultAgent: Current file location: /home/opsvi/ACCF/src/accf/agents/consult_agent_comprehensive.py

2025-08-08 05:42:48.518 [error] 2025-08-08 05:42:48,518 [INFO] Critic: === CRITIC AGENT INITIALIZED WITH DEBUG LOGGING ===

2025-08-08 05:42:48.518 [error] 2025-08-08 05:42:48,518 [INFO] Critic: === CRITIC AGENT INITIALIZED WITH DEBUG LOGGING ===

2025-08-08 05:42:48.518 [error] 2025-08-08 05:42:48,518 [INFO] Critic: CriticAgent initialized with model: o3
2025-08-08 05:42:48,518 [INFO] ConsultAgent: Critic agent enabled for quality control (relative import)
2025-08-08 05:42:48,518 [INFO] ConsultAgent: === CRITIC INITIALIZATION END - Agent exists: True ===

2025-08-08 05:42:48.518 [error] 2025-08-08 05:42:48,518 [INFO] Critic: CriticAgent initialized with model: o3
2025-08-08 05:42:48,518 [INFO] ConsultAgent: Critic agent enabled for quality control (relative import)
2025-08-08 05:42:48,518 [INFO] ConsultAgent: === CRITIC INITIALIZATION END - Agent exists: True ===

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [INFO] ConsultAgent: Starting iteration 1/3

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [INFO] ConsultAgent: Starting iteration 1/3

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: === API CALL START ===

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: === API CALL START ===

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Prompt length: 4551 characters

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Prompt length: 4551 characters

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Context:

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Context:

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Timestamp: 1754646168.5769193

2025-08-08 05:42:48.576 [error] 2025-08-08 05:42:48,576 [DEBUG] ConsultAgent: Timestamp: 1754646168.5769193

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: Prompt length: 4551 characters
2025-08-08 05:42:48,577 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:42:48,577 [INFO] ConsultAgent: --- PROMPT CONTENT START ---

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: Prompt length: 4551 characters
2025-08-08 05:42:48,577 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:42:48,577 [INFO] ConsultAgent: --- PROMPT CONTENT START ---

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## RESPONSE DECISION INSTRUCTIONS
After analyzing the request, you MUST decide whether to provide a direct response or ask for more information.

**RESPONSE TYPES:**
- **FINAL**: Provide complete response (use when you have sufficient information)
- **QUESTIONS**: Ask clarifying questions (use when missing critical information)
- **CONCERNS**: Flag potential issues (use when you have concerns about the approach)
- **CLARIFICATION**: Request specific details (use when request is unclear)

**DECISION CRITERIA:**
- If the request is clear, complete, and you have sufficient context ‚Üí Use **FINAL**
- If missing critical information needed for a good response ‚Üí Use **QUESTIONS**
- If you have concerns about the approach or potential issues ‚Üí Use **CONCERNS**
- If the request is unclear or ambiguous ‚Üí Use **CLARIFICATION**

**RESPONSE FORMAT:**
Start your response with the response type tag:

**FINAL:**
[Your complete response here]

**QUESTIONS:**
1. [Question 1]
2. [Question 2]
...

**CONCERNS:**
‚ö†Ô∏è [Concern 1]
‚ö†Ô∏è [Concern 2]
[Questions to address concerns]

**CLARIFICATION:**
[What specifically needs to be clarified]

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate

## REFERENCE INFORMATION (NOT THE REQUEST)
*** FOR CONTEXT ONLY - DO NOT TREAT AS THE ACTUAL REQUEST ***

### PROJECT CONTEXT


### CONVERSATION HISTORY
[]

## üéØ ACTUAL USER REQUEST (THIS IS WHAT MATTERS)
*** THIS IS THE REQUEST - FOCUS ON THIS ***

Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

*** END OF REQUEST - GENERATE THE REQUESTED code CONTENT ***

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## RESPONSE DECISION INSTRUCTIONS
After analyzing the request, you MUST decide whether to provide a direct response or ask for more information.

**RESPONSE TYPES:**
- **FINAL**: Provide complete response (use when you have sufficient information)
- **QUESTIONS**: Ask clarifying questions (use when missing critical information)
- **CONCERNS**: Flag potential issues (use when you have concerns about the approach)
- **CLARIFICATION**: Request specific details (use when request is unclear)

**DECISION CRITERIA:**
- If the request is clear, complete, and you have sufficient context ‚Üí Use **FINAL**
- If missing critical information needed for a good response ‚Üí Use **QUESTIONS**
- If you have concerns about the approach or potential issues ‚Üí Use **CONCERNS**
- If the request is unclear or ambiguous ‚Üí Use **CLARIFICATION**

**RESPONSE FORMAT:**
Start your response with the response type tag:

**FINAL:**
[Your complete response here]

**QUESTIONS:**
1. [Question 1]
2. [Question 2]
...

**CONCERNS:**
‚ö†Ô∏è [Concern 1]
‚ö†Ô∏è [Concern 2]
[Questions to address concerns]

**CLARIFICATION:**
[What specifically needs to be clarified]

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate

## REFERENCE INFORMATION (NOT THE REQUEST)
*** FOR CONTEXT ONLY - DO NOT TREAT AS THE ACTUAL REQUEST ***

### PROJECT CONTEXT


### CONVERSATION HISTORY
[]

## üéØ ACTUAL USER REQUEST (THIS IS WHAT MATTERS)
*** THIS IS THE REQUEST - FOCUS ON THIS ***

Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

*** END OF REQUEST - GENERATE THE REQUESTED code CONTENT ***

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:42:48,577 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:42:48.577 [error] 2025-08-08 05:42:48,577 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:42:48,577 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:43:29.072 [error] 2025-08-08 05:43:29,072 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:43:29.073 [error] 2025-08-08 05:43:29,072 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:43:29.085 [error] 2025-08-08 05:43:29,085 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:43:29.085 [error] 2025-08-08 05:43:29,085 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:43:29.085 [error] 2025-08-08 05:43:29,085 [DEBUG] ConsultAgent: Response length: 19201 characters
2025-08-08 05:43:29,085 [DEBUG] ConsultAgent: Response type: Response

2025-08-08 05:43:29.085 [error] 2025-08-08 05:43:29,085 [DEBUG] ConsultAgent: Response length: 19201 characters
2025-08-08 05:43:29,085 [DEBUG] ConsultAgent: Response type: Response

2025-08-08 05:43:29.086 [error] 2025-08-08 05:43:29,086 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']

2025-08-08 05:43:29.086 [error] 2025-08-08 05:43:29,086 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']

2025-08-08 05:43:29.086 [error] 2025-08-08 05:43:29,086 [DEBUG] ConsultAgent: Has error: None

2025-08-08 05:43:29.086 [error] 2025-08-08 05:43:29,086 [DEBUG] ConsultAgent: Has error: None

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,086 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=958, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=12151, output_tokens_details=OutputTokensDetails(reasoning_tokens=7680), total_tokens=13109)

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,086 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=958, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=12151, output_tokens_details=OutputTokensDetails(reasoning_tokens=7680), total_tokens=13109)

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,087 [DEBUG] ConsultAgent: Output type: <class 'list'>

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,087 [DEBUG] ConsultAgent: Output type: <class 'list'>

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,087 [DEBUG] ConsultAgent: Output length: 2

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,087 [DEBUG] ConsultAgent: Output length: 2

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,087 [DEBUG] ConsultAgent: Timestamp: 1754646209.087121

2025-08-08 05:43:29.087 [error] 2025-08-08 05:43:29,087 [DEBUG] ConsultAgent: Timestamp: 1754646209.087121

2025-08-08 05:43:29.125 [error] 2025-08-08 05:43:29,125 [INFO] ConsultAgent: === TOKEN USAGE ===
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Model: gpt-5-nano

2025-08-08 05:43:29.125 [error] 2025-08-08 05:43:29,125 [INFO] ConsultAgent: === TOKEN USAGE ===
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Model: gpt-5-nano

2025-08-08 05:43:29.125 [error] 2025-08-08 05:43:29,125 [INFO] ConsultAgent: Prompt tokens: 940
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Response tokens: 4450
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Total tokens: 5390
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 940, 'response_tokens': 4450, 'total_tokens': 5390, 'model': 'gpt-5-nano'}
2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: ConsultAgent iteration 1 output length: 19201 characters
2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===

2025-08-08 05:43:29.125 [error] 2025-08-08 05:43:29,125 [INFO] ConsultAgent: Prompt tokens: 940
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Response tokens: 4450
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Total tokens: 5390
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 940, 'response_tokens': 4450, 'total_tokens': 5390, 'model': 'gpt-5-nano'}
2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: ConsultAgent iteration 1 output length: 19201 characters
2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===

2025-08-08 05:43:29.125 [error] 2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: FINAL: Below is a production-ready Python microservice for user authentication using FastAPI, with JWT-based authentication, bcrypt password hashing, SQLite via SQLAlchemy, Pydantic validation, simple rate limiting, logging, health checks, Docker-ready setup, and pytest-based unit tests. The repository layout is provided as multiple files within a single code block to be ready for copy-paste into your project.

Note: This code uses an in-process rate limiter (per-process memory). For horizontal scaling, replace with a distributed store (e.g., Redis) in a real deployment. The code includes security headers, defensive error handling, and clean separation of concerns.

Code bundle (multiple files)

# File: app/config.py
from __future__ import annotations

from pydantic import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days in minutes
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"


def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()


# File: app/db.py
from __future__ import annotations

import os
from typing import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

Base = declarative_base()
_engine = None
_SessionLocal = None


def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)


def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()


# File: app/models.py
from __future__ import annotations

import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from .db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"


# File: app/security.py
from __future__ import annotations

import datetime
from typing import Optional, Dict

import bcrypt
import jwt
from datetime import datetime, timedelta

# Internal secret storage; will be initialized via set_jwt_secret()
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"


def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key


def hash_password(plain_password: str, rounds: int = 12) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False


def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    return jwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)


def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return jwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])


def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)


def create_access_token(user_id: int, expires_minutes: int = 15) -> str:
    """
    Create a short-lived access token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "access")


def create_refresh_token(user_id: int, expires_minutes: int = 60 * 24 * 7) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "refresh")


def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")


def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1


# File: app/schemas.py
from __future__ import annotations

from pydantic import BaseModel, EmailStr, constr
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"


class TokenRefresh(BaseModel):
    refresh_token: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True


# File: app/rate_limiter.py
import time
from typing import Dict, Tuple

class RateLimiter:
    def __init__(self, window_seconds: int, max_requests: int):
        self.window = window_seconds
        self.max = max_requests
        self.clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        now = time.time()
        count, window_start = self.clients.get(key, (0, now))
        if now - window_start > self.window:
            # New window
            self.clients[key] = (1, now)
            return True
        else:
            if count < self.max:
                self.clients[key] = (count + 1, window_start)
                return True
            else:
                return False


# File: app/routers/auth.py
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from ..db import get_session
from ..models import User
from ..schemas import UserCreate, UserLogin, TokenResponse, TokenRefresh
from ..security import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
    extract_user_id_from_payload,
    set_jwt_secret,
)
from ..rate_limiter import RateLimiter
from datetime import datetime

from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/auth", tags=["auth"])
# Simple in-memory rate limiter; per-process. For production, use Redis or similar.
rate_limiter = RateLimiter(window_seconds=60, max_requests=5)
logger = logging.getLogger("auth")


@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Register a new user and return an access token (and optionally a refresh token).
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = hash_password(user_in.password, rounds=12)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=15)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(get_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    client_ip = getattr(request, "client", None)
    host = client_ip.host if client_ip else "unknown"

    if not rate_limiter.is_allowed(host + ":login"):
        logger.warning(f"Rate limit exceeded for {host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token(user.id, expires_minutes=15)
    refresh_token = create_refresh_token(user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    new_access = create_access_token(user_id, expires_minutes=15)
    new_refresh = create_refresh_token(user_id, expires_minutes=60 * 24 * 7)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)


# File: app/main.py
from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse

from .config import get_settings
from .db import init_db
from .security import set_jwt_secret
from .routers import auth as auth_routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

def _setup_logging(level: str) -> None:
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )


def _security_headers_middleware(app: FastAPI) -> None:
    @app.middleware("http")
    async def add_security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        # Minimal, strong defaults for security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response


def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    init_db(db_url)

    if jwt_secret:
        set_jwt_secret(jwt_secret)
    else:
        set_jwt_secret(settings.JWT_SECRET_KEY)

    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    _setup_logging(settings.LOG_LEVEL)
    _security_headers_middleware(app)

    # Security middleware examples (optional)
    app.add_middleware(CORSMiddleware,
                       allow_origins=["*"],
                       allow_credentials=True,
                       allow_methods=["*"],
                       allow_headers=["*"])

    app.include_router(auth_routes.router)

    @app.get("/health")
    def health():
        return {"status": "healthy", "timestamp": os.times()}

    return app


# Expose a concrete app instance for production deployments
# and a factory for testability.
app = create_app()

# File: Dockerfile
# A minimal Dockerfile to build and run the FastAPI app
"""
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# File: requirements.txt
"""
fastapi==0.106.0
uvicorn[standard]==0.22.0
sqlalchemy==2.0.18
pydantic==1.10.2
bcrypt==3.2.0
jwt==0.3.2
PyJWT==2.5.0
httpx==0.28.0
pytest==8.3.1
pytest-asyncio==0.21.0
"""

# File: tests/test_auth.py
import os
import shutil
import pytest
from typing import AsyncIterator

import httpx

# Ensure test DB cleanup
TEST_DB_PATH = "./test_auth.db"


@pytest.fixture(scope="session", autouse=True)
def _global_cleanup():
    # Cleanup before/after tests
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    yield
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)


from app.main import create_app


@pytest.fixture
def app() -> "FastAPI":
    # Ensure a fresh DB per test session by using a dedicated test DB path
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    # Create app with test DB and secret
    return create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")


@pytest.fixture
async def client(app) -> AsyncIterator[httpx.AsyncClient]:
    async with httpx.AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    assert resp.json()["status"] == "healthy"


@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    # Register
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code == 201 or reg_resp.status_code == 200
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    access_token = reg_json["access_token"]
    refresh_token = reg_json["refresh_token"]

    # Login (using a fresh login with same credentials)
    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    # Token refresh
    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json


@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401


@pytest.mark.asyncio
async def test_rate_limiting_on_login(client: httpx.AsyncClient):
    payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
    # First, register the user so login would be valid
    reg_resp = await client.post("/auth/register", json=payload)
    # The above payload uses email Bob; proceed to login attempts with same email
    login_payload = {"email": "bob@example.com", "password": "WrongPass!"}
    # Perform multiple login attempts to hit the rate limit
    for i in range(6):
        resp = await client.post("/auth/login", json=login_payload)
        if i < 4:
            assert resp.status_code in (401, 200)  # Depending on timing
        else:
            assert resp.status_code == 429


# Note:
# - The tests use a dedicated test database file to avoid clashing with development data.
# - In a real production setup, you would replace the in-memory rate limiter with Redis-based counters,
#   and you would store and rotate refresh tokens securely with revocation lists as needed.

# End of repository content

Security notes and usage:
- Set real secrets via environment variables (JWT_SECRET_KEY in production).
- The rate limiter is per-process; for multi-instance deployments, replace with Redis-backed rate limiting.
- The code uses bcrypt for password hashing; salt rounds default to 12. You can adjust via HASH_ROUNDS in config.
- The Dockerfile is included as a heredoc string; save as Dockerfile in repo root and build with:
  - docker build -t your-name/auth-service .
  - docker run -p 8000:8000 your-name/auth-service
- Unit tests can be run with pytest: pytest

If you would like, I can also provide:
- A docker-compose.yml for local development tying the auth service to a Redis cache (for rate limiting), a database, and a reverse proxy.
- Additional endpoints (e.g., /me for getting current user, protected endpoints) and more extensive security headers.
2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:43:29,125 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: FINAL: Below is a production-ready Python microservice for user authentication using FastAPI, with JWT-based authentication, bcrypt password hashing, SQLite via SQLAlchemy, Pydantic validation, simple rate limiting, logging, health checks, Docker-ready setup, and pytest-based unit tests. The repository layout is provided as multiple files within a single code block to be ready for copy-paste into your project.

Note: This code uses an in-process rate limiter (per-process memory). For horizontal scaling, replace with a distributed store (e.g., Redis) in a real deployment. The code includes security headers, defensive error handling, and clean separation of concerns.

Code bundle (multiple files)

# File: app/config.py
from __future__ import annotations

from pydantic import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days in minutes
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"


def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()


# File: app/db.py
from __future__ import annotations

import os
from typing import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

Base = declarative_base()
_engine = None
_SessionLocal = None


def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)


def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()


# File: app/models.py
from __future__ import annotations

import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from .db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"


# File: app/security.py
from __future__ import annotations

import datetime
from typing import Optional, Dict

import bcrypt
import jwt
from datetime import datetime, timedelta

# Internal secret storage; will be initialized via set_jwt_secret()
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"


def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key


def hash_password(plain_password: str, rounds: int = 12) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False


def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    return jwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)


def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return jwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])


def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)


def create_access_token(user_id: int, expires_minutes: int = 15) -> str:
    """
    Create a short-lived access token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "access")


def create_refresh_token(user_id: int, expires_minutes: int = 60 * 24 * 7) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "refresh")


def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")


def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1


# File: app/schemas.py
from __future__ import annotations

from pydantic import BaseModel, EmailStr, constr
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"


class TokenRefresh(BaseModel):
    refresh_token: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True


# File: app/rate_limiter.py
import time
from typing import Dict, Tuple

class RateLimiter:
    def __init__(self, window_seconds: int, max_requests: int):
        self.window = window_seconds
        self.max = max_requests
        self.clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        now = time.time()
        count, window_start = self.clients.get(key, (0, now))
        if now - window_start > self.window:
            # New window
            self.clients[key] = (1, now)
            return True
        else:
            if count < self.max:
                self.clients[key] = (count + 1, window_start)
                return True
            else:
                return False


# File: app/routers/auth.py
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from ..db import get_session
from ..models import User
from ..schemas import UserCreate, UserLogin, TokenResponse, TokenRefresh
from ..security import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
    extract_user_id_from_payload,
    set_jwt_secret,
)
from ..rate_limiter import RateLimiter
from datetime import datetime

from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/auth", tags=["auth"])
# Simple in-memory rate limiter; per-process. For production, use Redis or similar.
rate_limiter = RateLimiter(window_seconds=60, max_requests=5)
logger = logging.getLogger("auth")


@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Register a new user and return an access token (and optionally a refresh token).
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = hash_password(user_in.password, rounds=12)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=15)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(get_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    client_ip = getattr(request, "client", None)
    host = client_ip.host if client_ip else "unknown"

    if not rate_limiter.is_allowed(host + ":login"):
        logger.warning(f"Rate limit exceeded for {host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token(user.id, expires_minutes=15)
    refresh_token = create_refresh_token(user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    new_access = create_access_token(user_id, expires_minutes=15)
    new_refresh = create_refresh_token(user_id, expires_minutes=60 * 24 * 7)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)


# File: app/main.py
from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse

from .config import get_settings
from .db import init_db
from .security import set_jwt_secret
from .routers import auth as auth_routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

def _setup_logging(level: str) -> None:
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )


def _security_headers_middleware(app: FastAPI) -> None:
    @app.middleware("http")
    async def add_security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        # Minimal, strong defaults for security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response


def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    init_db(db_url)

    if jwt_secret:
        set_jwt_secret(jwt_secret)
    else:
        set_jwt_secret(settings.JWT_SECRET_KEY)

    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    _setup_logging(settings.LOG_LEVEL)
    _security_headers_middleware(app)

    # Security middleware examples (optional)
    app.add_middleware(CORSMiddleware,
                       allow_origins=["*"],
                       allow_credentials=True,
                       allow_methods=["*"],
                       allow_headers=["*"])

    app.include_router(auth_routes.router)

    @app.get("/health")
    def health():
        return {"status": "healthy", "timestamp": os.times()}

    return app


# Expose a concrete app instance for production deployments
# and a factory for testability.
app = create_app()

# File: Dockerfile
# A minimal Dockerfile to build and run the FastAPI app
"""
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# File: requirements.txt
"""
fastapi==0.106.0
uvicorn[standard]==0.22.0
sqlalchemy==2.0.18
pydantic==1.10.2
bcrypt==3.2.0
jwt==0.3.2
PyJWT==2.5.0
httpx==0.28.0
pytest==8.3.1
pytest-asyncio==0.21.0
"""

# File: tests/test_auth.py
import os
import shutil
import pytest
from typing import AsyncIterator

import httpx

# Ensure test DB cleanup
TEST_DB_PATH = "./test_auth.db"


@pytest.fixture(scope="session", autouse=True)
def _global_cleanup():
    # Cleanup before/after tests
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    yield
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)


from app.main import create_app


@pytest.fixture
def app() -> "FastAPI":
    # Ensure a fresh DB per test session by using a dedicated test DB path
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    # Create app with test DB and secret
    return create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")


@pytest.fixture
async def client(app) -> AsyncIterator[httpx.AsyncClient]:
    async with httpx.AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    assert resp.json()["status"] == "healthy"


@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    # Register
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code == 201 or reg_resp.status_code == 200
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    access_token = reg_json["access_token"]
    refresh_token = reg_json["refresh_token"]

    # Login (using a fresh login with same credentials)
    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    # Token refresh
    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json


@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401


@pytest.mark.asyncio
async def test_rate_limiting_on_login(client: httpx.AsyncClient):
    payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
    # First, register the user so login would be valid
    reg_resp = await client.post("/auth/register", json=payload)
    # The above payload uses email Bob; proceed to login attempts with same email
    login_payload = {"email": "bob@example.com", "password": "WrongPass!"}
    # Perform multiple login attempts to hit the rate limit
    for i in range(6):
        resp = await client.post("/auth/login", json=login_payload)
        if i < 4:
            assert resp.status_code in (401, 200)  # Depending on timing
        else:
            assert resp.status_code == 429


# Note:
# - The tests use a dedicated test database file to avoid clashing with development data.
# - In a real production setup, you would replace the in-memory rate limiter with Redis-based counters,
#   and you would store and rotate refresh tokens securely with revocation lists as needed.

# End of repository content

Security notes and usage:
- Set real secrets via environment variables (JWT_SECRET_KEY in production).
- The rate limiter is per-process; for multi-instance deployments, replace with Redis-backed rate limiting.
- The code uses bcrypt for password hashing; salt rounds default to 12. You can adjust via HASH_ROUNDS in config.
- The Dockerfile is included as a heredoc string; save as Dockerfile in repo root and build with:
  - docker build -t your-name/auth-service .
  - docker run -p 8000:8000 your-name/auth-service
- Unit tests can be run with pytest: pytest

If you would like, I can also provide:
- A docker-compose.yml for local development tying the auth service to a Redis cache (for rate limiting), a database, and a reverse proxy.
- Additional endpoints (e.g., /me for getting current user, protected endpoints) and more extensive security headers.
2025-08-08 05:43:29,125 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:43:29,125 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,125 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Running critic review for iteration 1
2025-08-08 05:43:29,126 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:43:29,126 [DEBUG] Critic: Model: o3

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,125 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:43:29,125 [INFO] ConsultAgent: Running critic review for iteration 1
2025-08-08 05:43:29,126 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:43:29,126 [DEBUG] Critic: Model: o3

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: Review prompt length: 21630 characters

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: Review prompt length: 21630 characters

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: Response to review length: 19201 characters
2025-08-08 05:43:29,126 [DEBUG] Critic: Artifact type: code

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: Response to review length: 19201 characters
2025-08-08 05:43:29,126 [DEBUG] Critic: Artifact type: code

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: Timestamp: 1754646209.1262228

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: Timestamp: 1754646209.1262228

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:43:29,126 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
FINAL: Below is a production-ready Python microservice for user authentication using FastAPI, with JWT-based authentication, bcrypt password hashing, SQLite via SQLAlchemy, Pydantic validation, simple rate limiting, logging, health checks, Docker-ready setup, and pytest-based unit tests. The repository layout is provided as multiple files within a single code block to be ready for copy-paste into your project.

Note: This code uses an in-process rate limiter (per-process memory). For horizontal scaling, replace with a distributed store (e.g., Redis) in a real deployment. The code includes security headers, defensive error handling, and clean separation of concerns.

Code bundle (multiple files)

# File: app/config.py
from __future__ import annotations

from pydantic import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days in minutes
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"


def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()


# File: app/db.py
from __future__ import annotations

import os
from typing import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

Base = declarative_base()
_engine = None
_SessionLocal = None


def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)


def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()


# File: app/models.py
from __future__ import annotations

import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from .db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"


# File: app/security.py
from __future__ import annotations

import datetime
from typing import Optional, Dict

import bcrypt
import jwt
from datetime import datetime, timedelta

# Internal secret storage; will be initialized via set_jwt_secret()
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"


def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key


def hash_password(plain_password: str, rounds: int = 12) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False


def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    return jwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)


def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return jwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])


def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)


def create_access_token(user_id: int, expires_minutes: int = 15) -> str:
    """
    Create a short-lived access token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "access")


def create_refresh_token(user_id: int, expires_minutes: int = 60 * 24 * 7) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "refresh")


def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")


def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1


# File: app/schemas.py
from __future__ import annotations

from pydantic import BaseModel, EmailStr, constr
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"


class TokenRefresh(BaseModel):
    refresh_token: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True


# File: app/rate_limiter.py
import time
from typing import Dict, Tuple

class RateLimiter:
    def __init__(self, window_seconds: int, max_requests: int):
        self.window = window_seconds
        self.max = max_requests
        self.clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        now = time.time()
        count, window_start = self.clients.get(key, (0, now))
        if now - window_start > self.window:
            # New window
            self.clients[key] = (1, now)
            return True
        else:
            if count < self.max:
                self.clients[key] = (count + 1, window_start)
                return True
            else:
                return False


# File: app/routers/auth.py
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from ..db import get_session
from ..models import User
from ..schemas import UserCreate, UserLogin, TokenResponse, TokenRefresh
from ..security import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
    extract_user_id_from_payload,
    set_jwt_secret,
)
from ..rate_limiter import RateLimiter
from datetime import datetime

from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/auth", tags=["auth"])
# Simple in-memory rate limiter; per-process. For production, use Redis or similar.
rate_limiter = RateLimiter(window_seconds=60, max_requests=5)
logger = logging.getLogger("auth")


@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Register a new user and return an access token (and optionally a refresh token).
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = hash_password(user_in.password, rounds=12)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=15)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(get_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    client_ip = getattr(request, "client", None)
    host = client_ip.host if client_ip else "unknown"

    if not rate_limiter.is_allowed(host + ":login"):
        logger.warning(f"Rate limit exceeded for {host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token(user.id, expires_minutes=15)
    refresh_token = create_refresh_token(user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    new_access = create_access_token(user_id, expires_minutes=15)
    new_refresh = create_refresh_token(user_id, expires_minutes=60 * 24 * 7)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)


# File: app/main.py
from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse

from .config import get_settings
from .db import init_db
from .security import set_jwt_secret
from .routers import auth as auth_routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

def _setup_logging(level: str) -> None:
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )


def _security_headers_middleware(app: FastAPI) -> None:
    @app.middleware("http")
    async def add_security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        # Minimal, strong defaults for security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response


def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    init_db(db_url)

    if jwt_secret:
        set_jwt_secret(jwt_secret)
    else:
        set_jwt_secret(settings.JWT_SECRET_KEY)

    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    _setup_logging(settings.LOG_LEVEL)
    _security_headers_middleware(app)

    # Security middleware examples (optional)
    app.add_middleware(CORSMiddleware,
                       allow_origins=["*"],
                       allow_credentials=True,
                       allow_methods=["*"],
                       allow_headers=["*"])

    app.include_router(auth_routes.router)

    @app.get("/health")
    def health():
        return {"status": "healthy", "timestamp": os.times()}

    return app


# Expose a concrete app instance for production deployments
# and a factory for testability.
app = create_app()

# File: Dockerfile
# A minimal Dockerfile to build and run the FastAPI app
"""
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# File: requirements.txt
"""
fastapi==0.106.0
uvicorn[standard]==0.22.0
sqlalchemy==2.0.18
pydantic==1.10.2
bcrypt==3.2.0
jwt==0.3.2
PyJWT==2.5.0
httpx==0.28.0
pytest==8.3.1
pytest-asyncio==0.21.0
"""

# File: tests/test_auth.py
import os
import shutil
import pytest
from typing import AsyncIterator

import httpx

# Ensure test DB cleanup
TEST_DB_PATH = "./test_auth.db"


@pytest.fixture(scope="session", autouse=True)
def _global_cleanup():
    # Cleanup before/after tests
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    yield
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)


from app.main import create_app


@pytest.fixture
def app() -> "FastAPI":
    # Ensure a fresh DB per test session by using a dedicated test DB path
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    # Create app with test DB and secret
    return create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")


@pytest.fixture
async def client(app) -> AsyncIterator[httpx.AsyncClient]:
    async with httpx.AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    assert resp.json()["status"] == "healthy"


@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    # Register
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code == 201 or reg_resp.status_code == 200
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    access_token = reg_json["access_token"]
    refresh_token = reg_json["refresh_token"]

    # Login (using a fresh login with same credentials)
    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    # Token refresh
    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json


@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401


@pytest.mark.asyncio
async def test_rate_limiting_on_login(client: httpx.AsyncClient):
    payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
    # First, register the user so login would be valid
    reg_resp = await client.post("/auth/register", json=payload)
    # The above payload uses email Bob; proceed to login attempts with same email
    login_payload = {"email": "bob@example.com", "password": "WrongPass!"}
    # Perform multiple login attempts to hit the rate limit
    for i in range(6):
        resp = await client.post("/auth/login", json=login_payload)
        if i < 4:
            assert resp.status_code in (401, 200)  # Depending on timing
        else:
            assert resp.status_code == 429


# Note:
# - The tests use a dedicated test database file to avoid clashing with development data.
# - In a real production setup, you would replace the in-memory rate limiter with Redis-based counters,
#   and you would store and rotate refresh tokens securely with revocation lists as needed.

# End of repository content

Security notes and usage:
- Set real secrets via environment variables (JWT_SECRET_KEY in production).
- The rate limiter is per-process; for multi-instance deployments, replace with Redis-backed rate limiting.
- The code uses bcrypt for password hashing; salt rounds default to 12. You can adjust via HASH_ROUNDS in config.
- The Dockerfile is included as a heredoc string; save as Dockerfile in repo root and build with:
  - docker build -t your-name/auth-service .
  - docker run -p 8000:8000 your-name/auth-service
- Unit tests can be run with pytest: pytest

If you would like, I can also provide:
- A docker-compose.yml for local development tying the auth service to a Redis cache (for rate limiting), a database, and a reverse proxy.
- Additional endpoints (e.g., /me for getting current user, protected endpoints) and more extensive security headers.

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:43:29,126 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
FINAL: Below is a production-ready Python microservice for user authentication using FastAPI, with JWT-based authentication, bcrypt password hashing, SQLite via SQLAlchemy, Pydantic validation, simple rate limiting, logging, health checks, Docker-ready setup, and pytest-based unit tests. The repository layout is provided as multiple files within a single code block to be ready for copy-paste into your project.

Note: This code uses an in-process rate limiter (per-process memory). For horizontal scaling, replace with a distributed store (e.g., Redis) in a real deployment. The code includes security headers, defensive error handling, and clean separation of concerns.

Code bundle (multiple files)

# File: app/config.py
from __future__ import annotations

from pydantic import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days in minutes
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"


def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()


# File: app/db.py
from __future__ import annotations

import os
from typing import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

Base = declarative_base()
_engine = None
_SessionLocal = None


def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)


def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()


# File: app/models.py
from __future__ import annotations

import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from .db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"


# File: app/security.py
from __future__ import annotations

import datetime
from typing import Optional, Dict

import bcrypt
import jwt
from datetime import datetime, timedelta

# Internal secret storage; will be initialized via set_jwt_secret()
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"


def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key


def hash_password(plain_password: str, rounds: int = 12) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False


def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    return jwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)


def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return jwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])


def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)


def create_access_token(user_id: int, expires_minutes: int = 15) -> str:
    """
    Create a short-lived access token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "access")


def create_refresh_token(user_id: int, expires_minutes: int = 60 * 24 * 7) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "refresh")


def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")


def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1


# File: app/schemas.py
from __future__ import annotations

from pydantic import BaseModel, EmailStr, constr
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"


class TokenRefresh(BaseModel):
    refresh_token: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True


# File: app/rate_limiter.py
import time
from typing import Dict, Tuple

class RateLimiter:
    def __init__(self, window_seconds: int, max_requests: int):
        self.window = window_seconds
        self.max = max_requests
        self.clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        now = time.time()
        count, window_start = self.clients.get(key, (0, now))
        if now - window_start > self.window:
            # New window
            self.clients[key] = (1, now)
            return True
        else:
            if count < self.max:
                self.clients[key] = (count + 1, window_start)
                return True
            else:
                return False


# File: app/routers/auth.py
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from ..db import get_session
from ..models import User
from ..schemas import UserCreate, UserLogin, TokenResponse, TokenRefresh
from ..security import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
    extract_user_id_from_payload,
    set_jwt_secret,
)
from ..rate_limiter import RateLimiter
from datetime import datetime

from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/auth", tags=["auth"])
# Simple in-memory rate limiter; per-process. For production, use Redis or similar.
rate_limiter = RateLimiter(window_seconds=60, max_requests=5)
logger = logging.getLogger("auth")


@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Register a new user and return an access token (and optionally a refresh token).
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = hash_password(user_in.password, rounds=12)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=15)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(get_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    client_ip = getattr(request, "client", None)
    host = client_ip.host if client_ip else "unknown"

    if not rate_limiter.is_allowed(host + ":login"):
        logger.warning(f"Rate limit exceeded for {host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token(user.id, expires_minutes=15)
    refresh_token = create_refresh_token(user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    new_access = create_access_token(user_id, expires_minutes=15)
    new_refresh = create_refresh_token(user_id, expires_minutes=60 * 24 * 7)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)


# File: app/main.py
from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse

from .config import get_settings
from .db import init_db
from .security import set_jwt_secret
from .routers import auth as auth_routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

def _setup_logging(level: str) -> None:
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )


def _security_headers_middleware(app: FastAPI) -> None:
    @app.middleware("http")
    async def add_security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        # Minimal, strong defaults for security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response


def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    init_db(db_url)

    if jwt_secret:
        set_jwt_secret(jwt_secret)
    else:
        set_jwt_secret(settings.JWT_SECRET_KEY)

    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    _setup_logging(settings.LOG_LEVEL)
    _security_headers_middleware(app)

    # Security middleware examples (optional)
    app.add_middleware(CORSMiddleware,
                       allow_origins=["*"],
                       allow_credentials=True,
                       allow_methods=["*"],
                       allow_headers=["*"])

    app.include_router(auth_routes.router)

    @app.get("/health")
    def health():
        return {"status": "healthy", "timestamp": os.times()}

    return app


# Expose a concrete app instance for production deployments
# and a factory for testability.
app = create_app()

# File: Dockerfile
# A minimal Dockerfile to build and run the FastAPI app
"""
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# File: requirements.txt
"""
fastapi==0.106.0
uvicorn[standard]==0.22.0
sqlalchemy==2.0.18
pydantic==1.10.2
bcrypt==3.2.0
jwt==0.3.2
PyJWT==2.5.0
httpx==0.28.0
pytest==8.3.1
pytest-asyncio==0.21.0
"""

# File: tests/test_auth.py
import os
import shutil
import pytest
from typing import AsyncIterator

import httpx

# Ensure test DB cleanup
TEST_DB_PATH = "./test_auth.db"


@pytest.fixture(scope="session", autouse=True)
def _global_cleanup():
    # Cleanup before/after tests
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    yield
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)


from app.main import create_app


@pytest.fixture
def app() -> "FastAPI":
    # Ensure a fresh DB per test session by using a dedicated test DB path
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    # Create app with test DB and secret
    return create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")


@pytest.fixture
async def client(app) -> AsyncIterator[httpx.AsyncClient]:
    async with httpx.AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    assert resp.json()["status"] == "healthy"


@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    # Register
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code == 201 or reg_resp.status_code == 200
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    access_token = reg_json["access_token"]
    refresh_token = reg_json["refresh_token"]

    # Login (using a fresh login with same credentials)
    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    # Token refresh
    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json


@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401


@pytest.mark.asyncio
async def test_rate_limiting_on_login(client: httpx.AsyncClient):
    payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
    # First, register the user so login would be valid
    reg_resp = await client.post("/auth/register", json=payload)
    # The above payload uses email Bob; proceed to login attempts with same email
    login_payload = {"email": "bob@example.com", "password": "WrongPass!"}
    # Perform multiple login attempts to hit the rate limit
    for i in range(6):
        resp = await client.post("/auth/login", json=login_payload)
        if i < 4:
            assert resp.status_code in (401, 200)  # Depending on timing
        else:
            assert resp.status_code == 429


# Note:
# - The tests use a dedicated test database file to avoid clashing with development data.
# - In a real production setup, you would replace the in-memory rate limiter with Redis-based counters,
#   and you would store and rotate refresh tokens securely with revocation lists as needed.

# End of repository content

Security notes and usage:
- Set real secrets via environment variables (JWT_SECRET_KEY in production).
- The rate limiter is per-process; for multi-instance deployments, replace with Redis-backed rate limiting.
- The code uses bcrypt for password hashing; salt rounds default to 12. You can adjust via HASH_ROUNDS in config.
- The Dockerfile is included as a heredoc string; save as Dockerfile in repo root and build with:
  - docker build -t your-name/auth-service .
  - docker run -p 8000:8000 your-name/auth-service
- Unit tests can be run with pytest: pytest

If you would like, I can also provide:
- A docker-compose.yml for local development tying the auth service to a Redis cache (for rate limiting), a database, and a reverse proxy.
- Additional endpoints (e.g., /me for getting current user, protected endpoints) and more extensive security headers.

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:43:29.126 [error] 2025-08-08 05:43:29,126 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:43:34.663 [info] Handling CallTool action for tool 'consult'
2025-08-08 05:43:34.663 [info] Calling tool 'consult' with toolCallId: tool_99a62daf-60a6-4541-80d8-61d8d3d5c22
2025-08-08 05:44:30.811 [error] 2025-08-08 05:44:30,811 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:44:30.811 [error] 2025-08-08 05:44:30,811 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:44:30.812 [error] 2025-08-08 05:44:30,812 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,812 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,812 [DEBUG] Critic: Response length: 991 characters
2025-08-08 05:44:30,812 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:44:30,812 [DEBUG] Critic: Has error: False
2025-08-08 05:44:30,812 [DEBUG] Critic: Timestamp: 1754646270.8129835
2025-08-08 05:44:30,813 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:44:30,813 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

### CRITICAL ISSUES
- requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.
  `import jwt` becomes ambiguous; if the python-jwt module is imported, the call
  `jwt.encode(payload, key, algorithm=...)` in `security._encode_token()` raises `TypeError` because that library does not accept the `algorithm` keyword argument.
  This will prevent token creation and authentication from working.

### SUGGESTIONS
- Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
- Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
- Use `HASH_ROUNDS` from Settings instead of a hard-coded value.
- Declare `request: Request` without a default `None`; FastAPI will always inject it.
2025-08-08 05:44:30,813 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,812 [DEBUG] Critic: Response length: 991 characters
2025-08-08 05:44:30,812 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:44:30,812 [DEBUG] Critic: Has error: False
2025-08-08 05:44:30,812 [DEBUG] Critic: Timestamp: 1754646270.8129835
2025-08-08 05:44:30,813 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:44:30,813 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

### CRITICAL ISSUES
- requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.
  `import jwt` becomes ambiguous; if the python-jwt module is imported, the call
  `jwt.encode(payload, key, algorithm=...)` in `security._encode_token()` raises `TypeError` because that library does not accept the `algorithm` keyword argument.
  This will prevent token creation and authentication from working.

### SUGGESTIONS
- Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
- Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
- Use `HASH_ROUNDS` from Settings instead of a hard-coded value.
- Declare `request: Request` without a default `None`; FastAPI will always inject it.
2025-08-08 05:44:30,813 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: === CRITIC RESULT PARSED ===

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: === CRITIC RESULT PARSED ===

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Passed: False

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Passed: False

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Feedback: The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Feedback: The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestions count: 4

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestions count: 4

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Critical issue 1: requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Critical issue 1: requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 1: Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 2: Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 3: Use `HASH_ROUNDS` from Settings instead of a hard-coded value.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 1: Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 2: Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 3: Use `HASH_ROUNDS` from Settings instead of a hard-coded value.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 4: Declare `request: Request` without a default `None`; FastAPI will always inject it.
2025-08-08 05:44:30,813 [DEBUG] Critic: Timestamp: 1754646270.813743
2025-08-08 05:44:30,813 [INFO] Critic: Critic review result: FAILED
2025-08-08 05:44:30,813 [WARNING] Critic: Critic found 1 critical issues

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] Critic: Suggestion 4: Declare `request: Request` without a default `None`; FastAPI will always inject it.
2025-08-08 05:44:30,813 [DEBUG] Critic: Timestamp: 1754646270.813743
2025-08-08 05:44:30,813 [INFO] Critic: Critic review result: FAILED
2025-08-08 05:44:30,813 [WARNING] Critic: Critic found 1 critical issues

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Feedback: The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

2025-08-08 05:44:30.813 [error] 2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Feedback: The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

2025-08-08 05:44:30.815 [error] 2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Suggestions count: 4
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Critical issue 1: requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 1: Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 2: Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 3: Use `HASH_ROUNDS` from Settings instead of a hard-coded value.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 4: Declare `request: Request` without a default `None`; FastAPI will always inject it.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Timestamp: 1754646270.8140826
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Critic review: FAILED
2025-08-08 05:44:30,814 [WARNING] ConsultAgent: Critic feedback: The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.
2025-08-08 05:44:30,814 [WARNING] ConsultAgent: Critical issue: requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.
2025-08-08 05:44:30,814 [WARNING] ConsultAgent: Critic failed - forcing retry 2/3
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Starting iteration 2/3
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: === API CALL START ===
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Prompt length: 23681 characters
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Context:
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Timestamp: 1754646270.814425
2025-08-08 05:44:30,814 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Prompt length: 23681 characters
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:44:30,814 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:44:30,814 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

### CRITICAL ISSUES IDENTIFIED:
- requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.

### SUGGESTIONS FOR IMPROVEMENT:
- Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
- Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
- Use `HASH_ROUNDS` from Settings instead of a hard-coded value.
- Declare `request: Request` without a default `None`; FastAPI will always inject it.



FINAL: Below is a production-ready Python microservice for user authentication using FastAPI, with JWT-based authentication, bcrypt password hashing, SQLite via SQLAlchemy, Pydantic validation, simple rate limiting, logging, health checks, Docker-ready setup, and pytest-based unit tests. The repository layout is provided as multiple files within a single code block to be ready for copy-paste into your project.

Note: This code uses an in-process rate limiter (per-process memory). For horizontal scaling, replace with a distributed store (e.g., Redis) in a real deployment. The code includes security headers, defensive error handling, and clean separation of concerns.

Code bundle (multiple files)

# File: app/config.py
from __future__ import annotations

from pydantic import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days in minutes
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"


def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()


# File: app/db.py
from __future__ import annotations

import os
from typing import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

Base = declarative_base()
_engine = None
_SessionLocal = None


def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)


def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()


# File: app/models.py
from __future__ import annotations

import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from .db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"


# File: app/security.py
from __future__ import annotations

import datetime
from typing import Optional, Dict

import bcrypt
import jwt
from datetime import datetime, timedelta

# Internal secret storage; will be initialized via set_jwt_secret()
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"


def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key


def hash_password(plain_password: str, rounds: int = 12) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False


def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    return jwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)


def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return jwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])


def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)


def create_access_token(user_id: int, expires_minutes: int = 15) -> str:
    """
    Create a short-lived access token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "access")


def create_refresh_token(user_id: int, expires_minutes: int = 60 * 24 * 7) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "refresh")


def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")


def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1


# File: app/schemas.py
from __future__ import annotations

from pydantic import BaseModel, EmailStr, constr
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"


class TokenRefresh(BaseModel):
    refresh_token: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True


# File: app/rate_limiter.py
import time
from typing import Dict, Tuple

class RateLimiter:
    def __init__(self, window_seconds: int, max_requests: int):
        self.window = window_seconds
        self.max = max_requests
        self.clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        now = time.time()
        count, window_start = self.clients.get(key, (0, now))
        if now - window_start > self.window:
            # New window
            self.clients[key] = (1, now)
            return True
        else:
            if count < self.max:
                self.clients[key] = (count + 1, window_start)
                return True
            else:
                return False


# File: app/routers/auth.py
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from ..db import get_session
from ..models import User
from ..schemas import UserCreate, UserLogin, TokenResponse, TokenRefresh
from ..security import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
    extract_user_id_from_payload,
    set_jwt_secret,
)
from ..rate_limiter import RateLimiter
from datetime import datetime

from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/auth", tags=["auth"])
# Simple in-memory rate limiter; per-process. For production, use Redis or similar.
rate_limiter = RateLimiter(window_seconds=60, max_requests=5)
logger = logging.getLogger("auth")


@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Register a new user and return an access token (and optionally a refresh token).
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = hash_password(user_in.password, rounds=12)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=15)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(get_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    client_ip = getattr(request, "client", None)
    host = client_ip.host if client_ip else "unknown"

    if not rate_limiter.is_allowed(host + ":login"):
        logger.warning(f"Rate limit exceeded for {host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token(user.id, expires_minutes=15)
    refresh_token = create_refresh_token(user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    new_access = create_access_token(user_id, expires_minutes=15)
    new_refresh = create_refresh_token(user_id, expires_minutes=60 * 24 * 7)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)


# File: app/main.py
from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse

from .config import get_settings
from .db import init_db
from .security import set_jwt_secret
from .routers import auth as auth_routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

def _setup_logging(level: str) -> None:
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )


def _security_headers_middleware(app: FastAPI) -> None:
    @app.middleware("http")
    async def add_security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        # Minimal, strong defaults for security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response


def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    init_db(db_url)

    if jwt_secret:
        set_jwt_secret(jwt_secret)
    else:
        set_jwt_secret(settings.JWT_SECRET_KEY)

    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    _setup_logging(settings.LOG_LEVEL)
    _security_headers_middleware(app)

    # Security middleware examples (optional)
    app.add_middleware(CORSMiddleware,
                       allow_origins=["*"],
                       allow_credentials=True,
                       allow_methods=["*"],
                       allow_headers=["*"])

    app.include_router(auth_routes.router)

    @app.get("/health")
    def health():
        return {"status": "healthy", "timestamp": os.times()}

    return app


# Expose a concrete app instance for production deployments
# and a factory for testability.
app = create_app()

# File: Dockerfile
# A minimal Dockerfile to build and run the FastAPI app
"""
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# File: requirements.txt
"""
fastapi==0.106.0
uvicorn[standard]==0.22.0
sqlalchemy==2.0.18
pydantic==1.10.2
bcrypt==3.2.0
jwt==0.3.2
PyJWT==2.5.0
httpx==0.28.0
pytest==8.3.1
pytest-asyncio==0.21.0
"""

# File: tests/test_auth.py
import os
import shutil
import pytest
from typing import AsyncIterator

import httpx

# Ensure test DB cleanup
TEST_DB_PATH = "./test_auth.db"


@pytest.fixture(scope="session", autouse=True)
def _global_cleanup():
    # Cleanup before/after tests
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    yield
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)


from app.main import create_app


@pytest.fixture
def app() -> "FastAPI":
    # Ensure a fresh DB per test session by using a dedicated test DB path
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    # Create app with test DB and secret
    return create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")


@pytest.fixture
async def client(app) -> AsyncIterator[httpx.AsyncClient]:
    async with httpx.AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    assert resp.json()["status"] == "healthy"


@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    # Register
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code == 201 or reg_resp.status_code == 200
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    access_token = reg_json["access_token"]
    refresh_token = reg_json["refresh_token"]

    # Login (using a fresh login with same credentials)
    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    # Token refresh
    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json


@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401


@pytest.mark.asyncio
async def test_rate_limiting_on_login(client: httpx.AsyncClient):
    payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
    # First, register the user so login would be valid
    reg_resp = await client.post("/auth/register", json=payload)
    # The above payload uses email Bob; proceed to login attempts with same email
    login_payload = {"email": "bob@example.com", "password": "WrongPass!"}
    # Perform multiple login attempts to hit the rate limit
    for i in range(6):
        resp = await client.post("/auth/login", json=login_payload)
        if i < 4:
            assert resp.status_code in (401, 200)  # Depending on timing
        else:
            assert resp.status_code == 429


# Note:
# - The tests use a dedicated test database file to avoid clashing with development data.
# - In a real production setup, you would replace the in-memory rate limiter with Redis-based counters,
#   and you would store and rotate refresh tokens securely with revocation lists as needed.

# End of repository content

Security notes and usage:
- Set real secrets via environment variables (JWT_SECRET_KEY in production).
- The rate limiter is per-process; for multi-instance deployments, replace with Redis-backed rate limiting.
- The code uses bcrypt for password hashing; salt rounds default to 12. You can adjust via HASH_ROUNDS in config.
- The Dockerfile is included as a heredoc string; save as Dockerfile in repo root and build with:
  - docker build -t your-name/auth-service .
  - docker run -p 8000:8000 your-name/auth-service
- Unit tests can be run with pytest: pytest

If you would like, I can also provide:
- A docker-compose.yml for local development tying the auth service to a Redis cache (for rate limiting), a database, and a reverse proxy.
- Additional endpoints (e.g., /me for getting current user, protected endpoints) and more extensive security headers.

## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.
2025-08-08 05:44:30,814 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:44:30,814 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:44:30.815 [error] 2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Suggestions count: 4
2025-08-08 05:44:30,813 [DEBUG] ConsultAgent: Critical issue 1: requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 1: Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 2: Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 3: Use `HASH_ROUNDS` from Settings instead of a hard-coded value.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Suggestion 4: Declare `request: Request` without a default `None`; FastAPI will always inject it.
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Timestamp: 1754646270.8140826
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Critic review: FAILED
2025-08-08 05:44:30,814 [WARNING] ConsultAgent: Critic feedback: The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.
2025-08-08 05:44:30,814 [WARNING] ConsultAgent: Critical issue: requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.
2025-08-08 05:44:30,814 [WARNING] ConsultAgent: Critic failed - forcing retry 2/3
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Starting iteration 2/3
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: === API CALL START ===
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Prompt length: 23681 characters
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Context:
2025-08-08 05:44:30,814 [DEBUG] ConsultAgent: Timestamp: 1754646270.814425
2025-08-08 05:44:30,814 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Prompt length: 23681 characters
2025-08-08 05:44:30,814 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:44:30,814 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:44:30,814 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
The codebase is generally well-structured, but one dependency conflict will cause the JWT logic to break at runtime.

### CRITICAL ISSUES IDENTIFIED:
- requirements.txt lists both `jwt==0.3.2` (python-jwt) and `PyJWT==2.5.0`.

### SUGGESTIONS FOR IMPROVEMENT:
- Remove the `jwt` (python-jwt) package from requirements.txt and keep only `PyJWT`, or import PyJWT explicitly (`import jwt as pyjwt`) to eliminate the collision.
- Consider making `RateLimiter` thread-/process-safe (e.g., use Redis) and cleaning stale keys.
- Use `HASH_ROUNDS` from Settings instead of a hard-coded value.
- Declare `request: Request` without a default `None`; FastAPI will always inject it.



FINAL: Below is a production-ready Python microservice for user authentication using FastAPI, with JWT-based authentication, bcrypt password hashing, SQLite via SQLAlchemy, Pydantic validation, simple rate limiting, logging, health checks, Docker-ready setup, and pytest-based unit tests. The repository layout is provided as multiple files within a single code block to be ready for copy-paste into your project.

Note: This code uses an in-process rate limiter (per-process memory). For horizontal scaling, replace with a distributed store (e.g., Redis) in a real deployment. The code includes security headers, defensive error handling, and clean separation of concerns.

Code bundle (multiple files)

# File: app/config.py
from __future__ import annotations

from pydantic import BaseSettings


class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days in minutes
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"


def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()


# File: app/db.py
from __future__ import annotations

import os
from typing import Generator

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session

Base = declarative_base()
_engine = None
_SessionLocal = None


def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)


def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()


# File: app/models.py
from __future__ import annotations

import datetime
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from .db import Base


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"


# File: app/security.py
from __future__ import annotations

import datetime
from typing import Optional, Dict

import bcrypt
import jwt
from datetime import datetime, timedelta

# Internal secret storage; will be initialized via set_jwt_secret()
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"


def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key


def hash_password(plain_password: str, rounds: int = 12) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False


def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    return jwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)


def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return jwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])


def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)


def create_access_token(user_id: int, expires_minutes: int = 15) -> str:
    """
    Create a short-lived access token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "access")


def create_refresh_token(user_id: int, expires_minutes: int = 60 * 24 * 7) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    return _build_token(user_id, timedelta(minutes=expires_minutes), "refresh")


def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.InvalidTokenError:
        raise ValueError("Invalid token")


def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1


# File: app/schemas.py
from __future__ import annotations

from pydantic import BaseModel, EmailStr, constr
from typing import Optional
from datetime import datetime


class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"


class TokenRefresh(BaseModel):
    refresh_token: str


class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True


# File: app/rate_limiter.py
import time
from typing import Dict, Tuple

class RateLimiter:
    def __init__(self, window_seconds: int, max_requests: int):
        self.window = window_seconds
        self.max = max_requests
        self.clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        now = time.time()
        count, window_start = self.clients.get(key, (0, now))
        if now - window_start > self.window:
            # New window
            self.clients[key] = (1, now)
            return True
        else:
            if count < self.max:
                self.clients[key] = (count + 1, window_start)
                return True
            else:
                return False


# File: app/routers/auth.py
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.orm import Session

from ..db import get_session
from ..models import User
from ..schemas import UserCreate, UserLogin, TokenResponse, TokenRefresh
from ..security import (
    hash_password,
    verify_password,
    create_access_token,
    create_refresh_token,
    decode_token,
    extract_user_id_from_payload,
    set_jwt_secret,
)
from ..rate_limiter import RateLimiter
from datetime import datetime

from sqlalchemy.exc import IntegrityError

router = APIRouter(prefix="/auth", tags=["auth"])
# Simple in-memory rate limiter; per-process. For production, use Redis or similar.
rate_limiter = RateLimiter(window_seconds=60, max_requests=5)
logger = logging.getLogger("auth")


@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Register a new user and return an access token (and optionally a refresh token).
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    hashed = hash_password(user_in.password, rounds=12)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=15)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(get_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    client_ip = getattr(request, "client", None)
    host = client_ip.host if client_ip else "unknown"

    if not rate_limiter.is_allowed(host + ":login"):
        logger.warning(f"Rate limit exceeded for {host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token(user.id, expires_minutes=15)
    refresh_token = create_refresh_token(user.id, expires_minutes=60 * 24 * 7)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)


@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(get_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    new_access = create_access_token(user_id, expires_minutes=15)
    new_refresh = create_refresh_token(user_id, expires_minutes=60 * 24 * 7)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)


# File: app/main.py
from __future__ import annotations

import logging
import os
from typing import Optional

from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse

from .config import get_settings
from .db import init_db
from .security import set_jwt_secret
from .routers import auth as auth_routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware

def _setup_logging(level: str) -> None:
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    )


def _security_headers_middleware(app: FastAPI) -> None:
    @app.middleware("http")
    async def add_security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        # Minimal, strong defaults for security headers
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response


def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    init_db(db_url)

    if jwt_secret:
        set_jwt_secret(jwt_secret)
    else:
        set_jwt_secret(settings.JWT_SECRET_KEY)

    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    _setup_logging(settings.LOG_LEVEL)
    _security_headers_middleware(app)

    # Security middleware examples (optional)
    app.add_middleware(CORSMiddleware,
                       allow_origins=["*"],
                       allow_credentials=True,
                       allow_methods=["*"],
                       allow_headers=["*"])

    app.include_router(auth_routes.router)

    @app.get("/health")
    def health():
        return {"status": "healthy", "timestamp": os.times()}

    return app


# Expose a concrete app instance for production deployments
# and a factory for testability.
app = create_app()

# File: Dockerfile
# A minimal Dockerfile to build and run the FastAPI app
"""
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# File: requirements.txt
"""
fastapi==0.106.0
uvicorn[standard]==0.22.0
sqlalchemy==2.0.18
pydantic==1.10.2
bcrypt==3.2.0
jwt==0.3.2
PyJWT==2.5.0
httpx==0.28.0
pytest==8.3.1
pytest-asyncio==0.21.0
"""

# File: tests/test_auth.py
import os
import shutil
import pytest
from typing import AsyncIterator

import httpx

# Ensure test DB cleanup
TEST_DB_PATH = "./test_auth.db"


@pytest.fixture(scope="session", autouse=True)
def _global_cleanup():
    # Cleanup before/after tests
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    yield
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)


from app.main import create_app


@pytest.fixture
def app() -> "FastAPI":
    # Ensure a fresh DB per test session by using a dedicated test DB path
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    # Create app with test DB and secret
    return create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")


@pytest.fixture
async def client(app) -> AsyncIterator[httpx.AsyncClient]:
    async with httpx.AsyncClient(app=app, base_url="http://test") as c:
        yield c


@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    assert resp.json()["status"] == "healthy"


@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    # Register
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code == 201 or reg_resp.status_code == 200
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    access_token = reg_json["access_token"]
    refresh_token = reg_json["refresh_token"]

    # Login (using a fresh login with same credentials)
    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    # Token refresh
    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json


@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401


@pytest.mark.asyncio
async def test_rate_limiting_on_login(client: httpx.AsyncClient):
    payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
    # First, register the user so login would be valid
    reg_resp = await client.post("/auth/register", json=payload)
    # The above payload uses email Bob; proceed to login attempts with same email
    login_payload = {"email": "bob@example.com", "password": "WrongPass!"}
    # Perform multiple login attempts to hit the rate limit
    for i in range(6):
        resp = await client.post("/auth/login", json=login_payload)
        if i < 4:
            assert resp.status_code in (401, 200)  # Depending on timing
        else:
            assert resp.status_code == 429


# Note:
# - The tests use a dedicated test database file to avoid clashing with development data.
# - In a real production setup, you would replace the in-memory rate limiter with Redis-based counters,
#   and you would store and rotate refresh tokens securely with revocation lists as needed.

# End of repository content

Security notes and usage:
- Set real secrets via environment variables (JWT_SECRET_KEY in production).
- The rate limiter is per-process; for multi-instance deployments, replace with Redis-backed rate limiting.
- The code uses bcrypt for password hashing; salt rounds default to 12. You can adjust via HASH_ROUNDS in config.
- The Dockerfile is included as a heredoc string; save as Dockerfile in repo root and build with:
  - docker build -t your-name/auth-service .
  - docker run -p 8000:8000 your-name/auth-service
- Unit tests can be run with pytest: pytest

If you would like, I can also provide:
- A docker-compose.yml for local development tying the auth service to a Redis cache (for rate limiting), a database, and a reverse proxy.
- Additional endpoints (e.g., /me for getting current user, protected endpoints) and more extensive security headers.

## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.
2025-08-08 05:44:30,814 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:44:30,814 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:45:26.168 [error] 2025-08-08 05:45:26,167 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:45:26.168 [error] 2025-08-08 05:45:26,167 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:45:26.174 [error] 2025-08-08 05:45:26,173 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:45:26.174 [error] 2025-08-08 05:45:26,173 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:45:26.174 [error] 2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Response length: 21347 characters
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5389, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=14177, output_tokens_details=OutputTokensDetails(reasoning_tokens=9344), total_tokens=19566)
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Timestamp: 1754646326.1742654

2025-08-08 05:45:26.174 [error] 2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Response length: 21347 characters
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5389, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=14177, output_tokens_details=OutputTokensDetails(reasoning_tokens=9344), total_tokens=19566)
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:45:26,174 [DEBUG] ConsultAgent: Timestamp: 1754646326.1742654

2025-08-08 05:45:26.182 [error] 2025-08-08 05:45:26,181 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:45:26.182 [error] 2025-08-08 05:45:26,181 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:45:26.182 [error] 2025-08-08 05:45:26,181 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:45:26,181 [INFO] ConsultAgent: Prompt tokens: 5358
2025-08-08 05:45:26,181 [INFO] ConsultAgent: Response tokens: 4807
2025-08-08 05:45:26,181 [INFO] ConsultAgent: Total tokens: 10165
2025-08-08 05:45:26,182 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5358, 'response_tokens': 4807, 'total_tokens': 10165, 'model': 'gpt-5-nano'}
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: ConsultAgent iteration 2 output length: 21347 characters
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and expiration/rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Simple, thread-safe rate limiting to mitigate brute-force attempts
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure (instructions in README docstring)
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- This is a self-contained module intended for demonstration and testing.
- For multi-instance deployments, replace the in-process RateLimiter with a Redis-backed store.
- Security: Secrets should come from environment variables in production (JWT_SECRET_KEY, etc.).

Usage:
- Run locally: uvicorn this_module:app --reload
- Tests: pytest
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies (imported)
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT, explicitly aliased to avoid collisions with other 'jwt' libs
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    # PyJWT >= 2.0 returns str, older versions may return bytes
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for simple deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _build_app_wrapper() -> FastAPI:
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # Security headers
    _setup_security_headers(app)

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    @app.on_event("startup")
    async def _startup():
        nonlocal db_url, jwt_secret
        # Initialize DB and JWT secret once per app instance
        if not hasattr(app.state, "db_initialized") or not app.state.db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            app.state.db_initialized = True
            # Rate limiter instance per app (thread-safe)
            settings = get_settings()
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            logger.info("Auth DB initialized and JWT secret set.")
        else:
            # Re-using existing app instance
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    # FastAPI ensures Request is injected; keep explicit typing for clarity
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    # Ensure a per-app rate limiter exists
    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # If startup did not run for some reason, initialize a local limiter
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton (startup will initialize DB)
    app = _build_app_wrapper()
    app.include_router(router)

    # Security and startup configuration
    _setup_security_headers(app)  # Ensure wrappers are set
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False

    # Attach startup events to initialize DB and secret lazily
    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    return app

# Build a default app instance for production-like usage (uvicorn module:app)
# Note: Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following tests are embedded for convenience. They can run with pytest if this file
# is named accordingly (e.g., auth_microservice.py) and executed in a test environment.

import asyncio  # noqa: F401 used by pytest-asyncio if needed
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:45:26,182 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:45:26,182 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:45:26,182 [INFO] ConsultAgent: Critic enabled: True

2025-08-08 05:45:26.182 [error] 2025-08-08 05:45:26,181 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:45:26,181 [INFO] ConsultAgent: Prompt tokens: 5358
2025-08-08 05:45:26,181 [INFO] ConsultAgent: Response tokens: 4807
2025-08-08 05:45:26,181 [INFO] ConsultAgent: Total tokens: 10165
2025-08-08 05:45:26,182 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5358, 'response_tokens': 4807, 'total_tokens': 10165, 'model': 'gpt-5-nano'}
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: ConsultAgent iteration 2 output length: 21347 characters
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and expiration/rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Simple, thread-safe rate limiting to mitigate brute-force attempts
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure (instructions in README docstring)
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- This is a self-contained module intended for demonstration and testing.
- For multi-instance deployments, replace the in-process RateLimiter with a Redis-backed store.
- Security: Secrets should come from environment variables in production (JWT_SECRET_KEY, etc.).

Usage:
- Run locally: uvicorn this_module:app --reload
- Tests: pytest
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies (imported)
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT, explicitly aliased to avoid collisions with other 'jwt' libs
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    # PyJWT >= 2.0 returns str, older versions may return bytes
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for simple deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _build_app_wrapper() -> FastAPI:
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # Security headers
    _setup_security_headers(app)

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    @app.on_event("startup")
    async def _startup():
        nonlocal db_url, jwt_secret
        # Initialize DB and JWT secret once per app instance
        if not hasattr(app.state, "db_initialized") or not app.state.db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            app.state.db_initialized = True
            # Rate limiter instance per app (thread-safe)
            settings = get_settings()
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            logger.info("Auth DB initialized and JWT secret set.")
        else:
            # Re-using existing app instance
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    # FastAPI ensures Request is injected; keep explicit typing for clarity
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    # Ensure a per-app rate limiter exists
    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # If startup did not run for some reason, initialize a local limiter
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton (startup will initialize DB)
    app = _build_app_wrapper()
    app.include_router(router)

    # Security and startup configuration
    _setup_security_headers(app)  # Ensure wrappers are set
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False

    # Attach startup events to initialize DB and secret lazily
    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    return app

# Build a default app instance for production-like usage (uvicorn module:app)
# Note: Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following tests are embedded for convenience. They can run with pytest if this file
# is named accordingly (e.g., auth_microservice.py) and executed in a test environment.

import asyncio  # noqa: F401 used by pytest-asyncio if needed
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
2025-08-08 05:45:26,182 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:45:26,182 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:45:26,182 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:45:26,182 [INFO] ConsultAgent: Critic enabled: True

2025-08-08 05:45:26.182 [error] 2025-08-08 05:45:26,182 [INFO] ConsultAgent: Running critic review for iteration 2
2025-08-08 05:45:26,182 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:45:26,182 [DEBUG] Critic: Model: o3
2025-08-08 05:45:26,182 [DEBUG] Critic: Review prompt length: 23776 characters
2025-08-08 05:45:26,182 [DEBUG] Critic: Response to review length: 21347 characters
2025-08-08 05:45:26,182 [DEBUG] Critic: Artifact type: code
2025-08-08 05:45:26,182 [DEBUG] Critic: Timestamp: 1754646326.1822622
2025-08-08 05:45:26,182 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:45:26,182 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and expiration/rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Simple, thread-safe rate limiting to mitigate brute-force attempts
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure (instructions in README docstring)
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- This is a self-contained module intended for demonstration and testing.
- For multi-instance deployments, replace the in-process RateLimiter with a Redis-backed store.
- Security: Secrets should come from environment variables in production (JWT_SECRET_KEY, etc.).

Usage:
- Run locally: uvicorn this_module:app --reload
- Tests: pytest
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies (imported)
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT, explicitly aliased to avoid collisions with other 'jwt' libs
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    # PyJWT >= 2.0 returns str, older versions may return bytes
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for simple deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _build_app_wrapper() -> FastAPI:
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # Security headers
    _setup_security_headers(app)

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    @app.on_event("startup")
    async def _startup():
        nonlocal db_url, jwt_secret
        # Initialize DB and JWT secret once per app instance
        if not hasattr(app.state, "db_initialized") or not app.state.db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            app.state.db_initialized = True
            # Rate limiter instance per app (thread-safe)
            settings = get_settings()
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            logger.info("Auth DB initialized and JWT secret set.")
        else:
            # Re-using existing app instance
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    # FastAPI ensures Request is injected; keep explicit typing for clarity
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    # Ensure a per-app rate limiter exists
    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # If startup did not run for some reason, initialize a local limiter
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton (startup will initialize DB)
    app = _build_app_wrapper()
    app.include_router(router)

    # Security and startup configuration
    _setup_security_headers(app)  # Ensure wrappers are set
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False

    # Attach startup events to initialize DB and secret lazily
    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    return app

# Build a default app instance for production-like usage (uvicorn module:app)
# Note: Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following tests are embedded for convenience. They can run with pytest if this file
# is named accordingly (e.g., auth_microservice.py) and executed in a test environment.

import asyncio  # noqa: F401 used by pytest-asyncio if needed
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:45:26,182 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:45:26.182 [error] 2025-08-08 05:45:26,182 [INFO] ConsultAgent: Running critic review for iteration 2
2025-08-08 05:45:26,182 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:45:26,182 [DEBUG] Critic: Model: o3
2025-08-08 05:45:26,182 [DEBUG] Critic: Review prompt length: 23776 characters
2025-08-08 05:45:26,182 [DEBUG] Critic: Response to review length: 21347 characters
2025-08-08 05:45:26,182 [DEBUG] Critic: Artifact type: code
2025-08-08 05:45:26,182 [DEBUG] Critic: Timestamp: 1754646326.1822622
2025-08-08 05:45:26,182 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:45:26,182 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and expiration/rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Simple, thread-safe rate limiting to mitigate brute-force attempts
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure (instructions in README docstring)
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- This is a self-contained module intended for demonstration and testing.
- For multi-instance deployments, replace the in-process RateLimiter with a Redis-backed store.
- Security: Secrets should come from environment variables in production (JWT_SECRET_KEY, etc.).

Usage:
- Run locally: uvicorn this_module:app --reload
- Tests: pytest
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies (imported)
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT, explicitly aliased to avoid collisions with other 'jwt' libs
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    # PyJWT >= 2.0 returns str, older versions may return bytes
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for simple deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _build_app_wrapper() -> FastAPI:
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # Security headers
    _setup_security_headers(app)

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    @app.on_event("startup")
    async def _startup():
        nonlocal db_url, jwt_secret
        # Initialize DB and JWT secret once per app instance
        if not hasattr(app.state, "db_initialized") or not app.state.db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            app.state.db_initialized = True
            # Rate limiter instance per app (thread-safe)
            settings = get_settings()
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            logger.info("Auth DB initialized and JWT secret set.")
        else:
            # Re-using existing app instance
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    # FastAPI ensures Request is injected; keep explicit typing for clarity
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    # Ensure a per-app rate limiter exists
    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # If startup did not run for some reason, initialize a local limiter
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton (startup will initialize DB)
    app = _build_app_wrapper()
    app.include_router(router)

    # Security and startup configuration
    _setup_security_headers(app)  # Ensure wrappers are set
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False

    # Attach startup events to initialize DB and secret lazily
    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    return app

# Build a default app instance for production-like usage (uvicorn module:app)
# Note: Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following tests are embedded for convenience. They can run with pytest if this file
# is named accordingly (e.g., auth_microservice.py) and executed in a test environment.

import asyncio  # noqa: F401 used by pytest-asyncio if needed
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:45:26,182 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:46:26.085 [error] 2025-08-08 05:46:26,084 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:46:26.085 [error] 2025-08-08 05:46:26,084 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:46:26.086 [error] 2025-08-08 05:46:26,086 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:46:26.086 [error] 2025-08-08 05:46:26,086 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:46:26.086 [error] 2025-08-08 05:46:26,086 [DEBUG] Critic: Response length: 522 characters
2025-08-08 05:46:26,086 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:46:26,086 [DEBUG] Critic: Has error: False
2025-08-08 05:46:26,086 [DEBUG] Critic: Timestamp: 1754646386.0869248
2025-08-08 05:46:26,086 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,086 [DEBUG] Critic: Response length: 522 characters
2025-08-08 05:46:26,086 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:46:26,086 [DEBUG] Critic: Has error: False
2025-08-08 05:46:26,086 [DEBUG] Critic: Timestamp: 1754646386.0869248
2025-08-08 05:46:26,086 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,086 [DEBUG] Critic: ### VERDICT
PASS

### FEEDBACK
Response passes review.

### CRITICAL ISSUES
-

### SUGGESTIONS
- Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
- Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
- The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.
2025-08-08 05:46:26,086 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:46:26,087 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:46:26,087 [DEBUG] Critic: Passed: True
2025-08-08 05:46:26,087 [DEBUG] Critic: Feedback: Response passes review.
2025-08-08 05:46:26,087 [DEBUG] Critic: Critical issues count: 0
2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestions count: 3

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,086 [DEBUG] Critic: ### VERDICT
PASS

### FEEDBACK
Response passes review.

### CRITICAL ISSUES
-

### SUGGESTIONS
- Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
- Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
- The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.
2025-08-08 05:46:26,086 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:46:26,087 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:46:26,087 [DEBUG] Critic: Passed: True
2025-08-08 05:46:26,087 [DEBUG] Critic: Feedback: Response passes review.
2025-08-08 05:46:26,087 [DEBUG] Critic: Critical issues count: 0
2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestions count: 3

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestion 1: Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestion 2: Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestion 3: The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.
2025-08-08 05:46:26,087 [DEBUG] Critic: Timestamp: 1754646386.0871217

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestion 1: Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestion 2: Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
2025-08-08 05:46:26,087 [DEBUG] Critic: Suggestion 3: The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.
2025-08-08 05:46:26,087 [DEBUG] Critic: Timestamp: 1754646386.0871217

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] Critic: Critic review result: PASSED

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] Critic: Critic review result: PASSED

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Passed: True

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Passed: True

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Feedback: Response passes review.
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Critical issues count: 0
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestions count: 3

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Feedback: Response passes review.
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Critical issues count: 0
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestions count: 3

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestion 1: Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestion 1: Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestion 2: Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestion 3: The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Timestamp: 1754646386.087341

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestion 2: Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Suggestion 3: The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Timestamp: 1754646386.087341

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Critic review: PASSED

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Critic review: PASSED

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Critic passed with 3 suggestions

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Critic passed with 3 suggestions

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Starting iteration 3/3

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Starting iteration 3/3

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: === API CALL START ===

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: === API CALL START ===

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Prompt length: 26132 characters

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Prompt length: 26132 characters

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Context:
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Timestamp: 1754646386.0876455
2025-08-08 05:46:26,087 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Context:
2025-08-08 05:46:26,087 [DEBUG] ConsultAgent: Timestamp: 1754646386.0876455
2025-08-08 05:46:26,087 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Prompt length: 26132 characters
2025-08-08 05:46:26,087 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:46:26,087 [INFO] ConsultAgent: --- PROMPT CONTENT START ---

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: Prompt length: 26132 characters
2025-08-08 05:46:26,087 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:46:26,087 [INFO] ConsultAgent: --- PROMPT CONTENT START ---

2025-08-08 05:46:26.087 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
Response passes review.

### CRITICAL ISSUES IDENTIFIED:
- None

### SUGGESTIONS FOR IMPROVEMENT:
- Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
- Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
- The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.



```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and expiration/rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Simple, thread-safe rate limiting to mitigate brute-force attempts
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure (instructions in README docstring)
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- This is a self-contained module intended for demonstration and testing.
- For multi-instance deployments, replace the in-process RateLimiter with a Redis-backed store.
- Security: Secrets should come from environment variables in production (JWT_SECRET_KEY, etc.).

Usage:
- Run locally: uvicorn this_module:app --reload
- Tests: pytest
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies (imported)
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT, explicitly aliased to avoid collisions with other 'jwt' libs
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    # PyJWT >= 2.0 returns str, older versions may return bytes
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for simple deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _build_app_wrapper() -> FastAPI:
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # Security headers
    _setup_security_headers(app)

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    @app.on_event("startup")
    async def _startup():
        nonlocal db_url, jwt_secret
        # Initialize DB and JWT secret once per app instance
        if not hasattr(app.state, "db_initialized") or not app.state.db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            app.state.db_initialized = True
            # Rate limiter instance per app (thread-safe)
            settings = get_settings()
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            logger.info("Auth DB initialized and JWT secret set.")
        else:
            # Re-using existing app instance
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    # FastAPI ensures Request is injected; keep explicit typing for clarity
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    # Ensure a per-app rate limiter exists
    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # If startup did not run for some reason, initialize a local limiter
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton (startup will initialize DB)
    app = _build_app_wrapper()
    app.include_router(router)

    # Security and startup configuration
    _setup_security_headers(app)  # Ensure wrappers are set
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False

    # Attach startup events to initialize DB and secret lazily
    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    return app

# Build a default app instance for production-like usage (uvicorn module:app)
# Note: Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following tests are embedded for convenience. They can run with pytest if this file
# is named accordingly (e.g., auth_microservice.py) and executed in a test environment.

import asyncio  # noqa: F401 used by pytest-asyncio if needed
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

# Critic Suggestions:
# Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
# Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
# The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.


## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.
2025-08-08 05:46:26,087 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:46:26,087 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:46:26.088 [error] 2025-08-08 05:46:26,087 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
Response passes review.

### CRITICAL ISSUES IDENTIFIED:
- None

### SUGGESTIONS FOR IMPROVEMENT:
- Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
- Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
- The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.



```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and expiration/rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Simple, thread-safe rate limiting to mitigate brute-force attempts
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure (instructions in README docstring)
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- This is a self-contained module intended for demonstration and testing.
- For multi-instance deployments, replace the in-process RateLimiter with a Redis-backed store.
- Security: Secrets should come from environment variables in production (JWT_SECRET_KEY, etc.).

Usage:
- Run locally: uvicorn this_module:app --reload
- Tests: pytest
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies (imported)
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT, explicitly aliased to avoid collisions with other 'jwt' libs
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

from pydantic import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    # PyJWT >= 2.0 returns str, older versions may return bytes
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for simple deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _build_app_wrapper() -> FastAPI:
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # Security headers
    _setup_security_headers(app)

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    @app.on_event("startup")
    async def _startup():
        nonlocal db_url, jwt_secret
        # Initialize DB and JWT secret once per app instance
        if not hasattr(app.state, "db_initialized") or not app.state.db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            app.state.db_initialized = True
            # Rate limiter instance per app (thread-safe)
            settings = get_settings()
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            logger.info("Auth DB initialized and JWT secret set.")
        else:
            # Re-using existing app instance
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    # FastAPI ensures Request is injected; keep explicit typing for clarity
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    # Ensure a per-app rate limiter exists
    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # If startup did not run for some reason, initialize a local limiter
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton (startup will initialize DB)
    app = _build_app_wrapper()
    app.include_router(router)

    # Security and startup configuration
    _setup_security_headers(app)  # Ensure wrappers are set
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False

    # Attach startup events to initialize DB and secret lazily
    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    return app

# Build a default app instance for production-like usage (uvicorn module:app)
# Note: Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following tests are embedded for convenience. They can run with pytest if this file
# is named accordingly (e.g., auth_microservice.py) and executed in a test environment.

import asyncio  # noqa: F401 used by pytest-asyncio if needed
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

# Critic Suggestions:
# Calling `_setup_security_headers` twice (`_build_app_wrapper` and `create_app`) registers the same middleware twice; removing the second call avoids redundant wrapping.
# Consider moving `HASH_ROUNDS` validation (e.g., 4-31) into `Settings` to prevent accidental mis-configuration.
# The in-memory `RateLimiter` will not work across multiple processes/instances; note this clearly or guard against multi-instance deployment.


## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.
2025-08-08 05:46:26,087 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:46:26,087 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:47:02.512 [error] 2025-08-08 05:47:02,511 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:47:02.512 [error] 2025-08-08 05:47:02,511 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:47:02.513 [error] 2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Response length: 21855 characters
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5791, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=7487, output_tokens_details=OutputTokensDetails(reasoning_tokens=2560), total_tokens=13278)
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Timestamp: 1754646422.5134897

2025-08-08 05:47:02.513 [error] 2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Response length: 21855 characters
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5791, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=7487, output_tokens_details=OutputTokensDetails(reasoning_tokens=2560), total_tokens=13278)
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:47:02,513 [DEBUG] ConsultAgent: Timestamp: 1754646422.5134897

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Prompt tokens: 5757
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Response tokens: 4898
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Total tokens: 10655
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5757, 'response_tokens': 4898, 'total_tokens': 10655, 'model': 'gpt-5-nano'}
2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: ConsultAgent iteration 3 output length: 21855 characters
2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Thread-safe in-process rate limiter (note: not shared across processes)
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure with security-focused defaults
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the RateLimiter with a distributed store (e.g., Redis).
- In production, load secrets from environment variables and secret managers.
- This module is self-contained and aims for production-readiness with defensive patterns.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """
        Ensure bcrypt salt rounds stay within reasonable bounds to balance security and performance.
        """
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"  # will be overridden by startup with set_jwt_secret
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for basic deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    """
    Register security headers middleware on FastAPI app.
    """
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; script-src 'self'; object-src 'none';"
        )
        return response

def _build_app_wrapper() -> FastAPI:
    """
    Build the base FastAPI app with CORS and core configuration.
    Note: Security headers are registered in create_app to avoid duplicate wrapping.
    """
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    settings = get_settings()

    @app.on_event("startup")
    def _startup():
        """
        Initialize database, secret key, and per-instance state once per app lifecycle.
        """
        if not hasattr(app.state, "_db_initialized") or not app.state._db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            # Rate limiter per app instance
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            app.state._db_initialized = True
            logger.info("Auth DB initialized and JWT secret configured.")
        else:
            # Already initialized in this process
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # Fallback: create a local limiter (in case startup order differs)
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton
    app = _build_app_wrapper()

    # Security headers (registered exactly once)
    _setup_security_headers(app)

    app.include_router(router)

    # Attach startup events to initialize DB and secret lazily
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False  # internal flag if needed

    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    # Ensure logging configuration
    _configure_logging(settings.LOG_LEVEL)

    return app

def _configure_logging(level_str: str) -> None:
    """
    Configure logging level from string to Python's logging level.
    """
    level = getattr(logging, level_str.upper(), logging.INFO)
    logging.basicConfig(
        level=level,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    )

# Build a default app instance for production-like usage (uvicorn module:app)
# Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide coverage for endpoints and basic rate limiting.
# Run with pytest to validate behavior.

import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
[STOP]

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Prompt tokens: 5757
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Response tokens: 4898
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Total tokens: 10655
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5757, 'response_tokens': 4898, 'total_tokens': 10655, 'model': 'gpt-5-nano'}
2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: ConsultAgent iteration 3 output length: 21855 characters
2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Thread-safe in-process rate limiter (note: not shared across processes)
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure with security-focused defaults
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the RateLimiter with a distributed store (e.g., Redis).
- In production, load secrets from environment variables and secret managers.
- This module is self-contained and aims for production-readiness with defensive patterns.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """
        Ensure bcrypt salt rounds stay within reasonable bounds to balance security and performance.
        """
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"  # will be overridden by startup with set_jwt_secret
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for basic deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    """
    Register security headers middleware on FastAPI app.
    """
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; script-src 'self'; object-src 'none';"
        )
        return response

def _build_app_wrapper() -> FastAPI:
    """
    Build the base FastAPI app with CORS and core configuration.
    Note: Security headers are registered in create_app to avoid duplicate wrapping.
    """
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    settings = get_settings()

    @app.on_event("startup")
    def _startup():
        """
        Initialize database, secret key, and per-instance state once per app lifecycle.
        """
        if not hasattr(app.state, "_db_initialized") or not app.state._db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            # Rate limiter per app instance
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            app.state._db_initialized = True
            logger.info("Auth DB initialized and JWT secret configured.")
        else:
            # Already initialized in this process
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # Fallback: create a local limiter (in case startup order differs)
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton
    app = _build_app_wrapper()

    # Security headers (registered exactly once)
    _setup_security_headers(app)

    app.include_router(router)

    # Attach startup events to initialize DB and secret lazily
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False  # internal flag if needed

    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    # Ensure logging configuration
    _configure_logging(settings.LOG_LEVEL)

    return app

def _configure_logging(level_str: str) -> None:
    """
    Configure logging level from string to Python's logging level.
    """
    level = getattr(logging, level_str.upper(), logging.INFO)
    logging.basicConfig(
        level=level,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    )

# Build a default app instance for production-like usage (uvicorn module:app)
# Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide coverage for endpoints and basic rate limiting.
# Run with pytest to validate behavior.

import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
[STOP]

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:47:02,519 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Running critic review for iteration 3
2025-08-08 05:47:02,519 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:47:02,519 [DEBUG] Critic: Model: o3
2025-08-08 05:47:02,519 [DEBUG] Critic: Review prompt length: 25069 characters
2025-08-08 05:47:02,519 [DEBUG] Critic: Response to review length: 21855 characters
2025-08-08 05:47:02,519 [DEBUG] Critic: Artifact type: code
2025-08-08 05:47:02,519 [DEBUG] Critic: Timestamp: 1754646422.5195944

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:47:02,519 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:47:02,519 [INFO] ConsultAgent: Running critic review for iteration 3
2025-08-08 05:47:02,519 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:47:02,519 [DEBUG] Critic: Model: o3
2025-08-08 05:47:02,519 [DEBUG] Critic: Review prompt length: 25069 characters
2025-08-08 05:47:02,519 [DEBUG] Critic: Response to review length: 21855 characters
2025-08-08 05:47:02,519 [DEBUG] Critic: Artifact type: code
2025-08-08 05:47:02,519 [DEBUG] Critic: Timestamp: 1754646422.5195944

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:47:02,519 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request: Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Thread-safe in-process rate limiter (note: not shared across processes)
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure with security-focused defaults
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the RateLimiter with a distributed store (e.g., Redis).
- In production, load secrets from environment variables and secret managers.
- This module is self-contained and aims for production-readiness with defensive patterns.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """
        Ensure bcrypt salt rounds stay within reasonable bounds to balance security and performance.
        """
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"  # will be overridden by startup with set_jwt_secret
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for basic deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    """
    Register security headers middleware on FastAPI app.
    """
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; script-src 'self'; object-src 'none';"
        )
        return response

def _build_app_wrapper() -> FastAPI:
    """
    Build the base FastAPI app with CORS and core configuration.
    Note: Security headers are registered in create_app to avoid duplicate wrapping.
    """
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    settings = get_settings()

    @app.on_event("startup")
    def _startup():
        """
        Initialize database, secret key, and per-instance state once per app lifecycle.
        """
        if not hasattr(app.state, "_db_initialized") or not app.state._db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            # Rate limiter per app instance
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            app.state._db_initialized = True
            logger.info("Auth DB initialized and JWT secret configured.")
        else:
            # Already initialized in this process
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # Fallback: create a local limiter (in case startup order differs)
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton
    app = _build_app_wrapper()

    # Security headers (registered exactly once)
    _setup_security_headers(app)

    app.include_router(router)

    # Attach startup events to initialize DB and secret lazily
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False  # internal flag if needed

    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    # Ensure logging configuration
    _configure_logging(settings.LOG_LEVEL)

    return app

def _configure_logging(level_str: str) -> None:
    """
    Configure logging level from string to Python's logging level.
    """
    level = getattr(logging, level_str.upper(), logging.INFO)
    logging.basicConfig(
        level=level,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    )

# Build a default app instance for production-like usage (uvicorn module:app)
# Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide coverage for endpoints and basic rate limiting.
# Run with pytest to validate behavior.

import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
[STOP]

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:47:02,519 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:47:02.519 [error] 2025-08-08 05:47:02,519 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:47:02,519 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request: Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice - production-ready FastAPI backend

Features:
- REST API for user registration, login, and token refresh
- JWT-based authentication with access/refresh tokens and rotation
- Password hashing with bcrypt (salt rounds configurable)
- SQLite (SQLAlchemy ORM) with a robust User model
- Pydantic input validation
- Thread-safe in-process rate limiter (note: not shared across processes)
- Logging with audit trails and defensive error handling
- Health check endpoint for monitoring
- Docker-ready structure with security-focused defaults
- Unit tests with pytest covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the RateLimiter with a distributed store (e.g., Redis).
- In production, load secrets from environment variables and secret managers.
- This module is self-contained and aims for production-readiness with defensive patterns.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Dict, Tuple

# ---------------------------
# Dependencies
# ---------------------------

import bcrypt
import jwt as pyjwt  # PyJWT
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Settings and Configuration
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """
        Ensure bcrypt salt rounds stay within reasonable bounds to balance security and performance.
        """
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """
    Load application settings from environment variables or defaults.
    """
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()
_engine = None  # type: Optional[object]
_SessionLocal = None  # type: Optional[sessionmaker]

def init_db(database_url: str) -> None:
    """
    Initialize the database engine and session factory.
    Creates tables if they do not exist yet.
    """
    global _engine, _SessionLocal
    _engine = create_engine(database_url, connect_args={"check_same_thread": False})
    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)
    Base.metadata.create_all(_engine)

def get_session() -> Generator[Session, None, None]:
    """
    Dependency to provide a SQLAlchemy session to API endpoints.
    """
    if _SessionLocal is None:
        raise RuntimeError("Database not initialized. Call init_db() first.")
    db = _SessionLocal()
    try:
        yield db
    finally:
        db.close()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

# JWT state (passwords secret)
_SECRET_KEY: str = "CHANGE_ME_SECRET"  # will be overridden by startup with set_jwt_secret
_ALGORITHM: str = "HS256"

def set_jwt_secret(key: str) -> None:
    """
    Initialize the secret key for JWT encoding/decoding.
    """
    global _SECRET_KEY
    _SECRET_KEY = key

def _encode_token(payload: dict) -> str:
    """
    Encode a JWT with the configured algorithm.
    """
    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)
    if isinstance(token, bytes):
        token = token.decode("utf-8")
    return token

def _decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload.
    """
    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])

def _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:
    exp = datetime.utcnow() + expires_delta
    payload = {"sub": str(user_id), "type": token_type, "exp": exp}
    return _encode_token(payload)

def create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a short-lived access token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "access")

def create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:
    """
    Create a long-lived refresh token for a user.
    """
    settings = get_settings()
    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES
    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")

def decode_token(token: str) -> dict:
    """
    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.
    """
    try:
        return _decode_token(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    """
    Extract user_id from a decoded payload. Returns -1 if invalid.
    """
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    """
    Hash a plain password using bcrypt with the specified rounds.
    """
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Verify a plain password against the stored bcrypt hash.
    """
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Rate Limiter (Thread-safe)
# ---------------------------

class RateLimiter:
    """
    Simple in-process rate limiter with a fixed window.
    Thread-safe for basic deployments. For multi-process deployments, replace with Redis.
    """
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._lock = threading.Lock()
        self._clients: Dict[str, Tuple[int, float]] = {}

    def is_allowed(self, key: str) -> bool:
        """
        Check if a given key is allowed under the rate limit.
        """
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # New window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])
logger = logging.getLogger("auth")

def _setup_security_headers(app: FastAPI) -> None:
    """
    Register security headers middleware on FastAPI app.
    """
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; script-src 'self'; object-src 'none';"
        )
        return response

def _build_app_wrapper() -> FastAPI:
    """
    Build the base FastAPI app with CORS and core configuration.
    Note: Security headers are registered in create_app to avoid duplicate wrapping.
    """
    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")

    # CORS (adjust in production)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

def _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:
    settings = get_settings()

    @app.on_event("startup")
    def _startup():
        """
        Initialize database, secret key, and per-instance state once per app lifecycle.
        """
        if not hasattr(app.state, "_db_initialized") or not app.state._db_initialized:
            init_db(db_url)
            set_jwt_secret(jwt_secret)
            # Rate limiter per app instance
            app.state.rate_limiter = RateLimiter(
                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                max_requests=settings.RATE_LIMIT_LOGIN,
            )
            app.state._db_initialized = True
            logger.info("Auth DB initialized and JWT secret configured.")
        else:
            # Already initialized in this process
            pass

# Dependency to ensure a session is ready
def _ensure_session() -> Generator[Session, None, None]:
    yield from get_session()

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Register a new user and return access/refresh tokens.
    """
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)
    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:
    """
    Authenticate user and return JWT tokens.
    Apply rate limiting to protect against brute force attempts.
    """
    if request is None:
        raise HTTPException(status_code=500, detail="Internal server error: missing request context")

    client_host = request.client.host if request.client else "unknown"

    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)
    if rate_limiter is None:
        # Fallback: create a local limiter (in case startup order differs)
        settings = get_settings()
        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
                                   max_requests=settings.RATE_LIMIT_LOGIN)

    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == user_in.email).first()
    if user is None or not verify_password(user_in.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={user_in.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"User login success: user_id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:
    """
    Refresh the access token using a valid refresh token.
    """
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    # Rotate tokens for security
    settings = get_settings()
    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# App Factory
# ---------------------------

def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """
    Factory to create a FastAPI app instance with a configured database and JWT secret.
    """
    settings = get_settings()

    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Build app skeleton
    app = _build_app_wrapper()

    # Security headers (registered exactly once)
    _setup_security_headers(app)

    app.include_router(router)

    # Attach startup events to initialize DB and secret lazily
    app.state._db_url = db_url
    app.state._jwt_secret = jwt_key
    app.state.db_initialized = False  # internal flag if needed

    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)

    # Health endpoint
    @app.get("/health")
    def health():
        return _health_body()

    # Ensure logging configuration
    _configure_logging(settings.LOG_LEVEL)

    return app

def _configure_logging(level_str: str) -> None:
    """
    Configure logging level from string to Python's logging level.
    """
    level = getattr(logging, level_str.upper(), logging.INFO)
    logging.basicConfig(
        level=level,
        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    )

# Build a default app instance for production-like usage (uvicorn module:app)
# Tests should call create_app(...) to spin up isolated apps.
app = create_app()

# ---------------------------
# Minimal Docker-ready Dockerfile hint (in code comments)
# ---------------------------
# To Dockerize:
# 1) Create a Dockerfile at repo root (example):
#    FROM python:3.11-slim
#    WORKDIR /app
#    ENV PYTHONDONTWRITEBYTECODE=1
#    ENV PYTHONUNBUFFERED=1
#    COPY requirements.txt .
#    RUN pip install --no-cache-dir -r requirements.txt
#    COPY . .
#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]
# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.
# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide coverage for endpoints and basic rate limiting.
# Run with pytest to validate behavior.

import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

# Re-export a helper for tests: create isolated app instances per test.
TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    # Use the default event loop for pytest-asyncio compatibility
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """
    Create a fresh app instance for a test session with its own test DB.
    """
    # Ensure a clean test DB
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_and_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """
    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.
    """
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        # Wrong password attempts to trigger rate limit
        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401 (invalid credentials) but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# End of embedded tests

# If this module is run directly, start the app (useful for quick manual testing)
if __name__ == "__main__":
    import uvicorn
    # Use production-ready defaults, can override via environment variables
    uvicorn.run(app, host="0.0.0.0", port=8000)
```
[STOP]

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:47:02,519 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:47:53.300 [error] 2025-08-08 05:47:53,299 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:47:53.300 [error] 2025-08-08 05:47:53,299 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:47:53.300 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:47:53.300 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:47:53.300 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: Response length: 560 characters
2025-08-08 05:47:53,300 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:47:53,300 [DEBUG] Critic: Has error: False
2025-08-08 05:47:53,300 [DEBUG] Critic: Timestamp: 1754646473.3007784
2025-08-08 05:47:53,300 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:47:53,300 [DEBUG] Critic: ### VERDICT
PASS

### FEEDBACK
Response passes review ‚Äì implementation satisfies requested functionality without critical flaws.

### CRITICAL ISSUES
-

### SUGGESTIONS
- `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.
- Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.
- Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.
2025-08-08 05:47:53,300 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:47:53.300 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: Response length: 560 characters
2025-08-08 05:47:53,300 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:47:53,300 [DEBUG] Critic: Has error: False
2025-08-08 05:47:53,300 [DEBUG] Critic: Timestamp: 1754646473.3007784
2025-08-08 05:47:53,300 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:47:53,300 [DEBUG] Critic: ### VERDICT
PASS

### FEEDBACK
Response passes review ‚Äì implementation satisfies requested functionality without critical flaws.

### CRITICAL ISSUES
-

### SUGGESTIONS
- `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.
- Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.
- Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.
2025-08-08 05:47:53,300 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: === CRITIC RESULT PARSED ===

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: === CRITIC RESULT PARSED ===

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: Passed: True

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,300 [DEBUG] Critic: Passed: True

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] Critic: Feedback: Response passes review ‚Äì implementation satisfies requested functionality without critical flaws.

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] Critic: Feedback: Response passes review ‚Äì implementation satisfies requested functionality without critical flaws.

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] Critic: Critical issues count: 0
2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestions count: 3

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] Critic: Critical issues count: 0
2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestions count: 3

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestion 1: `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.
2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestion 2: Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.
2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestion 3: Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.
2025-08-08 05:47:53,301 [DEBUG] Critic: Timestamp: 1754646473.3011997
2025-08-08 05:47:53,301 [INFO] Critic: Critic review result: PASSED

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestion 1: `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.
2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestion 2: Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.
2025-08-08 05:47:53,301 [DEBUG] Critic: Suggestion 3: Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.
2025-08-08 05:47:53,301 [DEBUG] Critic: Timestamp: 1754646473.3011997
2025-08-08 05:47:53,301 [INFO] Critic: Critic review result: PASSED

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Passed: True
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Feedback: Response passes review ‚Äì implementation satisfies requested functionality without critical flaws.
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Critical issues count: 0

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Passed: True
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Feedback: Response passes review ‚Äì implementation satisfies requested functionality without critical flaws.
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Critical issues count: 0

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestions count: 3
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestion 1: `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestion 2: Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestions count: 3
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestion 1: `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestion 2: Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestion 3: Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Timestamp: 1754646473.3013644
2025-08-08 05:47:53,301 [INFO] ConsultAgent: Critic review: PASSED

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Suggestion 3: Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.
2025-08-08 05:47:53,301 [DEBUG] ConsultAgent: Timestamp: 1754646473.3013644
2025-08-08 05:47:53,301 [INFO] ConsultAgent: Critic review: PASSED

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [INFO] ConsultAgent: Critic passed with 3 suggestions

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [INFO] ConsultAgent: Critic passed with 3 suggestions

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [INFO] ConsultAgent: STOP signal detected at iteration 3

2025-08-08 05:47:53.301 [error] 2025-08-08 05:47:53,301 [INFO] ConsultAgent: STOP signal detected at iteration 3

2025-08-08 05:47:53.312 [info] Successfully called tool 'consult'
2025-08-08 05:47:53.313 [error] 2025-08-08 05:47:53,312 [INFO] mcp.server.lowlevel.server: Processing request of type CallToolRequest

2025-08-08 05:47:53.313 [error] 2025-08-08 05:47:53,312 [INFO] mcp.server.lowlevel.server: Processing request of type CallToolRequest

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] accf.shared.mcp.mcp_server_template: Tool call requested: consult with arguments: {'prompt': 'Create a production-ready microservice for user authentication with the following requirements:\n\n1. REST API with FastAPI for user registration, login, and token refresh\n2. JWT token authentication with proper expiration and refresh logic\n3. Password hashing using bcrypt with salt rounds\n4. SQLite database with SQLAlchemy ORM for user storage\n5. Input validation using Pydantic models\n6. Rate limiting to prevent brute force attacks\n7. Logging with proper error handling and audit trails\n8. Health check endpoint for monitoring\n9. Docker containerization with proper security practices\n10. Unit tests with pytest covering all endpoints\n\nThe service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.', 'session_id': 'baseline_test_001', 'artifact_type': 'code', 'iterate': 3, 'critic_enabled': True, 'model': 'gpt-5-nano', 'auto_attach_project_intelligence': False, 'response_format': 'json'}

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] accf.shared.mcp.mcp_server_template: Tool call requested: consult with arguments: {'prompt': 'Create a production-ready microservice for user authentication with the following requirements:\n\n1. REST API with FastAPI for user registration, login, and token refresh\n2. JWT token authentication with proper expiration and refresh logic\n3. Password hashing using bcrypt with salt rounds\n4. SQLite database with SQLAlchemy ORM for user storage\n5. Input validation using Pydantic models\n6. Rate limiting to prevent brute force attacks\n7. Logging with proper error handling and audit trails\n8. Health check endpoint for monitoring\n9. Docker containerization with proper security practices\n10. Unit tests with pytest covering all endpoints\n\nThe service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.', 'session_id': 'baseline_test_001', 'artifact_type': 'code', 'iterate': 3, 'critic_enabled': True, 'model': 'gpt-5-nano', 'auto_attach_project_intelligence': False, 'response_format': 'json'}

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] __main__: All parameters explicitly provided by user

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] __main__: All parameters explicitly provided by user

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] ConsultAgent: Using user-specified model: gpt-5-nano

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] ConsultAgent: Using user-specified model: gpt-5-nano

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] ConsultAgent: === CRITIC INITIALIZATION START ===
2025-08-08 05:47:53,316 [DEBUG] ConsultAgent: Current working directory: /home/opsvi/master_root

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [INFO] ConsultAgent: === CRITIC INITIALIZATION START ===
2025-08-08 05:47:53,316 [DEBUG] ConsultAgent: Current working directory: /home/opsvi/master_root

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [DEBUG] ConsultAgent: Python path: ['/home/opsvi/master_root', '/home/opsvi/ACCF/src', '/home/opsvi/miniconda/lib/python312.zip', '/home/opsvi/miniconda/lib/python3.12', '/home/opsvi/miniconda/lib/python3.12/lib-dynload', '/home/opsvi/.local/lib/python3.12/site-packages', '/home/opsvi/miniconda/lib/python3.12/site-packages', '/home/opsvi/agent_world/src', '/home/opsvi/asea/asea_orchestrator/src', '/home/opsvi/genFileMap/src', '/home/opsvi/master_root/apps/proj-mapper/src', '/home/opsvi/master/projects/nested-workflow-architecture/mcp-servers/mcp-atlassian/src', '/home/opsvi/project-intelligence/src']
2025-08-08 05:47:53,316 [DEBUG] ConsultAgent: Current file location: /home/opsvi/ACCF/src/accf/agents/consult_agent_comprehensive.py

2025-08-08 05:47:53.316 [error] 2025-08-08 05:47:53,316 [DEBUG] ConsultAgent: Python path: ['/home/opsvi/master_root', '/home/opsvi/ACCF/src', '/home/opsvi/miniconda/lib/python312.zip', '/home/opsvi/miniconda/lib/python3.12', '/home/opsvi/miniconda/lib/python3.12/lib-dynload', '/home/opsvi/.local/lib/python3.12/site-packages', '/home/opsvi/miniconda/lib/python3.12/site-packages', '/home/opsvi/agent_world/src', '/home/opsvi/asea/asea_orchestrator/src', '/home/opsvi/genFileMap/src', '/home/opsvi/master_root/apps/proj-mapper/src', '/home/opsvi/master/projects/nested-workflow-architecture/mcp-servers/mcp-atlassian/src', '/home/opsvi/project-intelligence/src']
2025-08-08 05:47:53,316 [DEBUG] ConsultAgent: Current file location: /home/opsvi/ACCF/src/accf/agents/consult_agent_comprehensive.py

2025-08-08 05:47:53.339 [error] 2025-08-08 05:47:53,338 [INFO] Critic: === CRITIC AGENT INITIALIZED WITH DEBUG LOGGING ===
2025-08-08 05:47:53,338 [INFO] Critic: CriticAgent initialized with model: o3

2025-08-08 05:47:53.339 [error] 2025-08-08 05:47:53,338 [INFO] Critic: === CRITIC AGENT INITIALIZED WITH DEBUG LOGGING ===
2025-08-08 05:47:53,338 [INFO] Critic: CriticAgent initialized with model: o3

2025-08-08 05:47:53.339 [error] 2025-08-08 05:47:53,338 [INFO] ConsultAgent: Critic agent enabled for quality control (relative import)
2025-08-08 05:47:53,338 [INFO] ConsultAgent: === CRITIC INITIALIZATION END - Agent exists: True ===

2025-08-08 05:47:53.339 [error] 2025-08-08 05:47:53,338 [INFO] ConsultAgent: Critic agent enabled for quality control (relative import)
2025-08-08 05:47:53,338 [INFO] ConsultAgent: === CRITIC INITIALIZATION END - Agent exists: True ===

2025-08-08 05:47:53.382 [error] 2025-08-08 05:47:53,382 [INFO] ConsultAgent: Starting iteration 1/3

2025-08-08 05:47:53.382 [error] 2025-08-08 05:47:53,382 [INFO] ConsultAgent: Starting iteration 1/3

2025-08-08 05:47:53.383 [error] 2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: === API CALL START ===
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Prompt length: 28295 characters
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Context:
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Timestamp: 1754646473.3825653
2025-08-08 05:47:53,382 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:47:53,382 [INFO] ConsultAgent: Prompt length: 28295 characters
2025-08-08 05:47:53,382 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:47:53,382 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:47:53,382 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## RESPONSE DECISION INSTRUCTIONS
After analyzing the request, you MUST decide whether to provide a direct response or ask for more information.

**RESPONSE TYPES:**
- **FINAL**: Provide complete response (use when you have sufficient information)
- **QUESTIONS**: Ask clarifying questions (use when missing critical information)
- **CONCERNS**: Flag potential issues (use when you have concerns about the approach)
- **CLARIFICATION**: Request specific details (use when request is unclear)

**DECISION CRITERIA:**
- If the request is clear, complete, and you have sufficient context ‚Üí Use **FINAL**
- If missing critical information needed for a good response ‚Üí Use **QUESTIONS**
- If you have concerns about the approach or potential issues ‚Üí Use **CONCERNS**
- If the request is unclear or ambiguous ‚Üí Use **CLARIFICATION**

**RESPONSE FORMAT:**
Start your response with the response type tag:

**FINAL:**
[Your complete response here]

**QUESTIONS:**
1. [Question 1]
2. [Question 2]
...

**CONCERNS:**
‚ö†Ô∏è [Concern 1]
‚ö†Ô∏è [Concern 2]
[Questions to address concerns]

**CLARIFICATION:**
[What specifically needs to be clarified]

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate

## REFERENCE INFORMATION (NOT THE REQUEST)
*** FOR CONTEXT ONLY - DO NOT TREAT AS THE ACTUAL REQUEST ***

### PROJECT CONTEXT


### CONVERSATION HISTORY
['Previous conversation context:', 'Q: Create a production-ready microservice for user authentication with the following requirements:\n\n1. REST API with FastAPI for user registration, login, and token refresh\n2. JWT token authentication with proper expiration and refresh logic\n3. Password hashing using bcrypt with salt rounds\n4. SQLite database with SQLAlchemy ORM for user storage\n5. Input validation using Pydantic models\n6. Rate limiting to prevent brute force attacks\n7. Logging with proper error handling and audit trails\n8. Health check endpoint for monitoring\n9. Docker containerization with proper security practices\n10. Unit tests with pytest covering all endpoints\n\nThe service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.', 'A: ```python\n#!/usr/bin/env python3\n"""\nAuth Microservice - production-ready FastAPI backend\n\nFeatures:\n- REST API for user registration, login, and token refresh\n- JWT-based authentication with access/refresh tokens and rotation\n- Password hashing with bcrypt (salt rounds configurable)\n- SQLite (SQLAlchemy ORM) with a robust User model\n- Pydantic input validation\n- Thread-safe in-process rate limiter (note: not shared across processes)\n- Logging with audit trails and defensive error handling\n- Health check endpoint for monitoring\n- Docker-ready structure with security-focused defaults\n- Unit tests with pytest covering endpoints (embedded in this file for convenience)\n\nNotes:\n- For multi-instance deployments, replace the RateLimiter with a distributed store (e.g., Redis).\n- In production, load secrets from environment variables and secret managers.\n- This module is self-contained and aims for production-readiness with defensive patterns.\n"""\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport threading\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Generator, Optional, Dict, Tuple\n\n# ---------------------------\n# Dependencies\n# ---------------------------\n\nimport bcrypt\nimport jwt as pyjwt  # PyJWT\nfrom fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, EmailStr, constr, BaseSettings, validator\nfrom sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session, declarative_base, sessionmaker\n\n# ---------------------------\n# Settings and Configuration\n# ---------------------------\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str = "sqlite:///./auth.db"\n    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"\n    JWT_ALGORITHM: str = "HS256"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15\n    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days\n    HASH_ROUNDS: int = 12\n    LOG_LEVEL: str = "INFO"\n    RATE_LIMIT_LOGIN: int = 5\n    RATE_LIMIT_WINDOW_SECONDS: int = 60\n    APP_NAME: str = "Auth Microservice"\n\n    class Config:\n        env_file = ".env"\n\n    @validator("HASH_ROUNDS")\n    def validate_hash_rounds(cls, v: int) -> int:\n        """\n        Ensure bcrypt salt rounds stay within reasonable bounds to balance security and performance.\n        """\n        if not (4 <= v <= 31):\n            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")\n        return v\n\ndef get_settings() -> Settings:\n    """\n    Load application settings from environment variables or defaults.\n    """\n    return Settings()\n\n# ---------------------------\n# Database (SQLAlchemy)\n# ---------------------------\n\nBase = declarative_base()\n_engine = None  # type: Optional[object]\n_SessionLocal = None  # type: Optional[sessionmaker]\n\ndef init_db(database_url: str) -> None:\n    """\n    Initialize the database engine and session factory.\n    Creates tables if they do not exist yet.\n    """\n    global _engine, _SessionLocal\n    _engine = create_engine(database_url, connect_args={"check_same_thread": False})\n    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)\n    Base.metadata.create_all(_engine)\n\ndef get_session() -> Generator[Session, None, None]:\n    """\n    Dependency to provide a SQLAlchemy session to API endpoints.\n    """\n    if _SessionLocal is None:\n        raise RuntimeError("Database not initialized. Call init_db() first.")\n    db = _SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\nclass User(Base):\n    __tablename__ = "users"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, nullable=False, index=True)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    last_login = Column(DateTime, nullable=True)\n\n    def __repr__(self) -> str:\n        return f"<User id={self.id} email={self.email}>"\n\n# ---------------------------\n# Security (JWT & Passwords)\n# ---------------------------\n\n# JWT state (passwords secret)\n_SECRET_KEY: str = "CHANGE_ME_SECRET"  # will be overridden by startup with set_jwt_secret\n_ALGORITHM: str = "HS256"\n\ndef set_jwt_secret(key: str) -> None:\n    """\n    Initialize the secret key for JWT encoding/decoding.\n    """\n    global _SECRET_KEY\n    _SECRET_KEY = key\n\ndef _encode_token(payload: dict) -> str:\n    """\n    Encode a JWT with the configured algorithm.\n    """\n    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)\n    if isinstance(token, bytes):\n        token = token.decode("utf-8")\n    return token\n\ndef _decode_token(token: str) -> dict:\n    """\n    Decode a JWT and return its payload.\n    """\n    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])\n\ndef _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:\n    exp = datetime.utcnow() + expires_delta\n    payload = {"sub": str(user_id), "type": token_type, "exp": exp}\n    return _encode_token(payload)\n\ndef create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:\n    """\n    Create a short-lived access token for a user.\n    """\n    settings = get_settings()\n    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES\n    return _build_token(user_id, timedelta(minutes=exp_min), "access")\n\ndef create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:\n    """\n    Create a long-lived refresh token for a user.\n    """\n    settings = get_settings()\n    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES\n    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")\n\ndef decode_token(token: str) -> dict:\n    """\n    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.\n    """\n    try:\n        return _decode_token(token)\n    except pyjwt.ExpiredSignatureError:\n        raise ValueError("Token has expired")\n    except pyjwt.InvalidTokenError:\n        raise ValueError("Invalid token")\n\ndef extract_user_id_from_payload(payload: dict) -> int:\n    """\n    Extract user_id from a decoded payload. Returns -1 if invalid.\n    """\n    sub = payload.get("sub")\n    ttype = payload.get("type")\n    if not sub or not ttype:\n        return -1\n    try:\n        return int(sub)\n    except ValueError:\n        return -1\n\ndef hash_password(plain_password: str, rounds: int) -> str:\n    """\n    Hash a plain password using bcrypt with the specified rounds.\n    """\n    salt = bcrypt.gensalt(rounds)\n    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)\n    return hashed.decode("utf-8")\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    """\n    Verify a plain password against the stored bcrypt hash.\n    """\n    try:\n        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))\n    except Exception:\n        return False\n\n# ---------------------------\n# Rate Limiter (Thread-safe)\n# ---------------------------\n\nclass RateLimiter:\n    """\n    Simple in-process rate limiter with a fixed window.\n    Thread-safe for basic deployments. For multi-process deployments, replace with Redis.\n    """\n    def __init__(self, window_seconds: int, max_requests: int) -> None:\n        self.window = window_seconds\n        self.max = max_requests\n        self._lock = threading.Lock()\n        self._clients: Dict[str, Tuple[int, float]] = {}\n\n    def is_allowed(self, key: str) -> bool:\n        """\n        Check if a given key is allowed under the rate limit.\n        """\n        with self._lock:\n            now = time.time()\n            count, window_start = self._clients.get(key, (0, now))\n            if now - window_start > self.window:\n                # New window\n                self._clients[key] = (1, now)\n                return True\n            else:\n                if count < self.max:\n                    self._clients[key] = (count + 1, window_start)\n                    return True\n                else:\n                    return False\n\n# ---------------------------\n# Pydantic Schemas\n# ---------------------------\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: constr(min_length=8, max_length=128)\n\nclass UserLogin(BaseModel):\n    email: EmailStr\n    password: constr(min_length=8, max_length=128)\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    refresh_token: Optional[str] = None\n    token_type: str = "bearer"\n\nclass TokenRefresh(BaseModel):\n    refresh_token: str\n\nclass UserOut(BaseModel):\n    id: int\n    email: EmailStr\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n\n# ---------------------------\n# FastAPI App & Routes\n# ---------------------------\n\nrouter = APIRouter(prefix="/auth", tags=["auth"])\nlogger = logging.getLogger("auth")\n\ndef _setup_security_headers(app: FastAPI) -> None:\n    """\n    Register security headers middleware on FastAPI app.\n    """\n    @app.middleware("http")\n    async def _security_headers(request: Request, call_next):\n        response: Response = await call_next(request)\n        response.headers["X-Content-Type-Options"] = "nosniff"\n        response.headers["X-Frame-Options"] = "DENY"\n        response.headers["X-XSS-Protection"] = "1; mode=block"\n        response.headers["Content-Security-Policy"] = (\n            "default-src \'self\'; script-src \'self\'; object-src \'none\';"\n        )\n        return response\n\ndef _build_app_wrapper() -> FastAPI:\n    """\n    Build the base FastAPI app with CORS and core configuration.\n    Note: Security headers are registered in create_app to avoid duplicate wrapping.\n    """\n    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")\n\n    # CORS (adjust in production)\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=["*"],\n        allow_credentials=True,\n        allow_methods=["*"],\n        allow_headers=["*"],\n    )\n\n    return app\n\ndef _health_body() -> dict:\n    return {\n        "status": "healthy",\n        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),\n    }\n\ndef _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:\n    settings = get_settings()\n\n    @app.on_event("startup")\n    def _startup():\n        """\n        Initialize database, secret key, and per-instance state once per app lifecycle.\n        """\n        if not hasattr(app.state, "_db_initialized") or not app.state._db_initialized:\n            init_db(db_url)\n            set_jwt_secret(jwt_secret)\n            # Rate limiter per app instance\n            app.state.rate_limiter = RateLimiter(\n                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,\n                max_requests=settings.RATE_LIMIT_LOGIN,\n            )\n            app.state._db_initialized = True\n            logger.info("Auth DB initialized and JWT secret configured.")\n        else:\n            # Already initialized in this process\n            pass\n\n# Dependency to ensure a session is ready\ndef _ensure_session() -> Generator[Session, None, None]:\n    yield from get_session()\n\n@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)\ndef register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:\n    """\n    Register a new user and return access/refresh tokens.\n    """\n    if not user_in.email or not user_in.password:\n        raise HTTPException(status_code=400, detail="Email and password are required")\n\n    user = db.query(User).filter(User.email == user_in.email).first()\n    if user:\n        raise HTTPException(status_code=400, detail="Email already registered")\n\n    settings = get_settings()\n    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)\n    new_user = User(email=user_in.email, hashed_password=hashed)\n    db.add(new_user)\n    try:\n        db.commit()\n    except IntegrityError:\n        db.rollback()\n        raise HTTPException(status_code=400, detail="Email already registered")\n    db.refresh(new_user)\n\n    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")\n    return TokenResponse(access_token=access_token, refresh_token=refresh_token)\n\n@router.post("/login", response_model=TokenResponse)\ndef login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:\n    """\n    Authenticate user and return JWT tokens.\n    Apply rate limiting to protect against brute force attempts.\n    """\n    if request is None:\n        raise HTTPException(status_code=500, detail="Internal server error: missing request context")\n\n    client_host = request.client.host if request.client else "unknown"\n\n    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)\n    if rate_limiter is None:\n        # Fallback: create a local limiter (in case startup order differs)\n        settings = get_settings()\n        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,\n                                   max_requests=settings.RATE_LIMIT_LOGIN)\n\n    if not rate_limiter.is_allowed(f"{client_host}:login"):\n        logger.warning(f"Rate limit exceeded for {client_host}")\n        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")\n\n    user = db.query(User).filter(User.email == user_in.email).first()\n    if user is None or not verify_password(user_in.password, user.hashed_password):\n        logger.warning(f"Invalid login attempt for email={user_in.email}")\n        raise HTTPException(status_code=401, detail="Invalid credentials")\n\n    user.last_login = datetime.utcnow()\n    try:\n        db.commit()\n    except Exception as e:\n        db.rollback()\n        logger.exception("Failed to update last_login on login: %s", e)\n\n    settings = get_settings()\n    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    logger.info(f"User login success: user_id={user.id}, email={user.email}")\n    return TokenResponse(access_token=access_token, refresh_token=refresh_token)\n\n@router.post("/token/refresh", response_model=TokenResponse)\ndef token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:\n    """\n    Refresh the access token using a valid refresh token.\n    """\n    try:\n        token_payload = decode_token(payload.refresh_token)\n    except ValueError as e:\n        raise HTTPException(status_code=401, detail=str(e))\n\n    user_id = extract_user_id_from_payload(token_payload)\n    token_type = token_payload.get("type")\n\n    if user_id == -1 or token_type != "refresh":\n        raise HTTPException(status_code=401, detail="Invalid refresh token")\n\n    user = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise HTTPException(status_code=401, detail="User not found")\n\n    # Rotate tokens for security\n    settings = get_settings()\n    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    logger.info(f"Token refreshed: user_id={user_id}")\n    return TokenResponse(access_token=new_access, refresh_token=new_refresh)\n\n# ---------------------------\n# App Factory\n# ---------------------------\n\ndef create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:\n    """\n    Factory to create a FastAPI app instance with a configured database and JWT secret.\n    """\n    settings = get_settings()\n\n    db_url = database_url or settings.DATABASE_URL\n    jwt_key = jwt_secret or settings.JWT_SECRET_KEY\n\n    # Build app skeleton\n    app = _build_app_wrapper()\n\n    # Security headers (registered exactly once)\n    _setup_security_headers(app)\n\n    app.include_router(router)\n\n    # Attach startup events to initialize DB and secret lazily\n    app.state._db_url = db_url\n    app.state._jwt_secret = jwt_key\n    app.state.db_initialized = False  # internal flag if needed\n\n    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)\n\n    # Health endpoint\n    @app.get("/health")\n    def health():\n        return _health_body()\n\n    # Ensure logging configuration\n    _configure_logging(settings.LOG_LEVEL)\n\n    return app\n\ndef _configure_logging(level_str: str) -> None:\n    """\n    Configure logging level from string to Python\'s logging level.\n    """\n    level = getattr(logging, level_str.upper(), logging.INFO)\n    logging.basicConfig(\n        level=level,\n        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",\n    )\n\n# Build a default app instance for production-like usage (uvicorn module:app)\n# Tests should call create_app(...) to spin up isolated apps.\napp = create_app()\n\n# ---------------------------\n# Minimal Docker-ready Dockerfile hint (in code comments)\n# ---------------------------\n# To Dockerize:\n# 1) Create a Dockerfile at repo root (example):\n#    FROM python:3.11-slim\n#    WORKDIR /app\n#    ENV PYTHONDONTWRITEBYTECODE=1\n#    ENV PYTHONUNBUFFERED=1\n#    COPY requirements.txt .\n#    RUN pip install --no-cache-dir -r requirements.txt\n#    COPY . .\n#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]\n# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.\n# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).\n\n# ---------------------------\n# Tests (pytest-based)\n# ---------------------------\n\n# The following embedded tests provide coverage for endpoints and basic rate limiting.\n# Run with pytest to validate behavior.\n\nimport asyncio  # noqa: F401\nimport httpx  # type: ignore\nimport pytest\nfrom fastapi import FastAPI\n\n# Re-export a helper for tests: create isolated app instances per test.\nTEST_DB_PATH = "./test_auth.db"\n\n@pytest.fixture(scope="session")\ndef event_loop():\n    # Use the default event loop for pytest-asyncio compatibility\n    loop = asyncio.get_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\ndef isolation_app():\n    """\n    Create a fresh app instance for a test session with its own test DB.\n    """\n    # Ensure a clean test DB\n    if os.path.exists(TEST_DB_PATH):\n        os.remove(TEST_DB_PATH)\n    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")\n    return test_app\n\n@pytest.fixture\nasync def client(isolation_app: FastAPI):\n    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:\n        yield c\n\n@pytest.mark.asyncio\nasync def test_health_endpoint(client: httpx.AsyncClient):\n    resp = await client.get("/health")\n    assert resp.status_code == 200\n    data = resp.json()\n    assert data.get("status") == "healthy"\n\n@pytest.mark.asyncio\nasync def test_register_and_login_and_refresh(client: httpx.AsyncClient):\n    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}\n    reg_resp = await client.post("/auth/register", json=reg_payload)\n    assert reg_resp.status_code in (200, 201)\n    reg_json = reg_resp.json()\n    assert "access_token" in reg_json\n    assert "refresh_token" in reg_json\n\n    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}\n    login_resp = await client.post("/auth/login", json=login_payload)\n    assert login_resp.status_code == 200\n    login_json = login_resp.json()\n    assert "access_token" in login_json\n    assert "refresh_token" in login_json\n\n    refresh_payload = {"refresh_token": login_json["refresh_token"]}\n    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)\n    assert refresh_resp.status_code == 200\n    refresh_json = refresh_resp.json()\n    assert "access_token" in refresh_json\n    assert "refresh_token" in refresh_json\n\n@pytest.mark.asyncio\nasync def test_invalid_login(client: httpx.AsyncClient):\n    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}\n    resp = await client.post("/auth/login", json=payload)\n    assert resp.status_code == 401\n\n@pytest.mark.asyncio\nasync def test_rate_limiting_on_login():\n    """\n    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.\n    """\n    test_db = "./test_rate_limit.db"\n    if os.path.exists(test_db):\n        os.remove(test_db)\n\n    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")\n    async with httpx.AsyncClient(app=app, base_url="http://test") as client:\n        # Register a user\n        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}\n        reg = await client.post("/auth/register", json=payload)\n        assert reg.status_code in (200, 201)\n\n        # Wrong password attempts to trigger rate limit\n        wrong = {"email": "bob@example.com", "password": "WrongPass!"}\n        for i in range(6):\n            resp = await client.post("/auth/login", json=wrong)\n            if i < 5:\n                # First 5 attempts may be 401 (invalid credentials) but not yet throttled\n                assert resp.status_code in (401, 200)\n            else:\n                assert resp.status_code == 429\n\n# End of embedded tests\n\n# If this module is run directly, start the app (useful for quick manual testing)\nif __name__ == "__main__":\n    import uvicorn\n    # Use production-ready defaults, can override via environment variables\n    uvicorn.run(app, host="0.0.0.0", port=8000)\n```\n\n\n# Critic Suggestions:\n# `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.\n# Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.\n# Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.', '']

## üéØ ACTUAL USER REQUEST (THIS IS WHAT MATTERS)
*** THIS IS THE REQUEST - FOCUS ON THIS ***

Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

*** END OF REQUEST - GENERATE THE REQUESTED code CONTENT ***

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:47:53.383 [error] 2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: === API CALL START ===
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Prompt length: 28295 characters
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Context:
2025-08-08 05:47:53,382 [DEBUG] ConsultAgent: Timestamp: 1754646473.3825653
2025-08-08 05:47:53,382 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:47:53,382 [INFO] ConsultAgent: Prompt length: 28295 characters
2025-08-08 05:47:53,382 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:47:53,382 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:47:53,382 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## RESPONSE DECISION INSTRUCTIONS
After analyzing the request, you MUST decide whether to provide a direct response or ask for more information.

**RESPONSE TYPES:**
- **FINAL**: Provide complete response (use when you have sufficient information)
- **QUESTIONS**: Ask clarifying questions (use when missing critical information)
- **CONCERNS**: Flag potential issues (use when you have concerns about the approach)
- **CLARIFICATION**: Request specific details (use when request is unclear)

**DECISION CRITERIA:**
- If the request is clear, complete, and you have sufficient context ‚Üí Use **FINAL**
- If missing critical information needed for a good response ‚Üí Use **QUESTIONS**
- If you have concerns about the approach or potential issues ‚Üí Use **CONCERNS**
- If the request is unclear or ambiguous ‚Üí Use **CLARIFICATION**

**RESPONSE FORMAT:**
Start your response with the response type tag:

**FINAL:**
[Your complete response here]

**QUESTIONS:**
1. [Question 1]
2. [Question 2]
...

**CONCERNS:**
‚ö†Ô∏è [Concern 1]
‚ö†Ô∏è [Concern 2]
[Questions to address concerns]

**CLARIFICATION:**
[What specifically needs to be clarified]

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate

## REFERENCE INFORMATION (NOT THE REQUEST)
*** FOR CONTEXT ONLY - DO NOT TREAT AS THE ACTUAL REQUEST ***

### PROJECT CONTEXT


### CONVERSATION HISTORY
['Previous conversation context:', 'Q: Create a production-ready microservice for user authentication with the following requirements:\n\n1. REST API with FastAPI for user registration, login, and token refresh\n2. JWT token authentication with proper expiration and refresh logic\n3. Password hashing using bcrypt with salt rounds\n4. SQLite database with SQLAlchemy ORM for user storage\n5. Input validation using Pydantic models\n6. Rate limiting to prevent brute force attacks\n7. Logging with proper error handling and audit trails\n8. Health check endpoint for monitoring\n9. Docker containerization with proper security practices\n10. Unit tests with pytest covering all endpoints\n\nThe service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.', 'A: ```python\n#!/usr/bin/env python3\n"""\nAuth Microservice - production-ready FastAPI backend\n\nFeatures:\n- REST API for user registration, login, and token refresh\n- JWT-based authentication with access/refresh tokens and rotation\n- Password hashing with bcrypt (salt rounds configurable)\n- SQLite (SQLAlchemy ORM) with a robust User model\n- Pydantic input validation\n- Thread-safe in-process rate limiter (note: not shared across processes)\n- Logging with audit trails and defensive error handling\n- Health check endpoint for monitoring\n- Docker-ready structure with security-focused defaults\n- Unit tests with pytest covering endpoints (embedded in this file for convenience)\n\nNotes:\n- For multi-instance deployments, replace the RateLimiter with a distributed store (e.g., Redis).\n- In production, load secrets from environment variables and secret managers.\n- This module is self-contained and aims for production-readiness with defensive patterns.\n"""\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport threading\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Generator, Optional, Dict, Tuple\n\n# ---------------------------\n# Dependencies\n# ---------------------------\n\nimport bcrypt\nimport jwt as pyjwt  # PyJWT\nfrom fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, EmailStr, constr, BaseSettings, validator\nfrom sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine\nfrom sqlalchemy.exc import IntegrityError\nfrom sqlalchemy.orm import Session, declarative_base, sessionmaker\n\n# ---------------------------\n# Settings and Configuration\n# ---------------------------\n\nclass Settings(BaseSettings):\n    DATABASE_URL: str = "sqlite:///./auth.db"\n    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"\n    JWT_ALGORITHM: str = "HS256"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15\n    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days\n    HASH_ROUNDS: int = 12\n    LOG_LEVEL: str = "INFO"\n    RATE_LIMIT_LOGIN: int = 5\n    RATE_LIMIT_WINDOW_SECONDS: int = 60\n    APP_NAME: str = "Auth Microservice"\n\n    class Config:\n        env_file = ".env"\n\n    @validator("HASH_ROUNDS")\n    def validate_hash_rounds(cls, v: int) -> int:\n        """\n        Ensure bcrypt salt rounds stay within reasonable bounds to balance security and performance.\n        """\n        if not (4 <= v <= 31):\n            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")\n        return v\n\ndef get_settings() -> Settings:\n    """\n    Load application settings from environment variables or defaults.\n    """\n    return Settings()\n\n# ---------------------------\n# Database (SQLAlchemy)\n# ---------------------------\n\nBase = declarative_base()\n_engine = None  # type: Optional[object]\n_SessionLocal = None  # type: Optional[sessionmaker]\n\ndef init_db(database_url: str) -> None:\n    """\n    Initialize the database engine and session factory.\n    Creates tables if they do not exist yet.\n    """\n    global _engine, _SessionLocal\n    _engine = create_engine(database_url, connect_args={"check_same_thread": False})\n    _SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=_engine)\n    Base.metadata.create_all(_engine)\n\ndef get_session() -> Generator[Session, None, None]:\n    """\n    Dependency to provide a SQLAlchemy session to API endpoints.\n    """\n    if _SessionLocal is None:\n        raise RuntimeError("Database not initialized. Call init_db() first.")\n    db = _SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\nclass User(Base):\n    __tablename__ = "users"\n\n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, nullable=False, index=True)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    last_login = Column(DateTime, nullable=True)\n\n    def __repr__(self) -> str:\n        return f"<User id={self.id} email={self.email}>"\n\n# ---------------------------\n# Security (JWT & Passwords)\n# ---------------------------\n\n# JWT state (passwords secret)\n_SECRET_KEY: str = "CHANGE_ME_SECRET"  # will be overridden by startup with set_jwt_secret\n_ALGORITHM: str = "HS256"\n\ndef set_jwt_secret(key: str) -> None:\n    """\n    Initialize the secret key for JWT encoding/decoding.\n    """\n    global _SECRET_KEY\n    _SECRET_KEY = key\n\ndef _encode_token(payload: dict) -> str:\n    """\n    Encode a JWT with the configured algorithm.\n    """\n    token = pyjwt.encode(payload, _SECRET_KEY, algorithm=_ALGORITHM)\n    if isinstance(token, bytes):\n        token = token.decode("utf-8")\n    return token\n\ndef _decode_token(token: str) -> dict:\n    """\n    Decode a JWT and return its payload.\n    """\n    return pyjwt.decode(token, _SECRET_KEY, algorithms=[_ALGORITHM])\n\ndef _build_token(user_id: int, expires_delta: timedelta, token_type: str) -> str:\n    exp = datetime.utcnow() + expires_delta\n    payload = {"sub": str(user_id), "type": token_type, "exp": exp}\n    return _encode_token(payload)\n\ndef create_access_token(user_id: int, expires_minutes: Optional[int] = None) -> str:\n    """\n    Create a short-lived access token for a user.\n    """\n    settings = get_settings()\n    exp_min = expires_minutes if expires_minutes is not None else settings.ACCESS_TOKEN_EXPIRE_MINUTES\n    return _build_token(user_id, timedelta(minutes=exp_min), "access")\n\ndef create_refresh_token(user_id: int, expires_minutes: Optional[int] = None) -> str:\n    """\n    Create a long-lived refresh token for a user.\n    """\n    settings = get_settings()\n    exp_min = expires_minutes if expires_minutes is not None else settings.REFRESH_TOKEN_EXPIRE_MINUTES\n    return _build_token(user_id, timedelta(minutes=exp_min), "refresh")\n\ndef decode_token(token: str) -> dict:\n    """\n    Decode a JWT and return its payload. Raises ValueError on invalid/expired tokens.\n    """\n    try:\n        return _decode_token(token)\n    except pyjwt.ExpiredSignatureError:\n        raise ValueError("Token has expired")\n    except pyjwt.InvalidTokenError:\n        raise ValueError("Invalid token")\n\ndef extract_user_id_from_payload(payload: dict) -> int:\n    """\n    Extract user_id from a decoded payload. Returns -1 if invalid.\n    """\n    sub = payload.get("sub")\n    ttype = payload.get("type")\n    if not sub or not ttype:\n        return -1\n    try:\n        return int(sub)\n    except ValueError:\n        return -1\n\ndef hash_password(plain_password: str, rounds: int) -> str:\n    """\n    Hash a plain password using bcrypt with the specified rounds.\n    """\n    salt = bcrypt.gensalt(rounds)\n    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)\n    return hashed.decode("utf-8")\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    """\n    Verify a plain password against the stored bcrypt hash.\n    """\n    try:\n        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))\n    except Exception:\n        return False\n\n# ---------------------------\n# Rate Limiter (Thread-safe)\n# ---------------------------\n\nclass RateLimiter:\n    """\n    Simple in-process rate limiter with a fixed window.\n    Thread-safe for basic deployments. For multi-process deployments, replace with Redis.\n    """\n    def __init__(self, window_seconds: int, max_requests: int) -> None:\n        self.window = window_seconds\n        self.max = max_requests\n        self._lock = threading.Lock()\n        self._clients: Dict[str, Tuple[int, float]] = {}\n\n    def is_allowed(self, key: str) -> bool:\n        """\n        Check if a given key is allowed under the rate limit.\n        """\n        with self._lock:\n            now = time.time()\n            count, window_start = self._clients.get(key, (0, now))\n            if now - window_start > self.window:\n                # New window\n                self._clients[key] = (1, now)\n                return True\n            else:\n                if count < self.max:\n                    self._clients[key] = (count + 1, window_start)\n                    return True\n                else:\n                    return False\n\n# ---------------------------\n# Pydantic Schemas\n# ---------------------------\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: constr(min_length=8, max_length=128)\n\nclass UserLogin(BaseModel):\n    email: EmailStr\n    password: constr(min_length=8, max_length=128)\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    refresh_token: Optional[str] = None\n    token_type: str = "bearer"\n\nclass TokenRefresh(BaseModel):\n    refresh_token: str\n\nclass UserOut(BaseModel):\n    id: int\n    email: EmailStr\n    created_at: datetime\n\n    class Config:\n        orm_mode = True\n\n# ---------------------------\n# FastAPI App & Routes\n# ---------------------------\n\nrouter = APIRouter(prefix="/auth", tags=["auth"])\nlogger = logging.getLogger("auth")\n\ndef _setup_security_headers(app: FastAPI) -> None:\n    """\n    Register security headers middleware on FastAPI app.\n    """\n    @app.middleware("http")\n    async def _security_headers(request: Request, call_next):\n        response: Response = await call_next(request)\n        response.headers["X-Content-Type-Options"] = "nosniff"\n        response.headers["X-Frame-Options"] = "DENY"\n        response.headers["X-XSS-Protection"] = "1; mode=block"\n        response.headers["Content-Security-Policy"] = (\n            "default-src \'self\'; script-src \'self\'; object-src \'none\';"\n        )\n        return response\n\ndef _build_app_wrapper() -> FastAPI:\n    """\n    Build the base FastAPI app with CORS and core configuration.\n    Note: Security headers are registered in create_app to avoid duplicate wrapping.\n    """\n    app = FastAPI(title=get_settings().APP_NAME, version="0.1.0")\n\n    # CORS (adjust in production)\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=["*"],\n        allow_credentials=True,\n        allow_methods=["*"],\n        allow_headers=["*"],\n    )\n\n    return app\n\ndef _health_body() -> dict:\n    return {\n        "status": "healthy",\n        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),\n    }\n\ndef _attach_startup_events(app: FastAPI, db_url: str, jwt_secret: str) -> None:\n    settings = get_settings()\n\n    @app.on_event("startup")\n    def _startup():\n        """\n        Initialize database, secret key, and per-instance state once per app lifecycle.\n        """\n        if not hasattr(app.state, "_db_initialized") or not app.state._db_initialized:\n            init_db(db_url)\n            set_jwt_secret(jwt_secret)\n            # Rate limiter per app instance\n            app.state.rate_limiter = RateLimiter(\n                window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,\n                max_requests=settings.RATE_LIMIT_LOGIN,\n            )\n            app.state._db_initialized = True\n            logger.info("Auth DB initialized and JWT secret configured.")\n        else:\n            # Already initialized in this process\n            pass\n\n# Dependency to ensure a session is ready\ndef _ensure_session() -> Generator[Session, None, None]:\n    yield from get_session()\n\n@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)\ndef register(user_in: UserCreate, db: Session = Depends(_ensure_session)) -> TokenResponse:\n    """\n    Register a new user and return access/refresh tokens.\n    """\n    if not user_in.email or not user_in.password:\n        raise HTTPException(status_code=400, detail="Email and password are required")\n\n    user = db.query(User).filter(User.email == user_in.email).first()\n    if user:\n        raise HTTPException(status_code=400, detail="Email already registered")\n\n    settings = get_settings()\n    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)\n    new_user = User(email=user_in.email, hashed_password=hashed)\n    db.add(new_user)\n    try:\n        db.commit()\n    except IntegrityError:\n        db.rollback()\n        raise HTTPException(status_code=400, detail="Email already registered")\n    db.refresh(new_user)\n\n    access_token = create_access_token(new_user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    refresh_token = create_refresh_token(new_user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    logger.info(f"User registered: user_id={new_user.id}, email={new_user.email}")\n    return TokenResponse(access_token=access_token, refresh_token=refresh_token)\n\n@router.post("/login", response_model=TokenResponse)\ndef login(user_in: UserLogin, db: Session = Depends(_ensure_session), request: Request = None) -> TokenResponse:\n    """\n    Authenticate user and return JWT tokens.\n    Apply rate limiting to protect against brute force attempts.\n    """\n    if request is None:\n        raise HTTPException(status_code=500, detail="Internal server error: missing request context")\n\n    client_host = request.client.host if request.client else "unknown"\n\n    rate_limiter: RateLimiter = getattr(request.app.state, "rate_limiter", None)\n    if rate_limiter is None:\n        # Fallback: create a local limiter (in case startup order differs)\n        settings = get_settings()\n        rate_limiter = RateLimiter(window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,\n                                   max_requests=settings.RATE_LIMIT_LOGIN)\n\n    if not rate_limiter.is_allowed(f"{client_host}:login"):\n        logger.warning(f"Rate limit exceeded for {client_host}")\n        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")\n\n    user = db.query(User).filter(User.email == user_in.email).first()\n    if user is None or not verify_password(user_in.password, user.hashed_password):\n        logger.warning(f"Invalid login attempt for email={user_in.email}")\n        raise HTTPException(status_code=401, detail="Invalid credentials")\n\n    user.last_login = datetime.utcnow()\n    try:\n        db.commit()\n    except Exception as e:\n        db.rollback()\n        logger.exception("Failed to update last_login on login: %s", e)\n\n    settings = get_settings()\n    access_token = create_access_token(user.id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    refresh_token = create_refresh_token(user.id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    logger.info(f"User login success: user_id={user.id}, email={user.email}")\n    return TokenResponse(access_token=access_token, refresh_token=refresh_token)\n\n@router.post("/token/refresh", response_model=TokenResponse)\ndef token_refresh(payload: TokenRefresh, db: Session = Depends(_ensure_session)) -> TokenResponse:\n    """\n    Refresh the access token using a valid refresh token.\n    """\n    try:\n        token_payload = decode_token(payload.refresh_token)\n    except ValueError as e:\n        raise HTTPException(status_code=401, detail=str(e))\n\n    user_id = extract_user_id_from_payload(token_payload)\n    token_type = token_payload.get("type")\n\n    if user_id == -1 or token_type != "refresh":\n        raise HTTPException(status_code=401, detail="Invalid refresh token")\n\n    user = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise HTTPException(status_code=401, detail="User not found")\n\n    # Rotate tokens for security\n    settings = get_settings()\n    new_access = create_access_token(user_id, expires_minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    new_refresh = create_refresh_token(user_id, expires_minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)\n\n    logger.info(f"Token refreshed: user_id={user_id}")\n    return TokenResponse(access_token=new_access, refresh_token=new_refresh)\n\n# ---------------------------\n# App Factory\n# ---------------------------\n\ndef create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:\n    """\n    Factory to create a FastAPI app instance with a configured database and JWT secret.\n    """\n    settings = get_settings()\n\n    db_url = database_url or settings.DATABASE_URL\n    jwt_key = jwt_secret or settings.JWT_SECRET_KEY\n\n    # Build app skeleton\n    app = _build_app_wrapper()\n\n    # Security headers (registered exactly once)\n    _setup_security_headers(app)\n\n    app.include_router(router)\n\n    # Attach startup events to initialize DB and secret lazily\n    app.state._db_url = db_url\n    app.state._jwt_secret = jwt_key\n    app.state.db_initialized = False  # internal flag if needed\n\n    _attach_startup_events(app, db_url=db_url, jwt_secret=jwt_key)\n\n    # Health endpoint\n    @app.get("/health")\n    def health():\n        return _health_body()\n\n    # Ensure logging configuration\n    _configure_logging(settings.LOG_LEVEL)\n\n    return app\n\ndef _configure_logging(level_str: str) -> None:\n    """\n    Configure logging level from string to Python\'s logging level.\n    """\n    level = getattr(logging, level_str.upper(), logging.INFO)\n    logging.basicConfig(\n        level=level,\n        format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",\n    )\n\n# Build a default app instance for production-like usage (uvicorn module:app)\n# Tests should call create_app(...) to spin up isolated apps.\napp = create_app()\n\n# ---------------------------\n# Minimal Docker-ready Dockerfile hint (in code comments)\n# ---------------------------\n# To Dockerize:\n# 1) Create a Dockerfile at repo root (example):\n#    FROM python:3.11-slim\n#    WORKDIR /app\n#    ENV PYTHONDONTWRITEBYTECODE=1\n#    ENV PYTHONUNBUFFERED=1\n#    COPY requirements.txt .\n#    RUN pip install --no-cache-dir -r requirements.txt\n#    COPY . .\n#    CMD ["uvicorn", "auth_microservice:app", "--host", "0.0.0.0", "--port", "8000"]\n# 2) Provide a docker-compose.yml including a DB volume and (optional) Redis for rate limiting.\n# 3) Set env vars in production (e.g., JWT_SECRET_KEY, DATABASE_URL).\n\n# ---------------------------\n# Tests (pytest-based)\n# ---------------------------\n\n# The following embedded tests provide coverage for endpoints and basic rate limiting.\n# Run with pytest to validate behavior.\n\nimport asyncio  # noqa: F401\nimport httpx  # type: ignore\nimport pytest\nfrom fastapi import FastAPI\n\n# Re-export a helper for tests: create isolated app instances per test.\nTEST_DB_PATH = "./test_auth.db"\n\n@pytest.fixture(scope="session")\ndef event_loop():\n    # Use the default event loop for pytest-asyncio compatibility\n    loop = asyncio.get_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\ndef isolation_app():\n    """\n    Create a fresh app instance for a test session with its own test DB.\n    """\n    # Ensure a clean test DB\n    if os.path.exists(TEST_DB_PATH):\n        os.remove(TEST_DB_PATH)\n    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")\n    return test_app\n\n@pytest.fixture\nasync def client(isolation_app: FastAPI):\n    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:\n        yield c\n\n@pytest.mark.asyncio\nasync def test_health_endpoint(client: httpx.AsyncClient):\n    resp = await client.get("/health")\n    assert resp.status_code == 200\n    data = resp.json()\n    assert data.get("status") == "healthy"\n\n@pytest.mark.asyncio\nasync def test_register_and_login_and_refresh(client: httpx.AsyncClient):\n    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}\n    reg_resp = await client.post("/auth/register", json=reg_payload)\n    assert reg_resp.status_code in (200, 201)\n    reg_json = reg_resp.json()\n    assert "access_token" in reg_json\n    assert "refresh_token" in reg_json\n\n    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}\n    login_resp = await client.post("/auth/login", json=login_payload)\n    assert login_resp.status_code == 200\n    login_json = login_resp.json()\n    assert "access_token" in login_json\n    assert "refresh_token" in login_json\n\n    refresh_payload = {"refresh_token": login_json["refresh_token"]}\n    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)\n    assert refresh_resp.status_code == 200\n    refresh_json = refresh_resp.json()\n    assert "access_token" in refresh_json\n    assert "refresh_token" in refresh_json\n\n@pytest.mark.asyncio\nasync def test_invalid_login(client: httpx.AsyncClient):\n    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}\n    resp = await client.post("/auth/login", json=payload)\n    assert resp.status_code == 401\n\n@pytest.mark.asyncio\nasync def test_rate_limiting_on_login():\n    """\n    Spin up a fresh app instance and perform multiple login attempts to trigger rate limiting.\n    """\n    test_db = "./test_rate_limit.db"\n    if os.path.exists(test_db):\n        os.remove(test_db)\n\n    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")\n    async with httpx.AsyncClient(app=app, base_url="http://test") as client:\n        # Register a user\n        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}\n        reg = await client.post("/auth/register", json=payload)\n        assert reg.status_code in (200, 201)\n\n        # Wrong password attempts to trigger rate limit\n        wrong = {"email": "bob@example.com", "password": "WrongPass!"}\n        for i in range(6):\n            resp = await client.post("/auth/login", json=wrong)\n            if i < 5:\n                # First 5 attempts may be 401 (invalid credentials) but not yet throttled\n                assert resp.status_code in (401, 200)\n            else:\n                assert resp.status_code == 429\n\n# End of embedded tests\n\n# If this module is run directly, start the app (useful for quick manual testing)\nif __name__ == "__main__":\n    import uvicorn\n    # Use production-ready defaults, can override via environment variables\n    uvicorn.run(app, host="0.0.0.0", port=8000)\n```\n\n\n# Critic Suggestions:\n# `create_app` sets `app.state.db_initialized`, while the startup hook checks/sets `app.state._db_initialized`; using a single flag name would avoid confusion.\n# Consider switching the in-process `RateLimiter` to a distributed store (e.g., Redis) before multi-instance deployment.\n# Default `JWT_SECRET_KEY` value should be overridden in production; you may want to raise if it‚Äôs unchanged.', '']

## üéØ ACTUAL USER REQUEST (THIS IS WHAT MATTERS)
*** THIS IS THE REQUEST - FOCUS ON THIS ***

Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

*** END OF REQUEST - GENERATE THE REQUESTED code CONTENT ***

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:47:53.383 [error] 2025-08-08 05:47:53,382 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:47:53,382 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:47:53.383 [error] 2025-08-08 05:47:53,382 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:47:53,382 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:48:27.343 [error] 2025-08-08 05:48:27,343 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:48:27.344 [error] 2025-08-08 05:48:27,343 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:48:27.349 [error] 2025-08-08 05:48:27,348 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:48:27.349 [error] 2025-08-08 05:48:27,348 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:48:27.349 [error] 2025-08-08 05:48:27,348 [DEBUG] ConsultAgent: Response length: 19799 characters
2025-08-08 05:48:27,348 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=6788, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=8849, output_tokens_details=OutputTokensDetails(reasoning_tokens=4352), total_tokens=15637)

2025-08-08 05:48:27.349 [error] 2025-08-08 05:48:27,348 [DEBUG] ConsultAgent: Response length: 19799 characters
2025-08-08 05:48:27,348 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=6788, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=8849, output_tokens_details=OutputTokensDetails(reasoning_tokens=4352), total_tokens=15637)

2025-08-08 05:48:27.349 [error] 2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Timestamp: 1754646507.349136

2025-08-08 05:48:27.349 [error] 2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:48:27,349 [DEBUG] ConsultAgent: Timestamp: 1754646507.349136

2025-08-08 05:48:27.355 [error] 2025-08-08 05:48:27,355 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:48:27.355 [error] 2025-08-08 05:48:27,355 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:48:27.355 [error] 2025-08-08 05:48:27,355 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Prompt tokens: 6744
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Response tokens: 4479
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Total tokens: 11223
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 6744, 'response_tokens': 4479, 'total_tokens': 11223, 'model': 'gpt-5-nano'}
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: ConsultAgent iteration 1 output length: 19799 characters
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and best-practices for production deployments
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict

import bcrypt
import jwt as pyjwt
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# Engine and session are created per app instance to support test isolation
# The app stores its own engine/session factory in app.state

def init_db(database_url: str) -> Tuple[Session, sessionmaker]:
    """Initialize the database engine and session factory."""
    engine = create_engine(
        database_url, connect_args={"check_same_thread": False}
    )
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return SessionLocal(), SessionLocal  # instance not used directly; return for clarity

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.get("db_session_factory")  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter (fixed window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._clients: Dict[str, Tuple[int, float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # Start a new window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize app
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    SessionLocal, _ = init_db(db_url)  # _ is kept for clarity; we set factory below
    # We will expose a factory function via app.state for per-request DB sessions
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key
    app.state.jwt = app.state.jwt  # type: ignore[no-redef]

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health():
        return _health_body()

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Attach an endpoint to quickly inspect app state if needed (optional)
    @app.get("/config")
    def config_view():
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn: main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)):
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User registered: id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = request.client.host if request.client else "unknown"
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={payload.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User login success: id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1
# ENV PYTHONUNBUFFERED=1
# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt
# COPY . .
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

```
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:48:27,355 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Critic agent exists: True

2025-08-08 05:48:27.355 [error] 2025-08-08 05:48:27,355 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Prompt tokens: 6744
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Response tokens: 4479
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Total tokens: 11223
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 6744, 'response_tokens': 4479, 'total_tokens': 11223, 'model': 'gpt-5-nano'}
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: ConsultAgent iteration 1 output length: 19799 characters
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and best-practices for production deployments
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict

import bcrypt
import jwt as pyjwt
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# Engine and session are created per app instance to support test isolation
# The app stores its own engine/session factory in app.state

def init_db(database_url: str) -> Tuple[Session, sessionmaker]:
    """Initialize the database engine and session factory."""
    engine = create_engine(
        database_url, connect_args={"check_same_thread": False}
    )
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return SessionLocal(), SessionLocal  # instance not used directly; return for clarity

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.get("db_session_factory")  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter (fixed window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._clients: Dict[str, Tuple[int, float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # Start a new window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize app
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    SessionLocal, _ = init_db(db_url)  # _ is kept for clarity; we set factory below
    # We will expose a factory function via app.state for per-request DB sessions
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key
    app.state.jwt = app.state.jwt  # type: ignore[no-redef]

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health():
        return _health_body()

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Attach an endpoint to quickly inspect app state if needed (optional)
    @app.get("/config")
    def config_view():
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn: main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)):
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User registered: id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = request.client.host if request.client else "unknown"
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={payload.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User login success: id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1
# ENV PYTHONUNBUFFERED=1
# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt
# COPY . .
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

```
2025-08-08 05:48:27,355 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:48:27,355 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Critic agent exists: True

2025-08-08 05:48:27.355 [error] 2025-08-08 05:48:27,355 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Running critic review for iteration 1
2025-08-08 05:48:27,355 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:48:27,355 [DEBUG] Critic: Model: o3
2025-08-08 05:48:27,355 [DEBUG] Critic: Review prompt length: 22228 characters
2025-08-08 05:48:27,355 [DEBUG] Critic: Response to review length: 19799 characters
2025-08-08 05:48:27,355 [DEBUG] Critic: Artifact type: code
2025-08-08 05:48:27,355 [DEBUG] Critic: Timestamp: 1754646507.3555121
2025-08-08 05:48:27,355 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:48:27,355 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and best-practices for production deployments
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict

import bcrypt
import jwt as pyjwt
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# Engine and session are created per app instance to support test isolation
# The app stores its own engine/session factory in app.state

def init_db(database_url: str) -> Tuple[Session, sessionmaker]:
    """Initialize the database engine and session factory."""
    engine = create_engine(
        database_url, connect_args={"check_same_thread": False}
    )
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return SessionLocal(), SessionLocal  # instance not used directly; return for clarity

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.get("db_session_factory")  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter (fixed window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._clients: Dict[str, Tuple[int, float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # Start a new window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize app
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    SessionLocal, _ = init_db(db_url)  # _ is kept for clarity; we set factory below
    # We will expose a factory function via app.state for per-request DB sessions
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key
    app.state.jwt = app.state.jwt  # type: ignore[no-redef]

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health():
        return _health_body()

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Attach an endpoint to quickly inspect app state if needed (optional)
    @app.get("/config")
    def config_view():
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn: main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)):
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User registered: id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = request.client.host if request.client else "unknown"
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={payload.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User login success: id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1
# ENV PYTHONUNBUFFERED=1
# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt
# COPY . .
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

```

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:48:27,355 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:48:27.355 [error] 2025-08-08 05:48:27,355 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:48:27,355 [INFO] ConsultAgent: Running critic review for iteration 1
2025-08-08 05:48:27,355 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:48:27,355 [DEBUG] Critic: Model: o3
2025-08-08 05:48:27,355 [DEBUG] Critic: Review prompt length: 22228 characters
2025-08-08 05:48:27,355 [DEBUG] Critic: Response to review length: 19799 characters
2025-08-08 05:48:27,355 [DEBUG] Critic: Artifact type: code
2025-08-08 05:48:27,355 [DEBUG] Critic: Timestamp: 1754646507.3555121
2025-08-08 05:48:27,355 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:48:27,355 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and best-practices for production deployments
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict

import bcrypt
import jwt as pyjwt
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# Engine and session are created per app instance to support test isolation
# The app stores its own engine/session factory in app.state

def init_db(database_url: str) -> Tuple[Session, sessionmaker]:
    """Initialize the database engine and session factory."""
    engine = create_engine(
        database_url, connect_args={"check_same_thread": False}
    )
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return SessionLocal(), SessionLocal  # instance not used directly; return for clarity

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.get("db_session_factory")  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter (fixed window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._clients: Dict[str, Tuple[int, float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # Start a new window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize app
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    SessionLocal, _ = init_db(db_url)  # _ is kept for clarity; we set factory below
    # We will expose a factory function via app.state for per-request DB sessions
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key
    app.state.jwt = app.state.jwt  # type: ignore[no-redef]

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health():
        return _health_body()

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Attach an endpoint to quickly inspect app state if needed (optional)
    @app.get("/config")
    def config_view():
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn: main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)):
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User registered: id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = request.client.host if request.client else "unknown"
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={payload.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User login success: id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1
# ENV PYTHONUNBUFFERED=1
# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt
# COPY . .
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

```

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:48:27,355 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:49:10.424 [error] 2025-08-08 05:49:10,424 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:49:10.425 [error] 2025-08-08 05:49:10,424 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:49:10.425 [error] 2025-08-08 05:49:10,425 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:49:10.425 [error] 2025-08-08 05:49:10,425 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:49:10.425 [error] 2025-08-08 05:49:10,425 [DEBUG] Critic: Response length: 847 characters
2025-08-08 05:49:10,425 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:49:10,425 [DEBUG] Critic: Has error: False
2025-08-08 05:49:10,425 [DEBUG] Critic: Timestamp: 1754646550.4256876
2025-08-08 05:49:10,425 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:10,425 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.

### CRITICAL ISSUES
- `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns
  `SessionLocal, _ = init_db(...)`.
  `SessionLocal` therefore holds a *Session instance*, not the factory.
  `get_db` later executes `SessionLocal()` which raises `TypeError: 'Session' object is not callable`, breaking every endpoint that depends on the database.

### SUGGESTIONS
- Swap the assignment in `create_app`:

  ```python
  _, SessionFactory = init_db(db_url)
  app.state.db_session_factory = SessionFactory
  ```
- (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.

2025-08-08 05:49:10,425 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:10,425 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:49:10,425 [DEBUG] Critic: Passed: False
2025-08-08 05:49:10,425 [DEBUG] Critic: Feedback: The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.
2025-08-08 05:49:10,425 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:49:10,425 [DEBUG] Critic: Suggestions count: 2
2025-08-08 05:49:10,425 [DEBUG] Critic: Critical issue 1: `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns

2025-08-08 05:49:10.425 [error] 2025-08-08 05:49:10,425 [DEBUG] Critic: Response length: 847 characters
2025-08-08 05:49:10,425 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:49:10,425 [DEBUG] Critic: Has error: False
2025-08-08 05:49:10,425 [DEBUG] Critic: Timestamp: 1754646550.4256876
2025-08-08 05:49:10,425 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:10,425 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.

### CRITICAL ISSUES
- `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns
  `SessionLocal, _ = init_db(...)`.
  `SessionLocal` therefore holds a *Session instance*, not the factory.
  `get_db` later executes `SessionLocal()` which raises `TypeError: 'Session' object is not callable`, breaking every endpoint that depends on the database.

### SUGGESTIONS
- Swap the assignment in `create_app`:

  ```python
  _, SessionFactory = init_db(db_url)
  app.state.db_session_factory = SessionFactory
  ```
- (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.

2025-08-08 05:49:10,425 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:10,425 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:49:10,425 [DEBUG] Critic: Passed: False
2025-08-08 05:49:10,425 [DEBUG] Critic: Feedback: The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.
2025-08-08 05:49:10,425 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:49:10,425 [DEBUG] Critic: Suggestions count: 2
2025-08-08 05:49:10,425 [DEBUG] Critic: Critical issue 1: `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,425 [DEBUG] Critic: Suggestion 1: Swap the assignment in `create_app`:
2025-08-08 05:49:10,425 [DEBUG] Critic: Suggestion 2: (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.
2025-08-08 05:49:10,425 [DEBUG] Critic: Timestamp: 1754646550.425903
2025-08-08 05:49:10,425 [INFO] Critic: Critic review result: FAILED
2025-08-08 05:49:10,425 [WARNING] Critic: Critic found 1 critical issues
2025-08-08 05:49:10,425 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,425 [DEBUG] Critic: Suggestion 1: Swap the assignment in `create_app`:
2025-08-08 05:49:10,425 [DEBUG] Critic: Suggestion 2: (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.
2025-08-08 05:49:10,425 [DEBUG] Critic: Timestamp: 1754646550.425903
2025-08-08 05:49:10,425 [INFO] Critic: Critic review result: FAILED
2025-08-08 05:49:10,425 [WARNING] Critic: Critic found 1 critical issues
2025-08-08 05:49:10,425 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,425 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Feedback: The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Suggestions count: 2

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,425 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Feedback: The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Suggestions count: 2

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Critical issue 1: `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Suggestion 1: Swap the assignment in `create_app`:
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Suggestion 2: (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Critical issue 1: `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Suggestion 1: Swap the assignment in `create_app`:
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Suggestion 2: (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Timestamp: 1754646550.4260852
2025-08-08 05:49:10,426 [INFO] ConsultAgent: Critic review: FAILED
2025-08-08 05:49:10,426 [WARNING] ConsultAgent: Critic feedback: The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Timestamp: 1754646550.4260852
2025-08-08 05:49:10,426 [INFO] ConsultAgent: Critic review: FAILED
2025-08-08 05:49:10,426 [WARNING] ConsultAgent: Critic feedback: The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [WARNING] ConsultAgent: Critical issue: `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns
2025-08-08 05:49:10,426 [WARNING] ConsultAgent: Critic failed - forcing retry 2/3

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [WARNING] ConsultAgent: Critical issue: `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns
2025-08-08 05:49:10,426 [WARNING] ConsultAgent: Critic failed - forcing retry 2/3

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [INFO] ConsultAgent: Starting iteration 2/3
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: === API CALL START ===
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Prompt length: 24075 characters

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [INFO] ConsultAgent: Starting iteration 2/3
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: === API CALL START ===
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Prompt length: 24075 characters

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Context:
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Timestamp: 1754646550.4262753
2025-08-08 05:49:10,426 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:49:10,426 [INFO] ConsultAgent: Prompt length: 24075 characters

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Context:
2025-08-08 05:49:10,426 [DEBUG] ConsultAgent: Timestamp: 1754646550.4262753
2025-08-08 05:49:10,426 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:49:10,426 [INFO] ConsultAgent: Prompt length: 24075 characters

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:49:10,426 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:49:10,426 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.

### CRITICAL ISSUES IDENTIFIED:
- `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns

### SUGGESTIONS FOR IMPROVEMENT:
- Swap the assignment in `create_app`:
- (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.



```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and best-practices for production deployments
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict

import bcrypt
import jwt as pyjwt
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# Engine and session are created per app instance to support test isolation
# The app stores its own engine/session factory in app.state

def init_db(database_url: str) -> Tuple[Session, sessionmaker]:
    """Initialize the database engine and session factory."""
    engine = create_engine(
        database_url, connect_args={"check_same_thread": False}
    )
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return SessionLocal(), SessionLocal  # instance not used directly; return for clarity

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.get("db_session_factory")  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter (fixed window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._clients: Dict[str, Tuple[int, float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # Start a new window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize app
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    SessionLocal, _ = init_db(db_url)  # _ is kept for clarity; we set factory below
    # We will expose a factory function via app.state for per-request DB sessions
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key
    app.state.jwt = app.state.jwt  # type: ignore[no-redef]

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health():
        return _health_body()

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Attach an endpoint to quickly inspect app state if needed (optional)
    @app.get("/config")
    def config_view():
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn: main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)):
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User registered: id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = request.client.host if request.client else "unknown"
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={payload.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User login success: id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1
# ENV PYTHONUNBUFFERED=1
# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt
# COPY . .
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

```

## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code
2025-08-08 05:49:10,426 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:49:10,426 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
The code contains a fundamental database-initialisation bug that will raise a runtime exception on every request that touches the database.

### CRITICAL ISSUES IDENTIFIED:
- `init_db` returns `(SessionInstance, SessionFactory)`, but `create_app` assigns

### SUGGESTIONS FOR IMPROVEMENT:
- Swap the assignment in `create_app`:
- (Optional) change `init_db` to return `(SessionFactory, )` only, or give the tuple elements explicit names to avoid this kind of mix-up.



```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and best-practices for production deployments
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, replace the in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict

import bcrypt
import jwt as pyjwt
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    Request,
    Response,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

# Engine and session are created per app instance to support test isolation
# The app stores its own engine/session factory in app.state

def init_db(database_url: str) -> Tuple[Session, sessionmaker]:
    """Initialize the database engine and session factory."""
    engine = create_engine(
        database_url, connect_args={"check_same_thread": False}
    )
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return SessionLocal(), SessionLocal  # instance not used directly; return for clarity

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.get("db_session_factory")  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter (fixed window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._clients: Dict[str, Tuple[int, float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            count, window_start = self._clients.get(key, (0, now))
            if now - window_start > self.window:
                # Start a new window
                self._clients[key] = (1, now)
                return True
            else:
                if count < self.max:
                    self._clients[key] = (count + 1, window_start)
                    return True
                else:
                    return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize app
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    SessionLocal, _ = init_db(db_url)  # _ is kept for clarity; we set factory below
    # We will expose a factory function via app.state for per-request DB sessions
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key
    app.state.jwt = app.state.jwt  # type: ignore[no-redef]

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health():
        return _health_body()

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Attach an endpoint to quickly inspect app state if needed (optional)
    @app.get("/config")
    def config_view():
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn: main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)):
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        raise HTTPException(status_code=400, detail="Email already registered")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User registered: id={new_user.id}, email={new_user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = request.client.host if request.client else "unknown"
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning(f"Rate limit exceeded for {client_host}")
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning(f"Invalid login attempt for email={payload.email}")
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login: %s", e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"User login success: id={user.id}, email={user.email}")
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info(f"Token refreshed: user_id={user_id}")
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# WORKDIR /app
# ENV PYTHONDONTWRITEBYTECODE=1
# ENV PYTHONUNBUFFERED=1
# COPY requirements.txt .
# RUN pip install --no-cache-dir -r requirements.txt
# COPY . .
# CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

```

## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:49:10,426 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:49:10.426 [error] 2025-08-08 05:49:10,426 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:49:10,426 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:49:41.274 [error] 2025-08-08 05:49:41,274 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:49:41.275 [error] 2025-08-08 05:49:41,274 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:49:41.278 [error] 2025-08-08 05:49:41,278 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,278 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,278 [DEBUG] ConsultAgent: Response length: 20319 characters
2025-08-08 05:49:41,278 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Has error: None

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,278 [DEBUG] ConsultAgent: Response length: 20319 characters
2025-08-08 05:49:41,278 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Has error: None

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5354, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=7928, output_tokens_details=OutputTokensDetails(reasoning_tokens=3328), total_tokens=13282)
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Output type: <class 'list'>

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5354, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=7928, output_tokens_details=OutputTokensDetails(reasoning_tokens=3328), total_tokens=13282)
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Output type: <class 'list'>

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Timestamp: 1754646581.2791421

2025-08-08 05:49:41.279 [error] 2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:49:41,279 [DEBUG] ConsultAgent: Timestamp: 1754646581.2791421

2025-08-08 05:49:41.283 [error] 2025-08-08 05:49:41,283 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:49:41.283 [error] 2025-08-08 05:49:41,283 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:49:41.284 [error] 2025-08-08 05:49:41,283 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Prompt tokens: 5322
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Response tokens: 4583
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Total tokens: 9905
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5322, 'response_tokens': 4583, 'total_tokens': 9905, 'model': 'gpt-5-nano'}
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: ConsultAgent iteration 2 output length: 20319 characters
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    engine = create_engine(database_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.db_session_factory  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:
#
# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===

2025-08-08 05:49:41.284 [error] 2025-08-08 05:49:41,283 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Prompt tokens: 5322
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Response tokens: 4583
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Total tokens: 9905
2025-08-08 05:49:41,283 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5322, 'response_tokens': 4583, 'total_tokens': 9905, 'model': 'gpt-5-nano'}
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: ConsultAgent iteration 2 output length: 20319 characters
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    engine = create_engine(database_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.db_session_factory  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:
#
# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]
2025-08-08 05:49:41,283 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===

2025-08-08 05:49:41.284 [error] 2025-08-08 05:49:41,283 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:49:41,284 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:49:41,284 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:49:41,284 [INFO] ConsultAgent: Running critic review for iteration 2
2025-08-08 05:49:41,284 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:49:41,284 [DEBUG] Critic: Model: o3
2025-08-08 05:49:41,284 [DEBUG] Critic: Review prompt length: 22748 characters
2025-08-08 05:49:41,284 [DEBUG] Critic: Response to review length: 20319 characters
2025-08-08 05:49:41,284 [DEBUG] Critic: Artifact type: code
2025-08-08 05:49:41,284 [DEBUG] Critic: Timestamp: 1754646581.284128
2025-08-08 05:49:41,284 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:49:41,284 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    engine = create_engine(database_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.db_session_factory  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:
#
# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup

2025-08-08 05:49:41.284 [error] 2025-08-08 05:49:41,283 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:49:41,284 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:49:41,284 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:49:41,284 [INFO] ConsultAgent: Running critic review for iteration 2
2025-08-08 05:49:41,284 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:49:41,284 [DEBUG] Critic: Model: o3
2025-08-08 05:49:41,284 [DEBUG] Critic: Review prompt length: 22748 characters
2025-08-08 05:49:41,284 [DEBUG] Critic: Response to review length: 20319 characters
2025-08-08 05:49:41,284 [DEBUG] Critic: Artifact type: code
2025-08-08 05:49:41,284 [DEBUG] Critic: Timestamp: 1754646581.284128
2025-08-08 05:49:41,284 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:49:41,284 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request:
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    engine = create_engine(database_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.db_session_factory  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:
#
# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup

2025-08-08 05:49:41.284 [error] 2025-08-08 05:49:41,284 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:49:41.284 [error] 2025-08-08 05:49:41,284 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:49:53.522 [error] 2025-08-08 05:49:53,522 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:49:53.522 [error] 2025-08-08 05:49:53,522 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] Critic: Response length: 472 characters
2025-08-08 05:49:53,523 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:49:53,523 [DEBUG] Critic: Has error: False
2025-08-08 05:49:53,523 [DEBUG] Critic: Timestamp: 1754646593.523373
2025-08-08 05:49:53,523 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:53,523 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
Syntax error in helper dependency prevents application from importing.

### CRITICAL ISSUES
- `_get_db_dependency` contains `return (yield from get_db(request))`.
  Using `return` together with `yield from` is illegal in a generator and raises a `SyntaxError` at import time.
  Fix:
  ```python
  def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
      yield from get_db(request)
  ```

### SUGGESTIONS
- None
2025-08-08 05:49:53,523 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:53,523 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:49:53,523 [DEBUG] Critic: Passed: False
2025-08-08 05:49:53,523 [DEBUG] Critic: Feedback: Syntax error in helper dependency prevents application from importing.
2025-08-08 05:49:53,523 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:49:53,523 [DEBUG] Critic: Suggestions count: 1
2025-08-08 05:49:53,523 [DEBUG] Critic: Critical issue 1: `_get_db_dependency` contains `return (yield from get_db(request))`.
2025-08-08 05:49:53,523 [DEBUG] Critic: Suggestion 1: None
2025-08-08 05:49:53,523 [DEBUG] Critic: Timestamp: 1754646593.523561
2025-08-08 05:49:53,523 [INFO] Critic: Critic review result: FAILED

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] Critic: Response length: 472 characters
2025-08-08 05:49:53,523 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:49:53,523 [DEBUG] Critic: Has error: False
2025-08-08 05:49:53,523 [DEBUG] Critic: Timestamp: 1754646593.523373
2025-08-08 05:49:53,523 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:53,523 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
Syntax error in helper dependency prevents application from importing.

### CRITICAL ISSUES
- `_get_db_dependency` contains `return (yield from get_db(request))`.
  Using `return` together with `yield from` is illegal in a generator and raises a `SyntaxError` at import time.
  Fix:
  ```python
  def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
      yield from get_db(request)
  ```

### SUGGESTIONS
- None
2025-08-08 05:49:53,523 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:49:53,523 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:49:53,523 [DEBUG] Critic: Passed: False
2025-08-08 05:49:53,523 [DEBUG] Critic: Feedback: Syntax error in helper dependency prevents application from importing.
2025-08-08 05:49:53,523 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:49:53,523 [DEBUG] Critic: Suggestions count: 1
2025-08-08 05:49:53,523 [DEBUG] Critic: Critical issue 1: `_get_db_dependency` contains `return (yield from get_db(request))`.
2025-08-08 05:49:53,523 [DEBUG] Critic: Suggestion 1: None
2025-08-08 05:49:53,523 [DEBUG] Critic: Timestamp: 1754646593.523561
2025-08-08 05:49:53,523 [INFO] Critic: Critic review result: FAILED

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [WARNING] Critic: Critic found 1 critical issues
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Feedback: Syntax error in helper dependency prevents application from importing.
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Suggestions count: 1
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Critical issue 1: `_get_db_dependency` contains `return (yield from get_db(request))`.
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Suggestion 1: None

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [WARNING] Critic: Critic found 1 critical issues
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Feedback: Syntax error in helper dependency prevents application from importing.
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Suggestions count: 1
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Critical issue 1: `_get_db_dependency` contains `return (yield from get_db(request))`.
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Suggestion 1: None

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Timestamp: 1754646593.523719
2025-08-08 05:49:53,523 [INFO] ConsultAgent: Critic review: FAILED
2025-08-08 05:49:53,523 [WARNING] ConsultAgent: Critic feedback: Syntax error in helper dependency prevents application from importing.
2025-08-08 05:49:53,523 [WARNING] ConsultAgent: Critical issue: `_get_db_dependency` contains `return (yield from get_db(request))`.
2025-08-08 05:49:53,523 [WARNING] ConsultAgent: Critic failed - forcing retry 3/3

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Timestamp: 1754646593.523719
2025-08-08 05:49:53,523 [INFO] ConsultAgent: Critic review: FAILED
2025-08-08 05:49:53,523 [WARNING] ConsultAgent: Critic feedback: Syntax error in helper dependency prevents application from importing.
2025-08-08 05:49:53,523 [WARNING] ConsultAgent: Critical issue: `_get_db_dependency` contains `return (yield from get_db(request))`.
2025-08-08 05:49:53,523 [WARNING] ConsultAgent: Critic failed - forcing retry 3/3

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [INFO] ConsultAgent: Starting iteration 3/3
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: === API CALL START ===

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [INFO] ConsultAgent: Starting iteration 3/3
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: === API CALL START ===

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Prompt length: 24344 characters
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Context:

2025-08-08 05:49:53.523 [error] 2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Prompt length: 24344 characters
2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Context:

2025-08-08 05:49:53.524 [error] 2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Timestamp: 1754646593.5239599
2025-08-08 05:49:53,523 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:49:53,523 [INFO] ConsultAgent: Prompt length: 24344 characters
2025-08-08 05:49:53,524 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code

2025-08-08 05:49:53.524 [error] 2025-08-08 05:49:53,523 [DEBUG] ConsultAgent: Timestamp: 1754646593.5239599
2025-08-08 05:49:53,523 [INFO] ConsultAgent: === FULL PROMPT BEING SENT TO MODEL ===
2025-08-08 05:49:53,523 [INFO] ConsultAgent: Prompt length: 24344 characters
2025-08-08 05:49:53,524 [INFO] ConsultAgent: Context: Model: gpt-5-nano, Artifact Type: code

2025-08-08 05:49:53.524 [error] 2025-08-08 05:49:53,524 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:49:53,524 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
Syntax error in helper dependency prevents application from importing.

### CRITICAL ISSUES IDENTIFIED:
- `_get_db_dependency` contains `return (yield from get_db(request))`.

### SUGGESTIONS FOR IMPROVEMENT:
- None



```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    engine = create_engine(database_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.db_session_factory  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:
#
# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]

## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:49:53.524 [error] 2025-08-08 05:49:53,524 [INFO] ConsultAgent: --- PROMPT CONTENT START ---
2025-08-08 05:49:53,524 [INFO] ConsultAgent: You are a specialized professional with the role profile and expertise described below. Your mission is to generate the actual code artifact requested by the user.


## ARTIFACT TYPE: CODE (.py)
**Purpose**: Python scripts for specific functionality

## ROLE PROFILE: SENIOR PYTHON DEVELOPER
**Skills**: Python mastery, software engineering, debugging, performance optimization, testing
**Experience**: 8+ years in Python development, production systems, and software architecture
**Focus**: Code quality, maintainability, performance, security, production readiness
**Behavioral Characteristics**:
- Writes defensive, production-ready code with comprehensive error handling
- Prioritizes code clarity and maintainability over cleverness
- Thinks about edge cases, failure modes, and debugging scenarios
- Considers performance implications and resource usage
- Follows established patterns and best practices religiously
- Documents code for future maintainers

## DIRECT ARTIFACT GENERATION
You are a Senior Python Developer. Generate the actual Python code that the user has requested.

**Your Task**: Create production-quality Python code that:
- Includes proper imports and dependencies
- Has comprehensive error handling and logging
- Follows PEP 8 standards and type hints
- Includes docstrings and comments
- Is ready to run with minimal setup

**Output**: Return the complete Python code in a code block, ready to use.

## CORE MISSION
You are an expert in your field with the skills, experience, and behavioral characteristics outlined above. Generate the actual code content that the user has requested, following the requirements and output format specified in your role profile.

## TASK INSTRUCTIONS
1. **Analyze the user request**: Understand what specific code content is needed
2. **Apply your expertise**: Use your skills, experience, and behavioral characteristics to create high-quality content
3. **Follow requirements**: Adhere to the specific requirements and output format for code
4. **Ensure quality**: Meet the quality standards and best practices for your field
5. **Provide context**: Include necessary context, explanations, or metadata as appropriate


## ITERATION REVIEW INSTRUCTIONS
Review the previous response for errors, omissions, unclear points, inefficiency, or any area that could be clarified, optimized, or enhanced. Improve the response for accuracy, completeness, clarity, and practical value.

Pay special attention to the critic feedback below and address any issues identified.

After revising, evaluate whether another review would likely add significant value.
If not, append [STOP] to your output; otherwise, do not include [STOP].

Output only the improved response, appending [STOP] if you determine further iteration is unnecessary.

## PREVIOUS RESPONSE TO IMPROVE

## CRITIC FEEDBACK FROM PREVIOUS ITERATION
Syntax error in helper dependency prevents application from importing.

### CRITICAL ISSUES IDENTIFIED:
- `_get_db_dependency` contains `return (yield from get_db(request))`.

### SUGGESTIONS FOR IMPROVEMENT:
- None



```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    engine = create_engine(database_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = request.app.state.db_session_factory  # type: ignore[assignment]
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    return (yield from get_db(request))

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import os
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:
#
# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]

## USER REQUEST
Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.

## TASK
Generate the actual code content requested by the user. Follow your role profile, requirements, and output format specifications.

2025-08-08 05:49:53.524 [error] 2025-08-08 05:49:53,524 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:49:53,524 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:49:53.524 [error] 2025-08-08 05:49:53,524 [INFO] ConsultAgent: --- PROMPT CONTENT END ---
2025-08-08 05:49:53,524 [INFO] ConsultAgent: === END FULL PROMPT LOG ===

2025-08-08 05:50:25.309 [error] 2025-08-08 05:50:25,309 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:50:25.309 [error] 2025-08-08 05:50:25,309 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:50:25.317 [error] 2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:50:25.317 [error] 2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: === API RESPONSE RECEIVED ===

2025-08-08 05:50:25.317 [error] 2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Response length: 21300 characters
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5397, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=6931, output_tokens_details=OutputTokensDetails(reasoning_tokens=2112), total_tokens=12328)
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Timestamp: 1754646625.3178544

2025-08-08 05:50:25.317 [error] 2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Response length: 21300 characters
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Response type: Response
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Response attributes: ['background', 'construct', 'copy', 'created_at', 'dict', 'error', 'from_orm', 'id', 'incomplete_details', 'instructions', 'json', 'max_output_tokens', 'max_tool_calls', 'metadata', 'model', 'model_computed_fields', 'model_config', 'model_construct', 'model_copy', 'model_dump', 'model_dump_json', 'model_extra', 'model_fields', 'model_fields_set', 'model_json_schema', 'model_parametrized_name', 'model_post_init', 'model_rebuild', 'model_validate', 'model_validate_json', 'model_validate_strings', 'object', 'output', 'output_text', 'parallel_tool_calls', 'parse_file', 'parse_obj', 'parse_raw', 'previous_response_id', 'prompt', 'prompt_cache_key', 'reasoning', 'safety_identifier', 'schema', 'schema_json', 'service_tier', 'status', 'temperature', 'text', 'to_dict', 'to_json', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'truncation', 'update_forward_refs', 'usage', 'user', 'validate']
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Has error: None
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Usage: ResponseUsage(input_tokens=5397, input_tokens_details=InputTokensDetails(cached_tokens=0), output_tokens=6931, output_tokens_details=OutputTokensDetails(reasoning_tokens=2112), total_tokens=12328)
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Output type: <class 'list'>
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Output length: 2
2025-08-08 05:50:25,317 [DEBUG] ConsultAgent: Timestamp: 1754646625.3178544

2025-08-08 05:50:25.323 [error] 2025-08-08 05:50:25,322 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:50:25.323 [error] 2025-08-08 05:50:25,322 [INFO] ConsultAgent: === TOKEN USAGE ===

2025-08-08 05:50:25.323 [error] 2025-08-08 05:50:25,322 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:50:25,322 [INFO] ConsultAgent: Prompt tokens: 5368
2025-08-08 05:50:25,322 [INFO] ConsultAgent: Response tokens: 4797
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Total tokens: 10165
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5368, 'response_tokens': 4797, 'total_tokens': 10165, 'model': 'gpt-5-nano'}
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: ConsultAgent iteration 3 output length: 21300 characters
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-Ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

def setup_logging(level: str) -> None:
    """Configure logging for production-friendly output."""
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        numeric_level = logging.INFO
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        "%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )
    handler.setFormatter(formatter)
    logger.setLevel(numeric_level)
    if not logger.handlers:
        logger.addHandler(handler)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """Return a Settings instance (cached by Pydantic)."""
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    # sqlite specific pragma for multi-threaded access
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    engine = create_engine(database_url, connect_args=connect_args)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = getattr(request.app.state, "db_session_factory", None)
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    # Normalize inputs
    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    """Yield a per-request DB session using the shared factory."""
    yield from get_db(request)

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:50:25,323 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Running critic review for iteration 3
2025-08-08 05:50:25,323 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:50:25,323 [DEBUG] Critic: Model: o3
2025-08-08 05:50:25,323 [DEBUG] Critic: Review prompt length: 24514 characters

2025-08-08 05:50:25.323 [error] 2025-08-08 05:50:25,322 [INFO] ConsultAgent: Model: gpt-5-nano
2025-08-08 05:50:25,322 [INFO] ConsultAgent: Prompt tokens: 5368
2025-08-08 05:50:25,322 [INFO] ConsultAgent: Response tokens: 4797
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Total tokens: 10165
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Token usage tracked: {'prompt_tokens': 5368, 'response_tokens': 4797, 'total_tokens': 10165, 'model': 'gpt-5-nano'}
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: ConsultAgent iteration 3 output length: 21300 characters
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: === CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: ```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-Ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

def setup_logging(level: str) -> None:
    """Configure logging for production-friendly output."""
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        numeric_level = logging.INFO
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        "%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )
    handler.setFormatter(formatter)
    logger.setLevel(numeric_level)
    if not logger.handlers:
        logger.addHandler(handler)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """Return a Settings instance (cached by Pydantic)."""
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    # sqlite specific pragma for multi-threaded access
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    engine = create_engine(database_url, connect_args=connect_args)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = getattr(request.app.state, "db_session_factory", None)
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    # Normalize inputs
    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    """Yield a per-request DB session using the shared factory."""
    yield from get_db(request)

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]
2025-08-08 05:50:25,323 [DEBUG] ConsultAgent: === END CONSULT AGENT RESPONSE CONTENT ===
2025-08-08 05:50:25,323 [INFO] ConsultAgent: === CRITIC STATUS CHECK ===
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Critic agent exists: True
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Critic enabled: True
2025-08-08 05:50:25,323 [INFO] ConsultAgent: Running critic review for iteration 3
2025-08-08 05:50:25,323 [DEBUG] Critic: === CRITIC API CALL START ===
2025-08-08 05:50:25,323 [DEBUG] Critic: Model: o3
2025-08-08 05:50:25,323 [DEBUG] Critic: Review prompt length: 24514 characters

2025-08-08 05:50:25.323 [error] 2025-08-08 05:50:25,323 [DEBUG] Critic: Response to review length: 21300 characters
2025-08-08 05:50:25,323 [DEBUG] Critic: Artifact type: code
2025-08-08 05:50:25,323 [DEBUG] Critic: Timestamp: 1754646625.3233
2025-08-08 05:50:25,323 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:50:25,323 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request: Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-Ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

def setup_logging(level: str) -> None:
    """Configure logging for production-friendly output."""
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        numeric_level = logging.INFO
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        "%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )
    handler.setFormatter(formatter)
    logger.setLevel(numeric_level)
    if not logger.handlers:
        logger.addHandler(handler)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """Return a Settings instance (cached by Pydantic)."""
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    # sqlite specific pragma for multi-threaded access
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    engine = create_engine(database_url, connect_args=connect_args)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = getattr(request.app.state, "db_session_factory", None)
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    # Normalize inputs
    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    """Yield a per-request DB session using the shared factory."""
    yield from get_db(request)

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:50:25,323 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:50:25.323 [error] 2025-08-08 05:50:25,323 [DEBUG] Critic: Response to review length: 21300 characters
2025-08-08 05:50:25,323 [DEBUG] Critic: Artifact type: code
2025-08-08 05:50:25,323 [DEBUG] Critic: Timestamp: 1754646625.3233
2025-08-08 05:50:25,323 [DEBUG] Critic: === CRITIC REVIEW PROMPT CONTENT ===
2025-08-08 05:50:25,323 [DEBUG] Critic: You are a fast, pragmatic code reviewer focused on correctness and major issues. Your job is to catch glaring errors, incorrect code, security vulnerabilities, and major problems - NOT minor stylistic issues.

## REVIEW CRITERIA

### CRITICAL ISSUES (FAIL the response):
- Syntax errors that prevent execution
- Logic errors that break functionality
- Security vulnerabilities (SQL injection, XSS, etc.)
- Missing critical components or dependencies
- Incorrect API usage that would cause runtime errors
- Data type mismatches or validation errors
- Missing error handling for critical operations

### MINOR ISSUES (Suggestions only):
- Code style and formatting preferences
- Optional optimizations
- Documentation improvements
- Minor naming conventions
- Performance suggestions (unless they're critical)

## RESPONSE FORMAT
Respond in this exact format:

### VERDICT
PASS | FAIL

### FEEDBACK
[Brief explanation of the verdict - if PASS, just say "Response passes review" or similar]

### CRITICAL ISSUES
- [List any critical issues that caused a FAIL]
- [Leave empty if PASS]

### SUGGESTIONS
- [List any minor improvements or suggestions]
- [Leave empty if none]

## OPTIMIZATION RULE
If the response PASSES review with no critical issues and only minor suggestions, keep your feedback minimal. Just state that it passes and move on - no need for detailed analysis that won't be used.

## YAML AND CODE BLOCK HANDLING
When reviewing prompts that contain YAML examples or nested code blocks:
- Focus on the correctness of the content and instructions
- Be lenient with YAML syntax in examples if the content is correct
- Allow nested code blocks if they serve instructional purposes
- Only fail on actual functional issues, not formatting preferences

## CONTEXT
Original Request: Create a production-ready microservice for user authentication with the following requirements:

1. REST API with FastAPI for user registration, login, and token refresh
2. JWT token authentication with proper expiration and refresh logic
3. Password hashing using bcrypt with salt rounds
4. SQLite database with SQLAlchemy ORM for user storage
5. Input validation using Pydantic models
6. Rate limiting to prevent brute force attacks
7. Logging with proper error handling and audit trails
8. Health check endpoint for monitoring
9. Docker containerization with proper security practices
10. Unit tests with pytest covering all endpoints

The service should be secure, scalable, and follow Python best practices. Include proper error handling, input sanitization, and security headers.
Context: Artifact type: code

## RESPONSE TO REVIEW
```python
#!/usr/bin/env python3
"""
Auth Microservice (Production-Ready)

Features:
- REST API with FastAPI for user registration, login, and token refresh
- JWT token authentication with proper expiration and refresh logic
- Password hashing using bcrypt with configurable salt rounds
- SQLite database (SQLAlchemy ORM) for user storage
- Input validation via Pydantic models
- In-process rate limiting to mitigate brute-force attacks
- Logging with error handling and audit trails
- Health check endpoint for monitoring
- Security headers and production-ready defaults
- Docker-ready (security-conscious defaults, environment-driven config)
- Pytest-based unit tests covering endpoints (embedded in this file for convenience)

Notes:
- For multi-instance deployments, swap in-process RateLimiter with a distributed store (e.g., Redis).
- In production, secrets (JWT secret) must be externally provided (environment variables/secret manager).
- This module exposes a create_app factory and a module-level app instance to support uvicorn:main:app usage.
"""

from __future__ import annotations

import logging
import os
import threading
import time
from datetime import datetime, timedelta
from typing import Generator, Optional, Tuple, Dict, List

import bcrypt
import jwt as pyjwt
from fastapi import APIRouter, Depends, FastAPI, HTTPException, Request, Response, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, constr, BaseSettings, validator
from sqlalchemy import Boolean, Column, DateTime, Integer, String, create_engine
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, declarative_base, sessionmaker

# ---------------------------
# Logging Configuration
# ---------------------------

LOGGER_NAME = "auth"
logger = logging.getLogger(LOGGER_NAME)

def setup_logging(level: str) -> None:
    """Configure logging for production-friendly output."""
    numeric_level = getattr(logging, level.upper(), None)
    if not isinstance(numeric_level, int):
        numeric_level = logging.INFO
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        "%(asctime)s | %(levelname)s | %(name)s | %(message)s"
    )
    handler.setFormatter(formatter)
    logger.setLevel(numeric_level)
    if not logger.handlers:
        logger.addHandler(handler)

# ---------------------------
# Settings
# ---------------------------

class Settings(BaseSettings):
    DATABASE_URL: str = "sqlite:///./auth.db"
    JWT_SECRET_KEY: str = "CHANGE_ME_SECRET"  # override in production
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 15
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 60 * 24 * 7  # 7 days
    HASH_ROUNDS: int = 12
    LOG_LEVEL: str = "INFO"
    RATE_LIMIT_LOGIN: int = 5
    RATE_LIMIT_WINDOW_SECONDS: int = 60
    APP_NAME: str = "Auth Microservice"

    class Config:
        env_file = ".env"

    @validator("HASH_ROUNDS")
    def validate_hash_rounds(cls, v: int) -> int:
        """Ensure bcrypt salt rounds stay within reasonable bounds."""
        if not (4 <= v <= 31):
            raise ValueError("HASH_ROUNDS must be between 4 and 31 (inclusive).")
        return v

def get_settings() -> Settings:
    """Return a Settings instance (cached by Pydantic)."""
    return Settings()

# ---------------------------
# Database (SQLAlchemy)
# ---------------------------

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, nullable=False, index=True)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    last_login = Column(DateTime, nullable=True)

    def __repr__(self) -> str:
        return f"<User id={self.id} email={self.email}>"

def init_db(database_url: str) -> Tuple[object, sessionmaker]:
    """Initialize the database engine and return (engine, SessionLocal)."""
    # sqlite specific pragma for multi-threaded access
    connect_args = {"check_same_thread": False} if database_url.startswith("sqlite") else {}
    engine = create_engine(database_url, connect_args=connect_args)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    Base.metadata.create_all(engine)
    return engine, SessionLocal

# Dependency to provide a per-request DB session
def get_db(request: Request) -> Generator[Session, None, None]:
    """Yield a SQLAlchemy session bound to the request's app state."""
    SessionLocal = getattr(request.app.state, "db_session_factory", None)
    if SessionLocal is None:
        raise RuntimeError("Database session factory not initialized.")
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------------------------
# Security (JWT & Passwords)
# ---------------------------

_rate_lock = threading.Lock()

class RateLimiter:
    """Thread-safe in-process rate limiter using per-key timestamps (sliding window)."""
    def __init__(self, window_seconds: int, max_requests: int) -> None:
        self.window = window_seconds
        self.max = max_requests
        self._calls: Dict[str, List[float]] = {}
        self._lock = threading.Lock()

    def is_allowed(self, key: str) -> bool:
        """Return True if allowed under rate limit, else False."""
        with self._lock:
            now = time.time()
            timestamps = self._calls.get(key, [])
            # Prune timestamps outside the current window
            window_start = now - self.window
            timestamps = [ts for ts in timestamps if ts >= window_start]
            if len(timestamps) < self.max:
                timestamps.append(now)
                self._calls[key] = timestamps
                return True
            else:
                self._calls[key] = timestamps
                return False

# JWT helpers (module-scope to ease testing / usage)
class JwtManager:
    def __init__(self, secret: str, algorithm: str) -> None:
        self.secret = secret
        self.algorithm = algorithm

    def encode(self, payload: dict) -> str:
        token = pyjwt.encode(payload, self.secret, algorithm=self.algorithm)
        # PyJWT >= 2 returns str; keep compatibility
        return token if isinstance(token, str) else token.decode("utf-8")

    def decode(self, token: str) -> dict:
        return pyjwt.decode(token, self.secret, algorithms=[self.algorithm])

def create_access_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "access", "exp": exp}
    return app.state.jwt.encode(payload)

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    settings = get_settings()
    exp = datetime.utcnow() + (expires_delta or timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))
    payload = {"sub": str(user_id), "type": "refresh", "exp": exp}
    return app.state.jwt.encode(payload)

def decode_token(token: str) -> dict:
    try:
        return app.state.jwt.decode(token)
    except pyjwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except pyjwt.InvalidTokenError:
        raise ValueError("Invalid token")

def extract_user_id_from_payload(payload: dict) -> int:
    sub = payload.get("sub")
    ttype = payload.get("type")
    if not sub or not ttype:
        return -1
    try:
        return int(sub)
    except ValueError:
        return -1

def hash_password(plain_password: str, rounds: int) -> str:
    salt = bcrypt.gensalt(rounds)
    hashed = bcrypt.hashpw(plain_password.encode("utf-8"), salt)
    return hashed.decode("utf-8")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    try:
        return bcrypt.checkpw(plain_password.encode("utf-8"), hashed_password.encode("utf-8"))
    except Exception:
        return False

# ---------------------------
# Pydantic Schemas
# ---------------------------

class UserCreate(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    # Normalize inputs
    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class UserLogin(BaseModel):
    email: EmailStr
    password: constr(min_length=8, max_length=128)

    @validator("email")
    def normalize_email(cls, v: str) -> str:
        return v.strip().lower()

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: Optional[str] = None
    token_type: str = "bearer"

class TokenRefresh(BaseModel):
    refresh_token: str

class UserOut(BaseModel):
    id: int
    email: EmailStr
    created_at: datetime

    class Config:
        orm_mode = True

# ---------------------------
# FastAPI App & Routes
# ---------------------------

router = APIRouter(prefix="/auth", tags=["auth"])

def _health_body() -> dict:
    return {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(timespec="seconds"),
    }

# Security headers middleware
def _add_security_headers(app: FastAPI) -> None:
    @app.middleware("http")
    async def _security_headers(request: Request, call_next):
        response: Response = await call_next(request)
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers[
            "Content-Security-Policy"
        ] = "default-src 'self'; script-src 'self'; object-src 'none';"
        return response

# App factory
def create_app(database_url: Optional[str] = None, jwt_secret: Optional[str] = None) -> FastAPI:
    """Create a FastAPI app instance with a configured database and JWT secret."""
    settings = get_settings()
    db_url = database_url or settings.DATABASE_URL
    jwt_key = jwt_secret or settings.JWT_SECRET_KEY

    # Initialize App
    app = FastAPI(title=settings.APP_NAME, version="0.1.0")

    # Initialize DB per-instance
    engine, SessionLocal = init_db(db_url)
    # Expose a factory function via app.state for per-request DB sessions
    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal  # type: ignore[assignment]

    # JWT manager per instance
    app.state.jwt = JwtManager(secret=jwt_key, algorithm=settings.JWT_ALGORITHM)

    # Rate limiter
    app.state.rate_limiter = RateLimiter(
        window_seconds=settings.RATE_LIMIT_WINDOW_SECONDS,
        max_requests=settings.RATE_LIMIT_LOGIN
    )

    # Attach security headers
    _add_security_headers(app)

    # Token helpers bound to app state (lazily used by endpoints)
    app.state.jwt_secret = jwt_key

    # Health endpoint (production-friendly health check)
    @app.get("/health")
    def health() -> dict:
        return _health_body()

    # Optional config endpoint for introspection (read-only)
    @app.get("/config")
    def config_view() -> dict:
        return {
            "database_url": db_url,
            "jwt_algorithm": settings.JWT_ALGORITHM,
            "rate_limit": {
                "window_seconds": settings.RATE_LIMIT_WINDOW_SECONDS,
                "max_requests": settings.RATE_LIMIT_LOGIN,
            },
        }

    # Register router
    app.include_router(router)

    # Security: allow CORS (adjust for production by restricting origins)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    return app

# Dependency for DB
def _get_db_dependency(request: Request) -> Generator[Session, None, None]:
    """Yield a per-request DB session using the shared factory."""
    yield from get_db(request)

# Initialize module-level app for production-like usage (uvicorn:main:app)
app: FastAPI = create_app()

# ---------------------------
# Endpoint Implementations
# ---------------------------

@router.post("/register", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)
def register(user_in: UserCreate, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Register a new user and return access/refresh tokens."""
    if not user_in.email or not user_in.password:
        raise HTTPException(status_code=400, detail="Email and password are required")

    existing = db.query(User).filter(User.email == user_in.email).first()
    if existing:
        logger.warning("Registration prevented: email already registered: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")

    settings = get_settings()
    hashed = hash_password(user_in.password, rounds=settings.HASH_ROUNDS)
    new_user = User(email=user_in.email, hashed_password=hashed)

    db.add(new_user)
    try:
        db.commit()
    except IntegrityError:
        db.rollback()
        logger.exception("IntegrityError during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=400, detail="Email already registered")
    except Exception:
        db.rollback()
        logger.exception("Unexpected error during user registration for email: %s", user_in.email)
        raise HTTPException(status_code=500, detail="Internal server error")
    db.refresh(new_user)

    access_token = create_access_token(new_user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(new_user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User registered: id=%d, email=%s", new_user.id, new_user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/login", response_model=TokenResponse)
def login(
    payload: UserLogin,
    request: Request,
    db: Session = Depends(_get_db_dependency),
) -> TokenResponse:
    """Login and return JWT tokens. Applies rate limiting per client IP."""
    client_host = (request.client.host if request.client else "unknown")
    rate_limiter: RateLimiter = request.app.state.rate_limiter  # type: ignore[attr-defined]
    if not rate_limiter.is_allowed(f"{client_host}:login"):
        logger.warning("Rate limit exceeded for %s", client_host)
        raise HTTPException(status_code=429, detail="Too many login attempts. Please try again later.")

    user = db.query(User).filter(User.email == payload.email).first()
    if user is None or not verify_password(payload.password, user.hashed_password):
        logger.warning("Invalid login attempt for email=%s from %s", payload.email, client_host)
        raise HTTPException(status_code=401, detail="Invalid credentials")

    user.last_login = datetime.utcnow()
    try:
        db.commit()
    except Exception as e:
        db.rollback()
        logger.exception("Failed to update last_login on login for email=%s: %s", payload.email, e)

    settings = get_settings()
    access_token = create_access_token(user.id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    refresh_token = create_refresh_token(user.id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("User login success: id=%d, email=%s", user.id, user.email)
    return TokenResponse(access_token=access_token, refresh_token=refresh_token)

@router.post("/token/refresh", response_model=TokenResponse)
def token_refresh(payload: TokenRefresh, db: Session = Depends(_get_db_dependency)) -> TokenResponse:
    """Refresh the access token using a valid refresh token (token rotation)."""
    try:
        token_payload = decode_token(payload.refresh_token)
    except ValueError as e:
        raise HTTPException(status_code=401, detail=str(e))

    user_id = extract_user_id_from_payload(token_payload)
    token_type = token_payload.get("type")

    if user_id == -1 or token_type != "refresh":
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")

    settings = get_settings()
    new_access = create_access_token(user_id, timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))
    new_refresh = create_refresh_token(user_id, timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES))

    logger.info("Token refreshed: user_id=%d", user_id)
    return TokenResponse(access_token=new_access, refresh_token=new_refresh)

# ---------------------------
# Tests (pytest-based)
# ---------------------------

# The following embedded tests provide basic end-to-end coverage for endpoints.
# To run:
#   pip install pytest httpx sqlalchemy
#   pytest -q
#
# NOTE: Tests rely on the create_app factory and independent DB instances per test.
import asyncio  # noqa: F401
import httpx  # type: ignore
import pytest
from fastapi import FastAPI

TEST_DB_PATH = "./test_auth.db"

@pytest.fixture(scope="session")
def event_loop():
    loop = asyncio.get_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def isolation_app():
    """Create a fresh app instance with its own test DB for each test module."""
    if os.path.exists(TEST_DB_PATH):
        os.remove(TEST_DB_PATH)
    test_app = create_app(database_url=f"sqlite:///{TEST_DB_PATH}", jwt_secret="TEST_JWT_SECRET")
    return test_app

@pytest.fixture
async def client(isolation_app: FastAPI):
    async with httpx.AsyncClient(app=isolation_app, base_url="http://test") as c:
        yield c

@pytest.mark.asyncio
async def test_health_endpoint(client: httpx.AsyncClient):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "healthy"

@pytest.mark.asyncio
async def test_register_login_and_refresh(client: httpx.AsyncClient):
    reg_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    reg_resp = await client.post("/auth/register", json=reg_payload)
    assert reg_resp.status_code in (200, 201)
    reg_json = reg_resp.json()
    assert "access_token" in reg_json
    assert "refresh_token" in reg_json

    login_payload = {"email": "alice@example.com", "password": "SecurePass123!"}
    login_resp = await client.post("/auth/login", json=login_payload)
    assert login_resp.status_code == 200
    login_json = login_resp.json()
    assert "access_token" in login_json
    assert "refresh_token" in login_json

    refresh_payload = {"refresh_token": login_json["refresh_token"]}
    refresh_resp = await client.post("/auth/token/refresh", json=refresh_payload)
    assert refresh_resp.status_code == 200
    refresh_json = refresh_resp.json()
    assert "access_token" in refresh_json
    assert "refresh_token" in refresh_json

@pytest.mark.asyncio
async def test_invalid_login(client: httpx.AsyncClient):
    payload = {"email": "nonexistent@example.com", "password": "WrongPassword!"}
    resp = await client.post("/auth/login", json=payload)
    assert resp.status_code == 401

@pytest.mark.asyncio
async def test_rate_limiting_on_login():
    """Test basic rate limiting by spinning up a dedicated app instance."""
    test_db = "./test_rate_limit.db"
    if os.path.exists(test_db):
        os.remove(test_db)

    app = create_app(database_url=f"sqlite:///{test_db}", jwt_secret="TEST_RATE_LIMIT")
    async with httpx.AsyncClient(app=app, base_url="http://test") as client:
        # Register a user
        payload = {"email": "bob@example.com", "password": "AnotherPass1!"}
        reg = await client.post("/auth/register", json=payload)
        assert reg.status_code in (200, 201)

        wrong = {"email": "bob@example.com", "password": "WrongPass!"}
        # Exceed rate limit threshold
        for i in range(6):
            resp = await client.post("/auth/login", json=wrong)
            if i < 5:
                # First 5 attempts may be 401, but not yet throttled
                assert resp.status_code in (401, 200)
            else:
                assert resp.status_code == 429

# Optional: direct run support for manual testing
if __name__ == "__main__":
    import uvicorn
    # Uses environment-driven defaults for production
    uvicorn.run(app, host="0.0.0.0", port=8000)

# ---------------------------
# Docker & Deployment Notes (comments)
# ---------------------------

# Dockerfile (example)
# FROM python:3.11-slim
# ENV PYTHONUNBUFFERED=1
# WORKDIR /app
# COPY . .
# RUN python -m pip install --upgrade pip
# RUN pip install --no-cache-dir -r requirements.txt
# CMD ["uvicorn", "this_module:app", "--host", "0.0.0.0", "--port", "8000"]

# Docker Compose (example, adjust as needed)
# version: "3.8"
# services:
#   auth:
#     build: .
#     ports:
#       - "8000:8000"
#     environment:
#       - DATABASE_URL=sqlite:///./auth.db
#       - JWT_SECRET_KEY=super-secure-prod-secret
#     volumes:
#       - db_data:/app
# volumes:
#   db_data:

# Security considerations:
# - Use a proper database in production (not SQLite) and rotate JWT keys regularly.
# - Use HTTPS (TLS) in fronting proxy like Nginx.
# - Consider authenticated endpoints for health/config or remove config exposure in prod.

``` [STOP]

## REVIEW INSTRUCTIONS
1. Focus on correctness and functionality
2. Be pragmatic - only fail on major issues
3. Provide specific, actionable feedback
4. If unsure, default to PASS with suggestions
5. Consider the artifact type when reviewing

Review the response above and provide your verdict.

## CODE-SPECIFIC CRITERIA
- Check for syntax errors, missing imports, undefined variables
- Verify logic flow and algorithm correctness
- Look for security issues (eval, exec, unsafe file operations)
- Ensure proper error handling and edge cases
- Check for resource leaks or improper cleanup
2025-08-08 05:50:25,323 [DEBUG] Critic: === END CRITIC REVIEW PROMPT CONTENT ===

2025-08-08 05:51:02.241 [error] 2025-08-08 05:51:02,241 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:51:02.241 [error] 2025-08-08 05:51:02,241 [INFO] httpx: HTTP Request: POST https://api.openai.com/v1/responses "HTTP/1.1 200 OK"

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: === CRITIC API RESPONSE RECEIVED ===

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Response length: 1178 characters
2025-08-08 05:51:02,242 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:51:02,242 [DEBUG] Critic: Has error: False
2025-08-08 05:51:02,242 [DEBUG] Critic: Timestamp: 1754646662.2424114

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Response length: 1178 characters
2025-08-08 05:51:02,242 [DEBUG] Critic: Response keys: ['raw', 'output_text']
2025-08-08 05:51:02,242 [DEBUG] Critic: Has error: False
2025-08-08 05:51:02,242 [DEBUG] Critic: Timestamp: 1754646662.2424114

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:51:02,242 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
Global helpers that issue / verify JWTs are hard-wired to the module-level `app`.
Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.

### CRITICAL ISSUES
- `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.
  When a new app is built with `create_app(...)`, its endpoints still call these helpers so they silently fall back to the *module-level* app‚Äôs secret (`CHANGE_ME_SECRET`).
  ‚Ä¢ Tokens generated by one instance may be rejected by another.
  ‚Ä¢ Overriding the secret per deployment (env var / test) has no effect, breaking security expectations.

### SUGGESTIONS
- Refactor helpers to accept `request: Request` (or `FastAPI` instance / `JwtManager`) instead of using the global `app`.
- Consider removing the publicly exposed `/config` route or protect it behind auth in production.
- In production replace in-process `RateLimiter` with a shared store (Redis) to work across replicas.
2025-08-08 05:51:02,242 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: === CRITIC REVIEW RESPONSE CONTENT ===
2025-08-08 05:51:02,242 [DEBUG] Critic: ### VERDICT
FAIL

### FEEDBACK
Global helpers that issue / verify JWTs are hard-wired to the module-level `app`.
Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.

### CRITICAL ISSUES
- `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.
  When a new app is built with `create_app(...)`, its endpoints still call these helpers so they silently fall back to the *module-level* app‚Äôs secret (`CHANGE_ME_SECRET`).
  ‚Ä¢ Tokens generated by one instance may be rejected by another.
  ‚Ä¢ Overriding the secret per deployment (env var / test) has no effect, breaking security expectations.

### SUGGESTIONS
- Refactor helpers to accept `request: Request` (or `FastAPI` instance / `JwtManager`) instead of using the global `app`.
- Consider removing the publicly exposed `/config` route or protect it behind auth in production.
- In production replace in-process `RateLimiter` with a shared store (Redis) to work across replicas.
2025-08-08 05:51:02,242 [DEBUG] Critic: === END CRITIC REVIEW RESPONSE CONTENT ===

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:51:02,242 [DEBUG] Critic: Passed: False

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: === CRITIC RESULT PARSED ===
2025-08-08 05:51:02,242 [DEBUG] Critic: Passed: False

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Feedback: Global helpers that issue / verify JWTs are hard-wired to the module-level `app`. Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Feedback: Global helpers that issue / verify JWTs are hard-wired to the module-level `app`. Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestions count: 3
2025-08-08 05:51:02,242 [DEBUG] Critic: Critical issue 1: `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Critical issues count: 1
2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestions count: 3
2025-08-08 05:51:02,242 [DEBUG] Critic: Critical issue 1: `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestion 1: Refactor helpers to accept `request: Request` (or `FastAPI` instance / `JwtManager`) instead of using the global `app`.
2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestion 2: Consider removing the publicly exposed `/config` route or protect it behind auth in production.

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestion 1: Refactor helpers to accept `request: Request` (or `FastAPI` instance / `JwtManager`) instead of using the global `app`.
2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestion 2: Consider removing the publicly exposed `/config` route or protect it behind auth in production.

2025-08-08 05:51:02.242 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestion 3: In production replace in-process `RateLimiter` with a shared store (Redis) to work across replicas.
2025-08-08 05:51:02,242 [DEBUG] Critic: Timestamp: 1754646662.2427292
2025-08-08 05:51:02,242 [INFO] Critic: Critic review result: FAILED
2025-08-08 05:51:02,242 [WARNING] Critic: Critic found 1 critical issues
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Feedback: Global helpers that issue / verify JWTs are hard-wired to the module-level `app`. Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestions count: 3

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,242 [DEBUG] Critic: Suggestion 3: In production replace in-process `RateLimiter` with a shared store (Redis) to work across replicas.
2025-08-08 05:51:02,242 [DEBUG] Critic: Timestamp: 1754646662.2427292
2025-08-08 05:51:02,242 [INFO] Critic: Critic review result: FAILED
2025-08-08 05:51:02,242 [WARNING] Critic: Critic found 1 critical issues
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: === CRITIC RESPONSE RECEIVED ===
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Passed: False
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Feedback: Global helpers that issue / verify JWTs are hard-wired to the module-level `app`. Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Critical issues count: 1
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestions count: 3

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Critical issue 1: `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestion 1: Refactor helpers to accept `request: Request` (or `FastAPI` instance / `JwtManager`) instead of using the global `app`.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestion 2: Consider removing the publicly exposed `/config` route or protect it behind auth in production.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestion 3: In production replace in-process `RateLimiter` with a shared store (Redis) to work across replicas.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Timestamp: 1754646662.242976
2025-08-08 05:51:02,243 [INFO] ConsultAgent: Critic review: FAILED

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Critical issue 1: `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestion 1: Refactor helpers to accept `request: Request` (or `FastAPI` instance / `JwtManager`) instead of using the global `app`.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestion 2: Consider removing the publicly exposed `/config` route or protect it behind auth in production.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Suggestion 3: In production replace in-process `RateLimiter` with a shared store (Redis) to work across replicas.
2025-08-08 05:51:02,242 [DEBUG] ConsultAgent: Timestamp: 1754646662.242976
2025-08-08 05:51:02,243 [INFO] ConsultAgent: Critic review: FAILED

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,243 [WARNING] ConsultAgent: Critic feedback: Global helpers that issue / verify JWTs are hard-wired to the module-level `app`. Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.
2025-08-08 05:51:02,243 [WARNING] ConsultAgent: Critical issue: `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,243 [WARNING] ConsultAgent: Critic feedback: Global helpers that issue / verify JWTs are hard-wired to the module-level `app`. Any app instance returned by `create_app()` (used in tests or by other services) will therefore sign and validate tokens with **the wrong JWT manager/secret**, defeating the configurability requirement and making multi-instance use unsafe.
2025-08-08 05:51:02,243 [WARNING] ConsultAgent: Critical issue: `create_access_token`, `create_refresh_token`, and `decode_token` reference the global variable `app.state.jwt`.

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,243 [ERROR] ConsultAgent: Critic failed after 3 attempts - logging for human review

2025-08-08 05:51:02.243 [error] 2025-08-08 05:51:02,243 [ERROR] ConsultAgent: Critic failed after 3 attempts - logging for human review

2025-08-08 05:51:02.246 [info] Successfully called tool 'consult'