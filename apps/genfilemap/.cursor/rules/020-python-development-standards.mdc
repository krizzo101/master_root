---
description: WHEN developing Python applications TO ensure quality, maintainability, and leverage Claude Sonnet 4 capabilities YOU MUST follow modern Python standards with AI-optimized practices
globs:
alwaysApply: false
---

{
"title": "Python Development Standards",
"sections": {
"python*environment": {
"depth": 1,
"trigger": "python-setup",
"rules": [
{"name": "Python Version Standard", "when": "setting up Python development environment", "to": "ensure modern features and security", "you_must": "use Python 3.13+ for all new development", "validation_criteria": ["Python 3.13+ specified in pyproject.toml", "No deprecated language features used", "Modern syntax patterns utilized"], "compliant_example": "# pyproject.toml\n[tool.poetry.dependencies]\npython = \"^3.13\"", "non_compliant_example": "# requirements.txt with no version spec", "dependencies": []},
{"name": "Package Manager Selection", "when": "choosing dependency management tool", "to": "ensure robust dependency resolution and modern workflow", "you_must": "prefer Poetry > PDM > Hatch > Rye for dependency management", "validation_criteria": ["pyproject.toml exists", "Lock file present", "Dev dependencies separated"], "compliant_example": "poetry init && poetry add --dev pytest mypy black ruff", "non_compliant_example": "pip install package && pip freeze > requirements.txt", "dependencies": ["Python Version Standard"]},
{"name": "Environment Isolation", "when": "working on any Python project", "to": "prevent dependency conflicts", "you_must": "always use virtual environments or containerized development", "validation_criteria": ["Virtual environment active", "No global package installations", "Environment documented"], "compliant_example": "poetry shell # or python -m venv .venv && source .venv/bin/activate", "non_compliant_example": "pip install package # into global Python", "dependencies": ["Package Manager Selection"]}
]
},
"code_quality": {
"depth": 1,
"trigger": "code-writing",
"rules": [
{"name": "Type Annotations Mandatory", "when": "writing any Python function or method", "to": "enable static analysis and IDE support", "you_must": "annotate all function parameters, return types, and complex variables", "validation_criteria": ["All functions have type hints", "Complex variables are annotated", "Generic types used for containers", "from __future__ import annotations used"], "compliant_example": "from **future** import annotations\n\ndef process_data(items: list[dict[str, Any]]) -> ProcessResult:\n result: list[str] = []\n return ProcessResult(processed=result)", "non_compliant_example": "def process_data(items):\n result = []\n return result", "dependencies": []},
{"name": "Modern Python Features", "when": "implementing functionality", "to": "leverage latest language capabilities", "you_must": "use pattern matching, f-strings, dataclasses, and async/await appropriately", "validation_criteria": ["Pattern matching for complex conditionals", "F-strings for formatting", "Dataclasses for data containers", "Async/await for I/O operations"], "compliant_example": "match response.status:\n case 200:\n return await process_success(response)\n case 404:\n raise NotFoundError(f\"Resource {resource_id} not found\")", "non_compliant_example": "if response.status == 200:\n return process_success(response)\nelif response.status == 404:\n raise Exception(\"Not found\")", "dependencies": ["Type Annotations Mandatory"]},
{"name": "Code Formatting Standards", "when": "writing or reviewing code", "to": "maintain consistency across codebase", "you_must": "use Black for formatting, Ruff for linting, and mypy for type checking", "validation_criteria": ["Black configuration in pyproject.toml", "Ruff replaces flake8/pylint", "mypy strict mode enabled", "Pre-commit hooks configured"], "compliant_example": "# pyproject.toml\n[tool.black]\nline-length = 88\ntarget-version = ['py313']\n\n[tool.ruff]\nselect = [\"E\", \"F\", \"I\", \"N\", \"W\"]\n\n[tool.mypy]\nstrict = true", "non_compliant_example": "# No formatting configuration", "dependencies": ["Modern Python Features"]}
]
},
"architecture_patterns": {
"depth": 1,
"trigger": "application-design",
"rules": [
{"name": "Modular Architecture", "when": "designing application structure", "to": "ensure scalability and maintainability", "you_must": "organize code into clear modules with single responsibilities", "validation_criteria": ["Clear separation of concerns", "Dependency injection used", "Interface segregation principle followed", "No circular dependencies"], "compliant_example": "# src/domain/user.py\nclass UserService:\n def **init**(self, repo: UserRepository):\n self.\_repo = repo\n\n# src/infrastructure/db.py\nclass SQLUserRepository(UserRepository):\n pass", "non_compliant_example": "# everything in main.py\ndef do_everything():\n # database, business logic, API all mixed", "dependencies": []},
{"name": "Error Handling Strategy", "when": "implementing error handling", "to": "provide clear error classification and debugging", "you_must": "create custom exception hierarchy and handle errors appropriately", "validation_criteria": ["Project-specific exception base class", "Contextual error messages", "Appropriate exception types", "No bare except clauses"], "compliant_example": "class AppError(Exception):\n pass\n\nclass ValidationError(AppError):\n def **init**(self, field: str, value: Any):\n super().**init**(f\"Invalid {field}: {value}\")", "non_compliant_example": "try:\n dangerous_operation()\nexcept:\n pass", "dependencies": ["Modular Architecture"]},
{"name": "Async Programming Standards", "when": "implementing I/O operations", "to": "prevent blocking and improve performance", "you_must": "use async/await for all I/O-bound operations with proper concurrency control", "validation_criteria": ["Async/await for network calls", "Semaphores for concurrency limits", "Proper error handling in async", "No blocking calls in async functions"], "compliant_example": "async def fetch_data(urls: list[str]) -> list[dict]:\n semaphore = asyncio.Semaphore(5)\n async def fetch_one(url):\n async with semaphore, aiohttp.ClientSession() as session:\n async with session.get(url) as response:\n return await response.json()\n tasks = [fetch_one(url) for url in urls]\n return await asyncio.gather(\*tasks, return_exceptions=True)", "non_compliant_example": "async def fetch_data(urls):\n results = []\n for url in urls:\n response = requests.get(url) # blocking in async\n results.append(response.json())\n return results", "dependencies": ["Error Handling Strategy"]}
]
},
"testing_standards": {
"depth": 1,
"trigger": "test-implementation",
"rules": [
{"name": "Comprehensive Test Coverage", "when": "writing tests", "to": "ensure code reliability and prevent regressions", "you_must": "maintain minimum 90% test coverage with unit, integration, and property-based tests", "validation_criteria": ["pytest configuration present", "90%+ code coverage", "Property-based tests for algorithms", "Integration tests for workflows", "Mocked external dependencies"], "compliant_example": "# pyproject.toml\n[tool.pytest.ini_options]\nminversion = \"7.0\"\ntestpaths = [\"tests\"]\npython_files = [\"test**.py\"]\naddopts = \"--cov=src --cov-report=html --cov-fail-under=90\"", "non_compliant_example": "# No test configuration", "dependencies": []},
{"name": "Test Organization", "when": "structuring test suites", "to": "maintain clear test structure and isolation", "you_must": "organize tests by functionality with proper fixtures and no shared state", "validation_criteria": ["Tests mirror source structure", "Fixtures for common setup", "No shared mutable state", "Tests can run independently"], "compliant_example": "@pytest.fixture\nasync def user_service():\n repo = MockUserRepository()\n service = UserService(repo)\n yield service\n await service.cleanup()\n\ndef test_create_user(user_service):\n # Test uses isolated fixture", "non_compliant_example": "# Global test data\ntest_user = User(\"test\")\n\ndef test_a():\n test_user.name = \"modified\"\n\ndef test_b():\n assert test_user.name == \"test\" # Fails!", "dependencies": ["Comprehensive Test Coverage"]}
]
},
"claude_optimization": {
"depth": 1,
"trigger": "ai-development",
"rules": [
{"name": "Extended Thinking Integration", "when": "implementing complex algorithms or business logic", "to": "leverage Claude's reasoning capabilities", "you_must": "design code to be readable and debuggable with clear intermediate steps", "validation_criteria": ["Complex logic broken into steps", "Intermediate results stored", "Clear variable names", "Docstrings explain reasoning"], "compliant_example": "def calculate_risk_score(user_data: UserData) -> RiskScore:\n \"\"\"Calculate user risk score using multi-factor analysis.\n \n Steps:\n 1. Normalize input factors\n 2. Apply weighted scoring\n 3. Adjust for historical patterns\n \"\"\"\n normalized_factors = normalize_risk_factors(user_data)\n weighted_score = apply_factor_weights(normalized_factors)\n final_score = adjust_for_history(weighted_score, user_data.history)\n return RiskScore(final_score)", "non_compliant_example": "def calc(d):\n return sum(x*w for x,w in zip(d.vals, WEIGHTS)) * d.hist_mult", "dependencies": []},
{"name": "Code Execution Compatibility", "when": "writing code for analysis or visualization", "to": "ensure compatibility with Claude's execution environment", "you_must": "write self-contained code blocks with minimal external dependencies", "validation_criteria": ["Minimal import statements", "No file system dependencies", "Clear data inputs", "Reproducible outputs"], "compliant_example": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate sample data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\n# Create plot\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_title('Sine Wave')\nplt.show()", "non_compliant_example": "from custom_module import complex_dependency\ndata = load_from_file('path/to/file.csv')\nresult = complex_dependency.process(data)", "dependencies": ["Extended Thinking Integration"]}
]
},
"security_practices": {
"depth": 1,
"trigger": "security-implementation",
"rules": [
{"name": "Input Validation", "when": "handling external data", "to": "prevent injection attacks and data corruption", "you_must": "validate and sanitize all external inputs using pydantic or similar", "validation_criteria": ["Pydantic models for data validation", "No eval() or exec() usage", "SQL injection prevention", "Path traversal protection"], "compliant_example": "from pydantic import BaseModel, validator\n\nclass UserInput(BaseModel):\n email: str\n age: int\n \n @validator('email')\n def validate_email(cls, v):\n if '@' not in v:\n raise ValueError('Invalid email')\n return v", "non_compliant_example": "user_data = eval(request.get_json()) # Dangerous!", "dependencies": []},
{"name": "Dependency Security", "when": "managing project dependencies", "to": "prevent supply chain attacks", "you_must": "regularly scan dependencies and pin versions", "validation_criteria": ["Safety or similar scanner configured", "Bandit for security analysis", "Dependencies pinned in lock file", "Regular security updates"], "compliant_example": "# CI/CD pipeline\n- name: Security scan\n run: |\n safety check\n bandit -r src/", "non_compliant_example": "# requirements.txt\nrequests # No version specified", "dependencies": ["Input Validation"]}
]
},
"performance_optimization": {
"depth": 2,
"trigger": "performance-optimization",
"rules": [
{"name": "Memory Efficiency", "when": "processing large datasets", "to": "optimize memory usage", "you_must": "use generators, itertools, and appropriate data structures", "validation_criteria": ["Generators for large sequences", "Appropriate data structure selection", "Memory profiling available", "No unnecessary data copying"], "compliant_example": "def process_large_file(filename: str) -> Generator[ProcessedRecord, None, None]:\n with open(filename) as f:\n for line in f:\n yield process_line(line)", "non_compliant_example": "def process_large_file(filename):\n with open(filename) as f:\n all_lines = f.readlines() # Loads entire file\n return [process_line(line) for line in all_lines]", "dependencies": []},
{"name": "Concurrency Patterns", "when": "implementing parallel processing", "to": "maximize CPU and I/O utilization", "you_must": "choose appropriate concurrency model based on workload type", "validation_criteria": ["asyncio for I/O-bound tasks", "multiprocessing for CPU-bound tasks", "threading for mixed workloads", "Proper resource management"], "compliant_example": "# I/O-bound: use asyncio\nasync def fetch_urls(urls):\n async with aiohttp.ClientSession() as session:\n tasks = [fetch_url(session, url) for url in urls]\n return await asyncio.gather(*tasks)\n\n# CPU-bound: use multiprocessing\ndef cpu*intensive_work(data_chunks):\n with multiprocessing.Pool() as pool:\n return pool.map(process_chunk, data_chunks)", "non_compliant_example": "# Using threading for CPU-bound work\nimport threading\ndef cpu_work():\n threads = [threading.Thread(target=cpu_task) for * in range(10)]\n # GIL prevents true parallelism", "dependencies": ["Memory Efficiency"]}
]
},
"documentation_standards": {
"depth": 2,
"trigger": "documentation",
"rules": [
{"name": "Docstring Requirements", "when": "documenting code", "to": "ensure comprehensive API documentation", "you_must": "use Google or NumPy style docstrings with type information", "validation_criteria": ["All public functions documented", "Type information included", "Examples provided", "Sphinx-compatible format"], "compliant_example": "def calculate_similarity(vector1: np.ndarray, vector2: np.ndarray, method: str = \"cosine\") -> float:\n \"\"\"Calculate similarity between two vectors.\n \n Args:\n vector1: First vector for comparison\n vector2: Second vector for comparison \n method: Similarity measure ('cosine', 'euclidean', 'manhattan')\n \n Returns:\n Similarity score between 0 and 1\n \n Raises:\n ValueError: If vectors have different dimensions\n \n Example:\n >>> v1 = np.array([1, 2, 3])\n >>> v2 = np.array([4, 5, 6])\n >>> calculate_similarity(v1, v2, 'cosine')\n 0.9746318461970762\n \"\"\"", "non_compliant_example": "def calc_sim(v1, v2, m=\"cosine\"):\n # Calculate similarity\n pass", "dependencies": []}
]
},
"deployment_readiness": {
"depth": 2,
"trigger": "deployment-preparation",
"rules": [
{"name": "Configuration Management", "when": "preparing for deployment", "to": "ensure environment-specific configuration", "you_must": "use environment variables and configuration files for all settings", "validation_criteria": ["Environment variables for secrets", "Configuration classes defined", "No hardcoded values", "Development/staging/production configs"], "compliant_example": "from pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n database_url: str\n api_key: str\n debug: bool = False\n \n class Config:\n env_file = \".env\"\n\nsettings = Settings()", "non_compliant_example": "DATABASE_URL = \"postgresql://localhost/mydb\" # Hardcoded", "dependencies": []},
{"name": "Docker Integration", "when": "containerizing applications", "to": "ensure consistent deployment environments", "you_must": "create optimized Dockerfiles with proper layer caching", "validation_criteria": ["Multi-stage builds used", "Non-root user configured", "Minimal base image", "Poetry/pip requirements cached"], "compliant_example": "FROM python:3.13-slim as builder\nRUN pip install poetry\nCOPY pyproject.toml poetry.lock ./\nRUN poetry config virtualenvs.create false && poetry install --no-dev\n\nFROM python:3.13-slim\nRUN adduser --disabled-password --gecos '' appuser\nCOPY --from=builder /usr/local/lib/python3.13/site-packages /usr/local/lib/python3.13/site-packages\nUSER appuser", "non_compliant_example": "FROM python:3.13\nCOPY . .\nRUN pip install -r requirements.txt\n# Running as root, inefficient layers", "dependencies": ["Configuration Management"]}
]
}
},
"danger": {
"critical_violations": [
"NEVER use eval() or exec() with untrusted input",
"NEVER store secrets or API keys in code",
"NEVER suppress exceptions without proper handling",
"NEVER use mutable default arguments",
"NEVER ignore type checking errors without justification",
"NEVER use blocking I/O in async functions",
"NEVER commit virtual environments or __pycache__ to version control",
"NEVER use global variables for application state"
]
}
}
