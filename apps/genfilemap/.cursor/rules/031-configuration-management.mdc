---
description: WHEN managing project configuration files TO ensure consistency and prevent conflicts YOU MUST maintain synchronized configurations across all tools and avoid format mixing
globs:
alwaysApply: false
---

# Configuration Management Standards

## Purpose

This rule ensures consistent configuration management across all project tools, preventing conflicts from inconsistent exclusions, format mixing, and configuration drift.

## Scope

This rule applies to all configuration files including pyproject.toml, .pre-commit-config.yaml, mypy.ini, and other tool-specific configuration files.

## Requirements

### Configuration Consistency

1. **Synchronized Exclusions**
   - MAINTAIN consistent exclude patterns across all tools
   - DEFINE exclusions in a central location when possible
   - SYNCHRONIZE mypy, ruff, black, and other tool exclusions
   - DOCUMENT rationale for each exclusion pattern

2. **Format Integrity**
   - NEVER mix YAML content in TOML files
   - VALIDATE configuration file formats before committing
   - USE appropriate parsers for each configuration format
   - IMPLEMENT configuration validation in CI/CD

### Implementation Standards

1. **Centralized Exclusion Management**
   ```toml
   # pyproject.toml - Define exclusions once
   [tool.ruff]
   exclude = [
       "archive/",
       "dev_prompts/",
       ".mypy_cache/",
       "__pycache__/"
   ]

   [tool.black]
   extend-exclude = '''
   /(
       archive
       | dev_prompts
       | \.mypy_cache
   )/
   '''

   [tool.mypy]
   exclude = [
       "archive/",
       "dev_prompts/"
   ]
   ```

2. **Configuration Validation**
   ```python
   # config_validator.py
   import toml
   import yaml
   from pathlib import Path

   def validate_pyproject_toml():
       """Validate pyproject.toml format and consistency."""
       try:
           with open("pyproject.toml", "r") as f:
               config = toml.load(f)

           # Check for YAML content in TOML
           content = f.read()
           if any(line.strip().startswith('-') for line in content.split('\n')):
               raise ValueError("YAML content detected in TOML file")

           return True
       except Exception as e:
           print(f"pyproject.toml validation failed: {e}")
           return False
   ```

3. **Exclusion Synchronization**
   - CREATE shared exclusion patterns
   - IMPLEMENT exclusion validation script
   - AUTOMATE exclusion synchronization
   - MONITOR for configuration drift

### Error Prevention

1. **Common Configuration Issues**
   - Inconsistent exclude patterns between tools
   - YAML content mixed into TOML files
   - Missing type stub dependencies
   - Conflicting tool configurations

2. **Mitigation Strategies**
   - USE configuration templates
   - IMPLEMENT automated validation
   - MAINTAIN configuration documentation
   - REGULAR configuration audits

## Validation Criteria

- [ ] All tools use consistent exclusion patterns
- [ ] Configuration files use correct formats
- [ ] No YAML content in TOML files
- [ ] Configuration validation passes
- [ ] Exclusion patterns are documented

## Examples

### Compliant Example
```toml
# pyproject.toml - Consistent and clean
[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "seai"
version = "0.1.0"

[tool.ruff]
target-version = "py312"
exclude = [
    "archive/",
    "dev_prompts/",
    ".mypy_cache/"
]

[tool.black]
target-version = ['py312']
extend-exclude = '''
/(
    archive
    | dev_prompts
    | \.mypy_cache
)/
'''

[tool.mypy]
python_version = "3.12"
strict = true
exclude = [
    "archive/",
    "dev_prompts/"
]
```

### Non-Compliant Example
```toml
# pyproject.toml - Mixed formats and inconsistent exclusions
[tool.ruff]
exclude = ["archive/"]  # Missing dev_prompts

[tool.black]
# YAML content in TOML file - WRONG!
extend-exclude: |
  /(
    archive
    | different_pattern
  )/

[tool.mypy]
exclude = ["completely_different/"]  # Inconsistent
```

## Configuration Validation Script

```python
#!/usr/bin/env python3
"""Configuration validation script."""

import toml
import yaml
import re
from pathlib import Path
from typing import List, Dict, Any

class ConfigValidator:
    def __init__(self):
        self.errors = []

    def validate_pyproject_format(self) -> bool:
        """Validate pyproject.toml format."""
        try:
            with open("pyproject.toml", "r") as f:
                content = f.read()

            # Check for YAML-style content
            yaml_patterns = [
                r'^\s*-\s+',  # YAML list items
                r':\s*\|',    # YAML literal block
                r':\s*>',     # YAML folded block
            ]

            for i, line in enumerate(content.split('\n'), 1):
                for pattern in yaml_patterns:
                    if re.match(pattern, line):
                        self.errors.append(f"Line {i}: YAML syntax in TOML file: {line.strip()}")

            # Validate TOML parsing
            toml.loads(content)
            return len(self.errors) == 0

        except Exception as e:
            self.errors.append(f"TOML parsing error: {e}")
            return False

    def validate_exclusion_consistency(self) -> bool:
        """Validate that exclusion patterns are consistent."""
        try:
            with open("pyproject.toml", "r") as f:
                config = toml.load(f)

            # Extract exclusion patterns
            ruff_excludes = set(config.get("tool", {}).get("ruff", {}).get("exclude", []))
            mypy_excludes = set(config.get("tool", {}).get("mypy", {}).get("exclude", []))

            # Check for common exclusions
            expected_common = {"archive/", "dev_prompts/"}

            if not expected_common.issubset(ruff_excludes):
                missing = expected_common - ruff_excludes
                self.errors.append(f"Ruff missing common exclusions: {missing}")

            if not expected_common.issubset(mypy_excludes):
                missing = expected_common - mypy_excludes
                self.errors.append(f"Mypy missing common exclusions: {missing}")

            return len(self.errors) == 0

        except Exception as e:
            self.errors.append(f"Exclusion validation error: {e}")
            return False

    def run_validation(self) -> bool:
        """Run all validations."""
        format_ok = self.validate_pyproject_format()
        exclusion_ok = self.validate_exclusion_consistency()

        if self.errors:
            print("❌ Configuration validation failed:")
            for error in self.errors:
                print(f"  - {error}")
            return False
        else:
            print("✅ Configuration validation passed")
            return True

if __name__ == "__main__":
    validator = ConfigValidator()
    success = validator.run_validation()
    exit(0 if success else 1)
```