---
description: "MANDATORY LANGGRAPH PATTERNS to ENFORCE SEND API COMPLIANCE for ZERO ASYNCIO.GATHER TOLERANCE"
alwaysApply: false
---
# OAMAT LANGGRAPH ARCHITECTURE

**Validation**: "Rule 955 Protocol Active"

## MANDATORY PRE-RESPONSE REQUIREMENTS

**BEFORE ANY OAMAT/LANGGRAPH WORK**:

### 1. **TIME AND DATE CHECK (MANDATORY)**
```python
# REQUIRED: Check current time/date at response start
from mcp_time_current_time import current_time
current_datetime = current_time(format="YYYY-MM-DD HH:mm:ss")
print(f"🕒 LangGraph Session: {current_datetime}")
```

### 2. **ONLINE RESEARCH REQUIREMENT (MANDATORY)**
- **RESEARCH LATEST LANGGRAPH**: API changes, new patterns, deprecations
- **VERIFY SEND API SYNTAX**: Current import paths and usage patterns
- **CHECK CREATE_REACT_AGENT**: Latest function signatures and parameters
- **VALIDATE MODEL COMPATIBILITY**: Confirm model support for features

### 3. **EVIDENCE-BASED ARCHITECTURE (MANDATORY)**
- Base ALL architectural decisions on CURRENT documentation
- Verify pattern compatibility through research
- No assumptions about LangGraph capabilities
- Document reasoning for architectural choices

## Core Principle: Techniques Over Names

**CRITICAL**: This rule focuses on **TECHNIQUES AND METHODS**, not specific class names. Any factory name is acceptable (AgentFactory, LangGraphAgentFactory, etc.) as long as it uses the required LangGraph patterns internally.

## LangGraph Agent Patterns (2025 Current Standards)

**Triggers**: OAMAT agent development, workflow orchestration, multi-agent coordination
**Principles**: create_react_agent patterns, Command routing, Send API parallelism, tool-based handoffs
**Signatures**: Agent factory using create_react_agent, Command objects, simplified contracts, parallel execution
**Validation**: No manual nodes, tool-based routing, type-safe communication, performance optimization
**Integration**: Modern orchestrator compatibility, Pydantic validation, O3 reasoning enhancement

## Modern Agent Creation (MANDATORY PATTERNS)

### Latest LangGraph Imports (2025)
```python
# ✅ CURRENT STANDARD - LangGraph 2025 imports
from langgraph.prebuilt import create_react_agent
from langgraph.constants import Send
from langgraph.graph import StateGraph, START, END
from langgraph.checkpoint.memory import InMemorySaver
from langchain.chat_models import init_chat_model
from pydantic import BaseModel
```

### Factory Pattern (MANDATORY)
```python
# ✅ CORRECT - Use factory with create_react_agent (any factory name acceptable)
class DynamicAgentFactory:
    def __init__(self, model_config: dict):
        # MANDATORY: Must use proper model configuration
        self.model = init_chat_model(
            model_config["model_name"],  # o3-mini or gpt-4.1-mini
            temperature=model_config.get("temperature", 0.1),
            **model_config.get("additional_params", {})
        )

    def create_agent(self, role: AgentRole, tools: list, config: dict):
        # Factory must internally use create_react_agent
        prompt = self._create_prompt_for_role(role)

        # MANDATORY: Must use create_react_agent
        return create_react_agent(
            model=self.model,
            tools=tools,
            prompt=prompt,
            checkpointer=config.get("checkpointer"),
            **config.get("additional_params", {})
        )

# ❌ INCORRECT - Manual node creation without create_react_agent
def create_agent_manually():
    # Manual StateGraph creation without create_react_agent
    return StateGraph(...)  # PROHIBITED
```

### Agent Creation Requirements (MANDATORY)
```python
# ✅ CORRECT - Factory must use create_react_agent internally
def create_agent_with_tools(self, spec: Dict[str, Any]) -> Any:
    tools = self._build_tools_from_spec(spec)
    prompt = self._create_prompt_for_role(spec["role"])

    # MANDATORY: Must use create_react_agent from langgraph.prebuilt
    return create_react_agent(
        model=self.model,
        tools=tools,
        prompt=prompt,
        checkpointer=spec.get("checkpointer")
    )

# ✅ CORRECT - Individual agent creators using create_react_agent
def create_researcher_agent(self, handoff_agents=None):
    tools = [knowledge_search, web_search, academic_search]

    # Dynamic prompt generation (no hardcoded prompts)
    prompt = self._generate_researcher_prompt(handoff_agents)

    # MANDATORY: Must use create_react_agent
    return create_react_agent(
        model=self.model,
        tools=tools,
        prompt=prompt
    )
```

## Command-Based Routing (MANDATORY)

### Dynamic Command Objects (NO HARDCODED ROUTING)
```python
# ✅ DYNAMIC COMMAND GENERATION
@dataclass
class HandoffCommand:
    target_agent: AgentRole
    task_description: str
    context: Dict[str, Any]
    priority: int = 0

    @classmethod
    def generate_from_state(cls, state: OAMATState) -> List['HandoffCommand']:
        """Dynamically generate commands based on current state"""
        # O3 model generates routing decisions dynamically
        routing_response = generate_routing_commands(state)
        return [cls(**cmd) for cmd in routing_response.commands]

# ✅ TOOL-BASED HANDOFF PATTERN
def create_handoff_tool(target_agent: str):
    """Create dynamic handoff tool for agent coordination"""
    return Tool(
        name=f"handoff_to_{target_agent}",
        description=f"Hand off task to {target_agent} agent",
        func=lambda task_description: HandoffCommand(
            target_agent=target_agent,
            task_description=task_description,
            context=get_current_context()
        )
    )

# ❌ HARDCODED ROUTING - PROHIBITED
HARDCODED_ROUTES = {
    "research": "researcher_agent",
    "analyze": "analyzer_agent"
}  # FORBIDDEN
```

### Routing Implementation (DYNAMIC ONLY)
```python
# ✅ CORRECT - Dynamic routing based on O3 analysis
def supervisor_node(state: OAMATState):
    # O3 model analyzes state and determines routing
    routing_analysis = analyze_next_step_with_o3(state)

    # Dynamic command generation
    commands = HandoffCommand.generate_from_state(state)

    # Send API for parallel execution
    return [Send(cmd.target_agent, cmd.create_state()) for cmd in commands]

# ❌ HARDCODED ROUTING - PROHIBITED
def hardcoded_supervisor(state: OAMATState):
    if "research" in state.task:
        return Send("researcher", state)  # FORBIDDEN - hardcoded logic
```

## Parallel Execution (MANDATORY SEND API)

### Send API Usage (ZERO ASYNCIO.GATHER TOLERANCE)
```python
# ✅ CORRECT - Parallel task execution with Send API
from langgraph.constants import Send

def distribute_tasks(state: OAMATState):
    # Dynamically identify parallel tasks
    parallel_tasks = identify_parallel_tasks_dynamically(state)

    # MANDATORY: Use Send API for parallelism
    return [Send(task.agent_id, task.state) for task in parallel_tasks]

# ✅ CORRECT - Dynamic parallel agent orchestration
def create_parallel_workflow(state: OAMATState):
    # O3 determines which agents can work in parallel
    agent_assignments = generate_parallel_assignments(state)

    return [
        Send(assignment.agent_role, assignment.task_state)
        for assignment in agent_assignments
    ]

# ❌ ABSOLUTE PROHIBITION - NEVER USE ASYNCIO.GATHER
async def prohibited_parallel_execution(tasks):
    # FORBIDDEN IN ALL FORMS
    results = await asyncio.gather(*tasks)  # VIOLATION
    return results

# ❌ FORBIDDEN WRAPPER PATTERNS
async def gather_wrapper(tasks):
    return await asyncio.wait_for(asyncio.gather(*tasks), timeout=30)  # PROHIBITED
```

### Performance Gains (3-5x IMPROVEMENT)
```python
# ✅ SEND API PERFORMANCE BENEFITS
def performance_optimized_workflow(state: OAMATState):
    """
    Send API provides 3-5x performance improvement over sequential execution
    through true parallel agent coordination
    """
    # Identify independent tasks
    independent_tasks = analyze_task_dependencies(state)

    # Parallel execution via Send API
    parallel_sends = []
    for task_group in independent_tasks:
        parallel_sends.extend([
            Send(task.agent, task.state) for task in task_group
        ])

    return parallel_sends
```

## Dynamic Configuration (NO HARDCODED VALUES)

### O3-Generated Configuration (MANDATORY)
```python
# ✅ DYNAMIC CONFIG - Generated by O3 model
class DynamicConfigGenerator:
    def __init__(self):
        self.o3_model = init_chat_model("o3-mini")  # Reasoning model

    def generate_agent_config(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """Generate complete agent configuration dynamically"""
        config_prompt = self._create_config_generation_prompt(requirements)

        response = self.o3_model.invoke(config_prompt, response_format=AgentConfigSchema)
        return response.parsed

    def generate_workflow_structure(self, task_description: str) -> WorkflowSchema:
        """Generate entire workflow structure dynamically"""
        workflow_prompt = self._create_workflow_prompt(task_description)

        response = self.o3_model.invoke(workflow_prompt, response_format=WorkflowSchema)
        return response.parsed

# ❌ HARDCODED CONFIG - ABSOLUTELY PROHIBITED
HARDCODED_AGENT_CONFIG = {
    "model": "gpt-4.1-mini",
    "temperature": 0.1,
    "max_tokens": 4000
}  # FORBIDDEN

PREDEFINED_WORKFLOW = {
    "steps": ["research", "analyze", "report"]
}  # PROHIBITED
```

## Simplified Contracts (PYDANTIC VALIDATION)

### Type-Safe Communication (DYNAMIC SCHEMAS)
```python
# ✅ DYNAMIC PYDANTIC MODELS
class ResearchInput(BaseModel):
    task_description: str
    topic: str
    depth: ResearchDepth = ResearchDepth.STANDARD
    dynamic_parameters: Dict[str, Any] = {}

    @classmethod
    def generate_from_request(cls, request: str) -> 'ResearchInput':
        """Dynamically generate input schema from request"""
        # O3 analyzes request and generates appropriate schema
        schema_response = generate_input_schema(request)
        return cls(**schema_response.parameters)

# ✅ DYNAMIC CONTRACT VALIDATION
class ContractValidator:
    @staticmethod
    def validate_input(agent_role: AgentRole, raw_data: Dict[str, Any]) -> BaseModel:
        """Generate and validate contracts dynamically"""
        # Generate appropriate schema based on agent role and data
        schema_class = generate_schema_for_agent(agent_role, raw_data)
        return schema_class(**raw_data)

# ❌ HARDCODED CONTRACTS - PROHIBITED
FIXED_CONTRACT = {
    "input_fields": ["task", "context"],
    "output_fields": ["result", "confidence"]
}  # FORBIDDEN
```

## Model Configuration (MANDATORY CONSTRAINTS)

### O3 Reasoning Integration (MANDATORY)
```python
# ✅ MANDATORY MODEL CONFIGURATION
class ModelConfigManager:
    MANDATORY_MODELS = {
        "reasoning": "o3-mini",     # REQUIRED for reasoning workflows
        "execution": "gpt-4.1-mini" # REQUIRED for agent implementation
    }

    def create_reasoning_model(self) -> Any:
        """Create O3 model for complex planning and reasoning"""
        return init_chat_model(
            self.MANDATORY_MODELS["reasoning"],
            temperature=0.1,
            max_tokens=4000
        )

    def create_execution_model(self) -> Any:
        """Create execution model for agent operations"""
        return init_chat_model(
            self.MANDATORY_MODELS["execution"],
            temperature=0.2,
            max_tokens=2000
        )

# ✅ MANAGER AGENT WITH O3 ENHANCEMENT
def create_manager_agent():
    # Manager agent uses O3 for complex planning
    manager_config = ModelConfigManager().create_reasoning_model()

    return create_react_agent(
        model=manager_config,
        tools=planning_tools,
        prompt=generate_manager_prompt()
    )

# ❌ HARDCODED MODEL SELECTION - PROHIBITED
FIXED_MODEL = "gpt-4"  # FORBIDDEN
```

## Anti-Pattern Detection (ZERO TOLERANCE)

### Prohibited Patterns (IMMEDIATE VIOLATION)
```python
# ❌ IMMEDIATE CONTRACT VIOLATIONS
# 1. Manual agent node creation (must use create_react_agent)
def manual_agent_creation():
    graph = StateGraph(AgentState)  # PROHIBITED
    graph.add_node("agent", agent_function)  # VIOLATION
    return graph.compile()

# 2. asyncio.gather usage (use Send API)
async def gather_violation():
    await asyncio.gather(task1, task2)  # FORBIDDEN

# 3. Hardcoded workflow patterns
PREDEFINED_WORKFLOW = ["step1", "step2"]  # PROHIBITED

# 4. Template-based agent creation
def template_agent():
    return AgentTemplate.create("researcher")  # FORBIDDEN

# 5. Manual state routing
def manual_routing(state):
    if condition:
        return "agent1"  # PROHIBITED - use dynamic routing
```

## Integration Checklist (MANDATORY COMPLIANCE)

- [ ] Time/date checked at response start
- [ ] Online research conducted for LangGraph updates
- [ ] Evidence-based architectural decisions documented
- [ ] Agent factory uses create_react_agent internally (factory name irrelevant)
- [ ] Command objects for dynamic routing decisions
- [ ] Send API for parallel execution (zero asyncio.gather)
- [ ] Simplified contracts with Pydantic validation
- [ ] Tool-based handoffs between agents
- [ ] O3 reasoning model for manager agent (o3-mini)
- [ ] Execution models use gpt-4.1-mini
- [ ] Dynamic configuration generation (no hardcoded values)
- [ ] Error handling with graceful degradation
- [ ] Performance monitoring and optimization
- [ ] Git commits before and after changes
- [ ] Evidence-based validation of all patterns

## Modern Orchestration Requirements

**Required Techniques** (implementation names flexible):
- **Agent Creation**: create_react_agent with tool binding (mandatory)
- **Communication**: Type-safe Pydantic models (dynamically generated)
- **Performance**: Send API parallelism optimization (3-5x gains)
- **Intelligence**: O3 reasoning for complex planning decisions
- **Validation**: Focus on patterns and methods, not class/function names
- **Configuration**: Dynamic generation via O3, zero hardcoded values
- **Routing**: Command-based dynamic routing, no predefined paths

**ZERO TOLERANCE FOR VIOLATIONS - IMMEDIATE ENFORCEMENT REQUIRED**
