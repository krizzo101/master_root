---
description: "use when BUILDING LANGGRAPH WORKFLOWS to ENFORCE STATE MANAGEMENT for AGENT ORCHESTRATION"
globs:
alwaysApply: false
---

# LANGGRAPH TECHNICAL GUIDELINES 2025

**Validation**: "Rule 950 Protocol Active"

## Enterprise Platform (July 2025)

**Triggers**: Multi-agent workflows, persistent state management, production deployment, AWS integration
**Principles**: LangGraph Platform deployment, stateful orchestration, enterprise scalability, cloud-native patterns
**Signatures**: AWS Marketplace integration, persistent checkpointing, bursty traffic handling, multi-agent coordination
**Validation**: Production deployment success, state persistence verification, scaling effectiveness
**Integration**: Enterprise compliance, hybrid deployment, self-hosted options

## LangGraph Platform Architecture

**AWS Marketplace Deployment** (Available July 2025):
```python
from langgraph.platform import LangGraphPlatform
from langgraph.checkpoint.postgres import PostgresCheckpointer

# Enterprise platform configuration
platform = LangGraphPlatform(
    deployment="aws-marketplace",
    scaling="auto",
    state_persistence=True,
    checkpointer=PostgresCheckpointer("postgresql://...")
)
```

**Long-Running Agent Workloads**:
```python
from langgraph.graph import StateGraph
from langgraph.prebuilt import create_react_agent

class AgentState(TypedDict):
    messages: List[dict]
    context: dict
    persistent_data: dict

# Production-grade agent with state
graph = StateGraph(AgentState)
graph.add_node("agent", create_react_agent(model, tools))
graph.add_edge("START", "agent")
```

## Stateful Multi-Actor Patterns

**Persistent State Management**:
```python
# Thread-based persistence
config = {"configurable": {"thread_id": "user_session_123"}}

# Long-term memory
response = app.invoke(
    {"messages": [{"role": "user", "content": "Remember this context"}]},
    config=config
)
```

**Asynchronous Collaboration**:
```python
from langgraph.constants import Send

# Multi-agent coordination
def distribute_work(state):
    tasks = split_complex_task(state["input"])
    return [Send("specialist_agent", task) for task in tasks]
```

## Production Deployment Options

**SaaS**: Fully managed LangGraph Platform
**Hybrid**: Compliance-aware partial cloud deployment
**Self-Hosted**: Complete on-premises control
**1-Click GitHub Integration**: Automated CI/CD pipeline

## Cyclic Workflow Patterns

**Dynamic Branching**:
```python
def conditional_edge(state):
    if state["needs_research"]:
        return "research_agent"
    elif state["needs_analysis"]:
        return "analysis_agent"
    else:
        return "END"

graph.add_conditional_edges("coordinator", conditional_edge)
```

## Success Indicators

- ✅ **LangGraph Platform** deployment ready
- ✅ **AWS Marketplace** integration complete
- ✅ **Persistent state** across sessions
- ✅ **Multi-agent coordination** operational
- ✅ **Production scaling** validated

[langgraph-patterns.md](mdc:.cursor/templates/langgraph-patterns.md)
