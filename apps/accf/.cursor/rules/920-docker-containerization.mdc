---
description: "use when CONTAINERIZING APPLICATIONS to IMPLEMENT SECURE MULTI-STAGE BUILDS for PRODUCTION DEPLOYMENT"
globs: ["Dockerfile", "*.Dockerfile"]
alwaysApply: false
---
# Dockerfile Best Practices

## Base Image
- Use official, minimal images: `python:3.11-slim`, `node:18-alpine`, `golang:1.22-alpine`.
- Pin digest for reproducibility.

## Layers & Caching
- Order instructions least→most changing.
- Combine `RUN` commands and clean caches:
  ```dockerfile
  RUN apt-get update && apt-get install -y build-essential           && rm -rf /var/lib/apt/lists/*
  ```

## Multi‑Stage Template
```dockerfile
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=build /app/dist ./dist
COPY --from=build /app/node_modules ./node_modules
RUN adduser -D app && chown -R app /app
USER app
EXPOSE 3000
CMD ["node","dist/index.js"]
```

## Security
- Run as non‑root (`USER app`).
- No secrets in image; pass via env/secret store.
- Scan with **Trivy** in CI.

## Misc
- `.dockerignore` to exclude node_modules, tests, docs.

# Docker Containerization Standards (Optimized for GPT-4.1)

- Clarity & Directness: Use clear, imperative instructions.
- Batching & Parallelization: Batch compatible containerization steps; execute in parallel where possible.
- Multi-Step Planning: Plan several steps ahead, identify batching opportunities, and optimize for efficiency.
- Persistent Autonomy: Continue until all objectives are met or explicitly told to stop; avoid unnecessary waiting for input.
- Tool-First Mandate: Always use available tools for every operation, preferring tool-based actions.
- Self-Review & Optimization: Review and revise plans for efficiency before acting.
- Evidence-Based Completion: Present clear evidence of completion before considering a task done.
