---
description: "use when CALLING TOOLS to VALIDATE OPERATION SUCCESS AND PREVENT SILENT FAILURES for RELIABLE EXECUTION"
globs:
alwaysApply: false
---
# TOOL OPERATION VALIDATION

### Pre-Operation Validation
```python
def validate_before_operation(tool_name, parameters):
    validation_checks = {
        "parameter_completeness": check_required_parameters(parameters),
        "parameter_validity": validate_parameter_values(parameters),
        "tool_availability": verify_tool_accessibility(tool_name),
        "preconditions": check_operation_preconditions(tool_name, parameters)
    }

    if not all(validation_checks.values()):
        raise ValidationError(f"Pre-operation validation failed: {validation_checks}")
```

### Post-Operation Validation
```python
def validate_after_operation(tool_result, expected_outcome):
    validation_results = {
        "operation_success": check_operation_success(tool_result),
        "result_completeness": validate_result_completeness(tool_result),
        "result_quality": assess_result_quality(tool_result),
        "expected_outcome": compare_with_expected(tool_result, expected_outcome)
    }

    return validation_results
```

## TOOL-SPECIFIC VALIDATION PATTERNS

### Database Operations
```python
# AQL Query Validation
def validate_aql_operation(query_result):
    return {
        "syntax_valid": check_aql_syntax(query_result),
        "data_returned": len(query_result) > 0 if expected_data else True,
        "id_field_present": "_id" in query_result[0] if query_result else True,
        "no_mcp_errors": "error" not in str(query_result)
    }

# Database Insert Validation
def validate_insert_operation(insert_result):
    return {
        "insert_successful": "_id" in insert_result,
        "no_errors": "error" not in str(insert_result),
        "id_format_valid": validate_arango_id_format(insert_result.get("_id"))
    }
```

### File Operations
```python
# File Read Validation
def validate_file_read(file_content, file_path):
    return {
        "file_exists": file_content is not None,
        "content_not_empty": len(file_content) > 0 if file_content else False,
        "encoding_valid": validate_utf8_encoding(file_content),
        "path_accessible": check_file_accessibility(file_path)
    }

# File Write Validation
def validate_file_write(write_result, expected_content):
    return {
        "write_successful": "Successfully wrote" in str(write_result),
        "no_errors": "error" not in str(write_result).lower(),
        "content_matches": verify_written_content(expected_content)
    }
```

### Web Operations
```python
# Web Scraping Validation
def validate_web_scraping(scraping_result):
    return {
        "request_successful": scraping_result.get("success", False),
        "content_retrieved": len(scraping_result.get("markdown", "")) > 0,
        "no_rate_limits": "rate limit" not in str(scraping_result).lower(),
        "valid_response": validate_response_structure(scraping_result)
    }

# Web Search Validation
def validate_web_search(search_results):
    return {
        "results_returned": len(search_results) > 0,
        "valid_structure": validate_search_result_structure(search_results),
        "no_errors": not any("error" in str(result) for result in search_results),
        "relevant_content": assess_search_relevance(search_results)
    }
```

### Shell Operations
```python
# Shell Command Validation
def validate_shell_operation(command_result, expected_exit_code=0):
    return {
        "command_executed": command_result is not None,
        "exit_code_valid": command_result.get("exit_code") == expected_exit_code,
        "no_errors": "error" not in str(command_result).lower(),
        "output_present": len(command_result.get("output", "")) > 0
    }
```

## ERROR DETECTION PATTERNS

### Silent Failure Detection
```python
def detect_silent_failures(tool_result, operation_context):
    silent_failure_indicators = {
        "empty_expected_data": check_unexpected_empty_results(tool_result, operation_context),
        "partial_execution": detect_incomplete_operations(tool_result, operation_context),
        "timeout_without_error": check_timeout_conditions(tool_result),
        "resource_unavailable": detect_resource_issues(tool_result)
    }

    return any(silent_failure_indicators.values())
```

### Error Classification
```python
def classify_operation_error(error_result):
    error_types = {
        "syntax_error": check_syntax_errors(error_result),
        "permission_error": check_permission_issues(error_result),
        "resource_error": check_resource_availability(error_result),
        "network_error": check_network_issues(error_result),
        "timeout_error": check_timeout_issues(error_result)
    }

    return {error_type: present for error_type, present in error_types.items() if present}
```

## VALIDATION RESPONSE PROTOCOLS

### Success Validation Response
```python
def handle_validation_success(tool_result, validation_results):
    if all(validation_results.values()):
        document_successful_operation(tool_result, validation_results)
        return proceed_with_operation_result(tool_result)
    else:
        return handle_partial_validation_success(tool_result, validation_results)
```

### Failure Response Protocol
```python
def handle_validation_failure(tool_result, validation_results):
    failure_response = {
        "stop_operation": True,
        "analyze_failure": analyze_validation_failures(validation_results),
        "apply_corrections": generate_correction_strategy(validation_results),
        "retry_with_corrections": prepare_retry_operation(tool_result, validation_results)
    }

    return execute_failure_response_protocol(failure_response)
```

## COMPOUND VALIDATION

### Multi-Tool Operation Validation
```python
def validate_compound_operation(tool_results_sequence):
    compound_validation = {
        "all_tools_successful": all(validate_individual_tool(result) for result in tool_results_sequence),
        "sequence_integrity": validate_operation_sequence(tool_results_sequence),
        "compound_outcome": validate_compound_outcome(tool_results_sequence),
        "no_cascade_failures": detect_cascade_failures(tool_results_sequence)
    }

    return compound_validation
```

### Orchestration Validation
```python
def validate_orchestration_quality(orchestration_results):
    orchestration_validation = {
        "parallel_execution_successful": validate_parallel_operations(orchestration_results),
        "sequential_dependencies_met": validate_sequential_operations(orchestration_results),
        "error_handling_effective": validate_error_handling(orchestration_results),
        "performance_acceptable": validate_performance_metrics(orchestration_results)
    }

    return orchestration_validation
```

## BEHAVIORAL REQUIREMENTS

### Mandatory Validation Standards
- **NEVER proceed** without validating tool operation success
- **ALWAYS check** for silent failures and partial execution
- **IMMEDIATELY stop** when validation failures detected
- **SYSTEMATICALLY retry** with corrections after validation failures

### Continuous Validation Improvement
- Monitor validation effectiveness over time
- Refine validation criteria based on failure patterns
- Develop domain-specific validation approaches
- Document successful validation patterns

## INTEGRATION WITH OPERATIONAL TOOLS

**Reference**: Use `mcp_cognitive_tools_arango_search(collection="shared_references", content="tool usage enforcement")` for operational tool requirements

### Automated Validation Integration
- Use autonomous systems validation tools when available
- Apply mistake prevention systems for critical operations
- Integrate with session continuity for operation tracking
- Document validation results in knowledge management system

# Tool Operation Validation
- Clarity & Directness: Use clear, imperative instructions.
- Batching & Parallelization: Batch compatible validation steps; execute in parallel where possible.
- Multi-Step Planning: Plan several steps ahead, identify batching opportunities, and optimize for efficiency.
- Persistent Autonomy: Continue until all objectives are met or explicitly told to stop; avoid unnecessary waiting for input.
- Tool-First Mandate: Always use available tools for every operation, preferring tool-based actions.
- Self-Review & Optimization: Review and revise plans for efficiency before acting.
- Evidence-Based Completion: Present clear evidence of completion before considering a task done.
