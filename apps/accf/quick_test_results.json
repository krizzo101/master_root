{
  "timestamp": "2025-07-30T14:18:33.155574",
  "test_prompt": "\nDesign a simple REST API for a todo list application. Include:\n1. API endpoints for CRUD operations\n2. Basic data model\n3. Error handling\n4. Simple authentication\n",
  "results": {
    "o4-mini": {
      "model": "o4-mini",
      "success": true,
      "response": "```python\n#!/usr/bin/env python3\n\"\"\"\nSimple REST API for a Todo List application using FastAPI and SQLite.\n\nFeatures:\n- CRUD operations for Todo items\n- SQLite-backed data model via SQLAlchemy ORM\n- Basic API key authentication\n- Error handling with HTTP status codes\n- Logging and configuration via environment variables\n\"\"\"\n\nimport os\nimport logging\nfrom typing import List, Generator, Optional\n\nfrom fastapi import FastAPI, Depends, HTTPException, Header, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import (\n    create_engine,\n    Column,\n    Integer,\n    String,\n    Boolean,\n    Text,\n)\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\n# -----------------------------------------------------------------------------\n# Configuration\n# -----------------------------------------------------------------------------\n\nAPI_KEY = os.getenv(\"API_KEY\", \"secret-key\")  # In production, set via env var\nAPI_KEY_HEADER = \"X-API-Key\"\n\nSQLALCHEMY_DATABASE_URL = os.getenv(\n    \"DATABASE_URL\", \"sqlite:///./todos.db\"\n)\n\n# -----------------------------------------------------------------------------\n# Logging Configuration\n# -----------------------------------------------------------------------------\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(\"todo_api\")\n\n# -----------------------------------------------------------------------------\n# Database Setup\n# -----------------------------------------------------------------------------\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n\nclass TodoORM(Base):\n    \"\"\"\n    SQLAlchemy ORM model for a Todo item.\n    \"\"\"\n    __tablename__ = \"todos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(128), nullable=False)\n    description = Column(Text, nullable=True)\n    completed = Column(Boolean, default=False, nullable=False)\n\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n\n# -----------------------------------------------------------------------------\n# Pydantic Schemas\n# -----------------------------------------------------------------------------\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., example=\"Buy groceries\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs\")\n    completed: bool = Field(False, example=False)\n\n\nclass TodoCreate(TodoBase):\n    \"\"\"\n    Schema for creating a new Todo.\n    \"\"\"\n    pass\n\n\nclass TodoUpdate(BaseModel):\n    \"\"\"\n    Schema for updating an existing Todo.\n    All fields are optional.\n    \"\"\"\n    title: Optional[str] = Field(None, example=\"Buy groceries and fruits\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs, Apples\")\n    completed: Optional[bool] = Field(None, example=True)\n\n\nclass TodoInDB(TodoBase):\n    \"\"\"\n    Schema representing a Todo stored in the database.\n    \"\"\"\n    id: int\n\n    class Config:\n        orm_mode = True\n\n\n# -----------------------------------------------------------------------------\n# FastAPI Initialization\n# -----------------------------------------------------------------------------\n\napp = FastAPI(\n    title=\"Todo List API\",\n    description=\"A simple REST API for managing todo items.\",\n    version=\"1.0.0\",\n)\n\n\n# -----------------------------------------------------------------------------\n# Dependencies\n# -----------------------------------------------------------------------------\n\ndef get_db() -> Generator[Session, None, None]:\n    \"\"\"\n    Dependency that provides a SQLAlchemy database session.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n\ndef verify_api_key(x_api_key: str = Header(..., alias=API_KEY_HEADER)) -> None:\n    \"\"\"\n    Dependency that verifies the provided API key.\n    Raises 401 Unauthorized if the key is invalid.\n    \"\"\"\n    if x_api_key != API_KEY:\n        logger.warning(\"Unauthorized access attempt with API key: %s\", x_api_key)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid API Key\",\n            headers={\"WWW-Authenticate\": \"API Key\"},\n        )\n\n\n# -----------------------------------------------------------------------------\n# API Endpoints\n# -----------------------------------------------------------------------------\n\n@app.post(\n    \"/todos/\",\n    response_model=TodoInDB,\n    status_code=status.HTTP_201_CREATED,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Create a new todo\",\n)\ndef create_todo(\n    todo_in: TodoCreate,\n    db: Session = Depends(get_db),\n) -> TodoInDB:\n    \"\"\"\n    Create a new todo item.\n    \"\"\"\n    todo = TodoORM(**todo_in.dict())\n    try:\n        db.add(todo)\n        db.commit()\n        db.refresh(todo)\n        logger.info(\"Created todo with id %d\", todo.id)\n        return todo\n    except SQLAlchemyError as e:\n        db.rollback()\n        logger.error(\"Database error on create_todo: %s\", e)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal Server Error\",\n        )\n\n\n@app.get(\n    \"/todos/\",\n    response_model=List[TodoInDB],\n    dependencies=[Depends(verify_api_key)],\n    summary=\"List all todos\",\n)\ndef read_todos(\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db),\n) -> List[TodoInDB]:\n    \"\"\"\n    Retrieve a list of todo items.\n    \"\"\"\n    todos = db.query(TodoORM).offset(skip).limit(limit).all()\n    logger.info(\"Retrieved %d todos\", len(todos))\n    return todos\n\n\n@app.get(\n    \"/todos/{todo_id}\",\n    response_model=TodoInDB,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Get a todo by ID\",\n)\ndef read_todo(\n    todo_id: int,\n    db: Session = Depends(get_db),\n) -> TodoInDB:\n    \"\"\"\n    Retrieve a single todo item by its ID.\n    \"\"\"\n    todo = db.query(TodoORM).get(todo_id)\n    if not todo:\n        logger.warning(\"Todo id %d not found\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    logger.info(\"Retrieved todo with id %d\", todo_id)\n    return todo\n\n\n@app.put(\n    \"/todos/{todo_id}\",\n    response_model=TodoInDB,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Update a todo\",\n)\ndef update_todo(\n    todo_id: int,\n    todo_in: TodoUpdate,\n    db: Session = Depends(get_db),\n) -> TodoInDB:\n    \"\"\"\n    Update an existing todo item.\n    \"\"\"\n    todo = db.query(TodoORM).get(todo_id)\n    if not todo:\n        logger.warning(\"Todo id %d not found for update\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    update_data = todo_in.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(todo, field, value)\n    try:\n        db.add(todo)\n        db.commit()\n        db.refresh(todo)\n        logger.info(\"Updated todo with id %d\", todo_id)\n        return todo\n    except SQLAlchemyError as e:\n        db.rollback()\n        logger.error(\"Database error on update_todo: %s\", e)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal Server Error\",\n        )\n\n\n@app.delete(\n    \"/todos/{todo_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Delete a todo\",\n)\ndef delete_todo(\n    todo_id: int,\n    db: Session = Depends(get_db),\n) -> JSONResponse:\n    \"\"\"\n    Delete a todo item by its ID.\n    \"\"\"\n    todo = db.query(TodoORM).get(todo_id)\n    if not todo:\n        logger.warning(\"Todo id %d not found for delete\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    try:\n        db.delete(todo)\n        db.commit()\n        logger.info(\"Deleted todo with id %d\", todo_id)\n        return JSONResponse(status_code=status.HTTP_204_NO_CONTENT, content=None)\n    except SQLAlchemyError as e:\n        db.rollback()\n        logger.error(\"Database error on delete_todo: %s\", e)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Internal Server Error\",\n        )\n\n\n# -----------------------------------------------------------------------------\n# Exception Handlers\n# -----------------------------------------------------------------------------\n\n@app.exception_handler(Exception)\ndef global_exception_handler(request, exc: Exception):\n    \"\"\"\n    Catch-all exception handler to ensure internal errors are not leaked.\n    \"\"\"\n    logger.exception(\"Unhandled exception: %s\", exc)\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal Server Error\"},\n    )\n\n\n# -----------------------------------------------------------------------------\n# Application Entry Point\n# -----------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    uvicorn.run(\n        \"main:app\",\n        host=\"0.0.0.0\",\n        port=int(os.getenv(\"PORT\", 8000)),\n        log_level=\"info\",\n    )\n```\n\nInstructions:\n1. Install dependencies:\n   `pip install fastapi uvicorn sqlalchemy pydantic`\n2. Optionally set environment variables:\n   - `API_KEY`: API Key for authentication (default: `secret-key`)\n   - `DATABASE_URL`: Database connection URL (default: SQLite file `./todos.db`)\n3. Run the application:\n   `python main.py`\n\nThe API will be available at `http://localhost:8000`. Interactive documentation at `http://localhost:8000/docs`.\n\n=== DEBUG DETAILS ===\n- Critic review skipped: critic agent not initialized or not enabled.\n=== END DEBUG DETAILS ===\n",
      "response_length": 9982
    },
    "o3": {
      "model": "o3",
      "success": true,
      "response": "```python\n#!/usr/bin/env python3\n\"\"\"\ntodo_api.py\n\nA minimal yet production-ready Todo List REST API built with FastAPI and SQLite.\n\nFeatures\n--------\n1. CRUD endpoints for Todo items\n2. SQLite data model via SQLAlchemy ORM\n3. Centralised error handling & structured logging\n4. Very simple API-Key based authentication\n\nQuick-start\n-----------\n1. Install dependencies:\n       pip install fastapi uvicorn sqlalchemy pydantic python-dotenv\n\n2. (Optional) Create a `.env` file or export environment variables:\n       API_KEY=change-me\n       DATABASE_URL=sqlite:///./todos.db\n       PORT=8000\n\n3. Run the service:\n       python todo_api.py\n   or\n       uvicorn todo_api:app --host 0.0.0.0 --port 8000\n\nInteractive documentation is available at http://localhost:8000/docs\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, List, Optional\n\nfrom dotenv import load_dotenv\nfrom fastapi import (\n    Depends,\n    FastAPI,\n    Header,\n    HTTPException,\n    Request,\n    Response,\n    status,\n)\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import Boolean, Column, Integer, String, Text, create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\n\n# ------------------------------------------------------------------------------\n# Environment & logging configuration\n# ------------------------------------------------------------------------------\n\nload_dotenv()  # Safely ignore if no .env file is present\n\nAPI_KEY: str = os.getenv(\"API_KEY\", \"secret-key\")\nAPI_KEY_HEADER = \"X-API-Key\"\nDATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"sqlite:///./todos.db\")\nSERVER_PORT: int = int(os.getenv(\"PORT\", 8000))\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(\"todo_api\")\n\n# ------------------------------------------------------------------------------\n# Database setup\n# ------------------------------------------------------------------------------\n\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False} if DATABASE_URL.startswith(\"sqlite\") else {},\n    pool_pre_ping=True,\n)\nSessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)\nBase = declarative_base()\n\n\nclass TodoORM(Base):\n    \"\"\"\n    SQLAlchemy ORM model representing a Todo item.\n    \"\"\"\n\n    __tablename__ = \"todos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(128), nullable=False)\n    description = Column(Text, nullable=True)\n    completed = Column(Boolean, default=False, nullable=False)\n\n\n# Create tables if they do not exist\nBase.metadata.create_all(bind=engine)\n\n# ------------------------------------------------------------------------------\n# Pydantic schemas\n# ------------------------------------------------------------------------------\n\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., example=\"Buy groceries\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs\")\n    completed: bool = Field(False, example=False)\n\n\nclass TodoCreate(TodoBase):\n    \"\"\"\n    Schema for creating a new Todo.\n    \"\"\"\n\n    pass\n\n\nclass TodoUpdate(BaseModel):\n    \"\"\"\n    Schema for updating an existing Todo.\n    All fields are optional; only supplied fields will be updated.\n    \"\"\"\n\n    title: Optional[str] = Field(None, example=\"Buy groceries and fruits\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs, Apples\")\n    completed: Optional[bool] = Field(None, example=True)\n\n\nclass TodoOut(TodoBase):\n    \"\"\"\n    Schema returned in API responses.\n    \"\"\"\n\n    id: int\n\n    class Config:\n        orm_mode = True\n\n\n# ------------------------------------------------------------------------------\n# FastAPI initialisation\n# ------------------------------------------------------------------------------\n\napp = FastAPI(\n    title=\"Todo List API\",\n    version=\"1.0.0\",\n    description=\"A simple, fully-typed REST API for managing Todo items.\",\n)\n\n\n# ------------------------------------------------------------------------------\n# Dependency helpers\n# ------------------------------------------------------------------------------\n\n\n@contextmanager\ndef db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Context manager / dependency that yields a SQLAlchemy session\n    and guarantees closure, rolling back on exceptions.\n    \"\"\"\n    db: Session = SessionLocal()\n    try:\n        yield db\n        db.commit()\n    except Exception:\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\n\ndef get_db() -> Generator[Session, None, None]:\n    with db_session() as db:\n        yield db\n\n\ndef verify_api_key(x_api_key: str = Header(..., alias=API_KEY_HEADER)) -> None:\n    \"\"\"\n    Dependency to enforce a simple API-Key header.\n    Raises 401 if the supplied key does not match expected `API_KEY`.\n    \"\"\"\n    if x_api_key != API_KEY:\n        logger.warning(\"Unauthorized access attempt with api key: %s\", x_api_key)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or missing API key\",\n        )\n\n\n# ------------------------------------------------------------------------------\n# CRUD Endpoints\n# ------------------------------------------------------------------------------\n\n@app.post(\n    \"/todos\",\n    response_model=TodoOut,\n    status_code=status.HTTP_201_CREATED,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Create a new Todo\",\n)\ndef create_todo(todo_in: TodoCreate, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Create a new Todo item.\n    \"\"\"\n    todo = TodoORM(**todo_in.dict())\n    try:\n        db.add(todo)\n        db.flush()  # ensure PK is generated\n        logger.info(\"Created todo (id=%s)\", todo.id)\n        return todo  # noqa: R504\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error during create_todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create Todo\",\n        ) from exc\n\n\n@app.get(\n    \"/todos\",\n    response_model=List[TodoOut],\n    dependencies=[Depends(verify_api_key)],\n    summary=\"List all Todos\",\n)\ndef list_todos(\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db),\n) -> List[TodoOut]:\n    \"\"\"\n    Retrieve a paginated list of Todo items.\n    \"\"\"\n    todos = db.query(TodoORM).offset(skip).limit(limit).all()\n    logger.debug(\"Retrieved %d todos [skip=%d, limit=%d]\", len(todos), skip, limit)\n    return todos\n\n\n@app.get(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Get a Todo by ID\",\n)\ndef get_todo(todo_id: int, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Retrieve a single Todo item.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if todo is None:\n        logger.info(\"Todo not found (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo\n\n\n@app.put(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Update a Todo\",\n)\ndef update_todo(\n    todo_id: int,\n    todo_in: TodoUpdate,\n    db: Session = Depends(get_db),\n) -> TodoOut:\n    \"\"\"\n    Update an existing Todo item.\n    Only supplied fields are updated.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if todo is None:\n        logger.info(\"Todo not found for update (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n\n    for field, value in todo_in.dict(exclude_unset=True).items():\n        setattr(todo, field, value)\n\n    try:\n        db.add(todo)\n        logger.info(\"Updated todo (id=%s)\", todo_id)\n        return todo  # noqa: R504\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error during update_todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to update Todo\",\n        ) from exc\n\n\n@app.delete(\n    \"/todos/{todo_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Delete a Todo\",\n)\ndef delete_todo(todo_id: int, db: Session = Depends(get_db)) -> Response:\n    \"\"\"\n    Delete a Todo item. Returns 204 No Content on success.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if todo is None:\n        logger.info(\"Todo not found for delete (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n\n    try:\n        db.delete(todo)\n        logger.info(\"Deleted todo (id=%s)\", todo_id)\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error during delete_todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete Todo\",\n        ) from exc\n\n\n# ------------------------------------------------------------------------------\n# Global exception handler\n# ------------------------------------------------------------------------------\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Catch-all exception handler to avoid leaking internal errors & stack traces.\n    \"\"\"\n    logger.exception(\"Unhandled exception: %s\", exc)\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal Server Error\"},\n    )\n\n\n# ------------------------------------------------------------------------------\n# Optional: Run via `python todo_api.py`\n# ------------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    logger.info(\"Starting Todo API on port %d\", SERVER_PORT)\n    uvicorn.run(\n        \"todo_api:app\",\n        host=\"0.0.0.0\",\n        port=SERVER_PORT,\n        log_level=\"info\",\n        reload=False,\n    )\n```\n\n=== DEBUG DETAILS ===\n- Critic review skipped: critic agent not initialized or not enabled.\n=== END DEBUG DETAILS ===\n",
      "response_length": 10435
    },
    "gpt-4.1-mini": {
      "model": "gpt-4.1-mini",
      "success": true,
      "response": "```python\n#!/usr/bin/env python3\n\"\"\"\ntodo_api.py\n\nA simple, production-ready REST API for a Todo List application using FastAPI with SQLite.\nFeatures:\n- CRUD endpoints for todo items\n- SQLite data model using SQLAlchemy ORM\n- Centralized error handling and structured logging\n- Simple API key authentication via header\n\nSetup:\n1. Install dependencies:\n   pip install fastapi uvicorn sqlalchemy pydantic python-dotenv\n\n2. (Optional) Configure environment variables (.env or system environment):\n   - API_KEY: API key string for authentication (default: \"secret-key\")\n   - DATABASE_URL: SQLAlchemy database URL (default: sqlite:///./todos.db)\n   - PORT: Server port (default: 8000)\n\n3. Run the application:\n   python todo_api.py\n   or\n   uvicorn todo_api:app --host 0.0.0.0 --port 8000\n\nAPI docs available at: http://localhost:8000/docs\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, List, Optional\n\nfrom dotenv import load_dotenv\nfrom fastapi import Depends, FastAPI, Header, HTTPException, Request, Response, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import Boolean, Column, Integer, String, Text, create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\n\n# -------------------------------------------------------------------\n# Environment and Logging Configuration\n# -------------------------------------------------------------------\n\nload_dotenv()  # Load environment variables from a .env file if present\n\nAPI_KEY: str = os.getenv(\"API_KEY\", \"secret-key\")\nAPI_KEY_HEADER = \"X-API-Key\"\nDATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"sqlite:///./todos.db\")\nSERVER_PORT: int = int(os.getenv(\"PORT\", \"8000\"))\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(\"todo_api\")\n\n# -------------------------------------------------------------------\n# Database Setup\n# -------------------------------------------------------------------\n\n# When using SQLite, need to disable check_same_thread to allow multithreading concurrency in FastAPI\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False} if DATABASE_URL.startswith(\"sqlite\") else {},\n    pool_pre_ping=True,\n)\nSessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)\nBase = declarative_base()\n\n\nclass TodoORM(Base):\n    \"\"\"\n    SQLAlchemy ORM model for a Todo item.\n    \"\"\"\n    __tablename__ = \"todos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(128), nullable=False)\n    description = Column(Text, nullable=True)\n    completed = Column(Boolean, nullable=False, default=False)\n\n\n# Create database tables on startup if they don't exist\nBase.metadata.create_all(bind=engine)\n\n# -------------------------------------------------------------------\n# Pydantic Schemas\n# -------------------------------------------------------------------\n\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., example=\"Buy groceries\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs\")\n    completed: bool = Field(False, example=False)\n\n\nclass TodoCreate(TodoBase):\n    \"\"\"\n    Schema for creating a Todo.\n    \"\"\"\n    pass\n\n\nclass TodoUpdate(BaseModel):\n    \"\"\"\n    Schema for updating a Todo.\n    All fields are optional; only provided fields will be updated.\n    \"\"\"\n    title: Optional[str] = Field(None, example=\"Buy groceries and fruits\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs, Apples\")\n    completed: Optional[bool] = Field(None, example=True)\n\n\nclass TodoOut(TodoBase):\n    \"\"\"\n    Schema for returning a Todo.\n    \"\"\"\n    id: int\n\n    class Config:\n        orm_mode = True\n\n\n# -------------------------------------------------------------------\n# FastAPI App Initialization\n# -------------------------------------------------------------------\n\napp = FastAPI(\n    title=\"Todo List API\",\n    version=\"1.0.0\",\n    description=\"A simple REST API for managing todo items with CRUD operations and basic API key authentication.\",\n)\n\n\n# -------------------------------------------------------------------\n# Dependency Helpers\n# -------------------------------------------------------------------\n\n@contextmanager\ndef db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    Automatically commits if no exceptions raised, otherwise rollbacks.\n    Ensures database session is closed.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n        db.commit()\n    except Exception:\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\n\ndef get_db() -> Generator[Session, None, None]:\n    \"\"\"\n    FastAPI dependency to get a database session.\n    \"\"\"\n    with db_session() as db:\n        yield db\n\n\ndef verify_api_key(x_api_key: str = Header(..., alias=API_KEY_HEADER)) -> None:\n    \"\"\"\n    Simple API key verification dependency.\n    Raises HTTP 401 if invalid or missing.\n    \"\"\"\n    if x_api_key != API_KEY:\n        logger.warning(\"Unauthorized access attempt with API key: %s\", x_api_key)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or missing API key\",\n            headers={\"WWW-Authenticate\": \"API Key\"},\n        )\n\n\n# -------------------------------------------------------------------\n# API Endpoints\n# -------------------------------------------------------------------\n\n@app.post(\n    \"/todos\",\n    response_model=TodoOut,\n    status_code=status.HTTP_201_CREATED,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Create a new todo\",\n    tags=[\"Todos\"],\n)\ndef create_todo(todo_in: TodoCreate, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Create a new todo item with the given title, description, and completed status.\n    \"\"\"\n    todo = TodoORM(**todo_in.dict())\n    try:\n        db.add(todo)\n        db.flush()  # Flush to assign ID without committing yet\n        logger.info(\"Created todo with id %d\", todo.id)\n        return todo\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while creating todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create todo\",\n        ) from exc\n\n\n@app.get(\n    \"/todos\",\n    response_model=List[TodoOut],\n    dependencies=[Depends(verify_api_key)],\n    summary=\"List all todos\",\n    tags=[\"Todos\"],\n)\ndef list_todos(\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db),\n) -> List[TodoOut]:\n    \"\"\"\n    Retrieve a list of todo items with pagination support.\n    \"\"\"\n    todos = db.query(TodoORM).offset(skip).limit(limit).all()\n    logger.debug(\"Retrieved %d todos (skip=%d, limit=%d)\", len(todos), skip, limit)\n    return todos\n\n\n@app.get(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Get a todo by ID\",\n    tags=[\"Todos\"],\n)\ndef get_todo(todo_id: int, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Retrieve a single todo item by its ID.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if todo is None:\n        logger.info(\"Todo with id %d not found\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo\n\n\n@app.put(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Update a todo by ID\",\n    tags=[\"Todos\"],\n)\ndef update_todo(\n    todo_id: int,\n    todo_in: TodoUpdate,\n    db: Session = Depends(get_db),\n) -> TodoOut:\n    \"\"\"\n    Update an existing todo item by ID.\n    Only fields provided in the request are updated.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if todo is None:\n        logger.info(\"Todo with id %d not found for update\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    update_data = todo_in.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(todo, field, value)\n    try:\n        db.add(todo)\n        logger.info(\"Updated todo with id %d\", todo_id)\n        return todo\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while updating todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to update todo\",\n        ) from exc\n\n\n@app.delete(\n    \"/todos/{todo_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    dependencies=[Depends(verify_api_key)],\n    summary=\"Delete a todo by ID\",\n    tags=[\"Todos\"],\n)\ndef delete_todo(todo_id: int, db: Session = Depends(get_db)) -> Response:\n    \"\"\"\n    Delete a todo item by its ID.\n    Returns 204 No Content on success.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if todo is None:\n        logger.info(\"Todo with id %d not found for deletion\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    try:\n        db.delete(todo)\n        logger.info(\"Deleted todo with id %d\", todo_id)\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while deleting todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete todo\",\n        ) from exc\n\n\n# -------------------------------------------------------------------\n# Global Exception Handler\n# -------------------------------------------------------------------\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Catch-all handler for unexpected exceptions to prevent leaking internal details.\n    \"\"\"\n    logger.exception(\"Unhandled exception: %s\", exc)\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal Server Error\"},\n    )\n\n\n# -------------------------------------------------------------------\n# Application Entry Point\n# -------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    logger.info(\"Starting Todo API server on port %d\", SERVER_PORT)\n    uvicorn.run(\n        \"todo_api:app\",\n        host=\"0.0.0.0\",\n        port=SERVER_PORT,\n        log_level=\"info\",\n        reload=False,\n    )\n```\n\n\n=== DEBUG DETAILS ===\n- Critic review skipped: critic agent not initialized or not enabled.\n=== END DEBUG DETAILS ===\n",
      "response_length": 10840
    },
    "gpt-4.1": {
      "model": "gpt-4.1",
      "success": true,
      "response": "```python\n#!/usr/bin/env python3\n\"\"\"\ntodo_api.py\n\nA production-ready, minimal REST API for a Todo List application using FastAPI and SQLite.\n\nFeatures:\n- CRUD endpoints for todo items\n- SQLite data model using SQLAlchemy ORM\n- Centralized error handling and structured logging\n- Simple API key authentication via request header\n\nUsage\n-----\n1. Install requirements:\n    pip install fastapi uvicorn sqlalchemy pydantic python-dotenv\n\n2. (Optional) Set environment variables for config (or use a `.env` file):\n    API_KEY=your_api_key_here\n    DATABASE_URL=sqlite:///./todos.db\n    PORT=8000\n\n3. Run the service:\n    python todo_api.py\n   or:\n    uvicorn todo_api:app --host 0.0.0.0 --port 8000\n\nAPI docs: http://localhost:8000/docs\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, List, Optional\n\nfrom dotenv import load_dotenv\nfrom fastapi import Depends, FastAPI, Header, HTTPException, Request, Response, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import Boolean, Column, Integer, String, Text, create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\n\n# ------------------------------------------------------------------------------\n# Environment and Logging Configuration\n# ------------------------------------------------------------------------------\n\nload_dotenv()  # load variables from .env if present\n\nAPI_KEY: str = os.getenv(\"API_KEY\", \"secret-key\")\nAPI_KEY_HEADER = \"X-API-Key\"\nDATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"sqlite:///./todos.db\")\nSERVER_PORT: int = int(os.getenv(\"PORT\", 8000))\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(\"todo_api\")\n\n# ------------------------------------------------------------------------------\n# Database Setup\n# ------------------------------------------------------------------------------\n\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False} if DATABASE_URL.startswith(\"sqlite\") else {},\n    pool_pre_ping=True,\n)\nSessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)\nBase = declarative_base()\n\n\nclass TodoORM(Base):\n    \"\"\"\n    SQLAlchemy ORM model for a Todo item.\n    \"\"\"\n    __tablename__ = \"todos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(128), nullable=False)\n    description = Column(Text, nullable=True)\n    completed = Column(Boolean, nullable=False, default=False)\n\n\n# Create database tables on startup if they don't exist\nBase.metadata.create_all(bind=engine)\n\n# ------------------------------------------------------------------------------\n# Pydantic Schemas\n# ------------------------------------------------------------------------------\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., example=\"Buy groceries\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs\")\n    completed: bool = Field(False, example=False)\n\n\nclass TodoCreate(TodoBase):\n    \"\"\"Schema for creating a Todo item.\"\"\"\n    pass\n\n\nclass TodoUpdate(BaseModel):\n    \"\"\"Schema for updating a Todo item (all fields optional).\"\"\"\n    title: Optional[str] = Field(None, example=\"Buy groceries & fruit\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs, Apples\")\n    completed: Optional[bool] = Field(None, example=True)\n\n\nclass TodoOut(TodoBase):\n    \"\"\"Return schema for Todo items.\"\"\"\n    id: int\n\n    class Config:\n        orm_mode = True\n\n# ------------------------------------------------------------------------------\n# FastAPI App Initialization\n# ------------------------------------------------------------------------------\n\napp = FastAPI(\n    title=\"Todo List API\",\n    version=\"1.0.0\",\n    description=\"A simple, production-ready REST API for managing todo items with CRUD operations and API key authentication.\",\n)\n\n# ------------------------------------------------------------------------------\n# Dependency Helpers\n# ------------------------------------------------------------------------------\n\n@contextmanager\ndef db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Yield a SQLAlchemy Session and ensure rollback/close semantics.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n        db.commit()\n    except Exception:\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\n\ndef get_db() -> Generator[Session, None, None]:\n    \"\"\"\n    FastAPI dependency for a database session.\n    \"\"\"\n    with db_session() as db:\n        yield db\n\n\ndef verify_api_key(x_api_key: str = Header(..., alias=API_KEY_HEADER)) -> None:\n    \"\"\"\n    Dependency: Ensures that the correct API key is sent in X-API-Key header.\n    Raises HTTP 401 if invalid/missing.\n    \"\"\"\n    if x_api_key != API_KEY:\n        logger.warning(\"Unauthorized API key attempted: %s\", x_api_key)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or missing API key\",\n            headers={\"WWW-Authenticate\": \"API Key\"},\n        )\n\n# ------------------------------------------------------------------------------\n# API Endpoints\n# ------------------------------------------------------------------------------\n\n@app.post(\n    \"/todos\",\n    response_model=TodoOut,\n    status_code=status.HTTP_201_CREATED,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Create a new todo\"\n)\ndef create_todo(todo_in: TodoCreate, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Create a new todo item.\n    \"\"\"\n    todo = TodoORM(**todo_in.dict())\n    try:\n        db.add(todo)\n        db.flush()  # assign id without committing yet\n        logger.info(\"Created todo (id=%s)\", todo.id)\n        return todo\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while creating todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create todo\",\n        ) from exc\n\n@app.get(\n    \"/todos\",\n    response_model=List[TodoOut],\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"List all todos\"\n)\ndef list_todos(\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db),\n) -> List[TodoOut]:\n    \"\"\"\n    List todo items with pagination.\n    \"\"\"\n    todos = db.query(TodoORM).offset(skip).limit(limit).all()\n    logger.debug(\"Retrieved %d todos [skip=%d, limit=%d]\", len(todos), skip, limit)\n    return todos\n\n@app.get(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Get a todo by ID\"\n)\ndef get_todo(todo_id: int, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Retrieve a single todo item by its ID.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if not todo:\n        logger.info(\"Todo not found (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo\n\n@app.put(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Update a todo\"\n)\ndef update_todo(\n    todo_id: int,\n    todo_in: TodoUpdate,\n    db: Session = Depends(get_db),\n) -> TodoOut:\n    \"\"\"\n    Update a todo item by ID. Only supplied fields will be updated.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if not todo:\n        logger.info(\"Todo not found for update (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    update_data = todo_in.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(todo, field, value)\n    try:\n        db.add(todo)\n        logger.info(\"Updated todo (id=%s)\", todo_id)\n        return todo\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while updating todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to update todo\",\n        ) from exc\n\n@app.delete(\n    \"/todos/{todo_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Delete a todo\"\n)\ndef delete_todo(todo_id: int, db: Session = Depends(get_db)) -> Response:\n    \"\"\"\n    Delete a todo item by its ID.\n    Returns 204 No Content on success.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if not todo:\n        logger.info(\"Todo not found for deletion (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    try:\n        db.delete(todo)\n        logger.info(\"Deleted todo (id=%s)\", todo_id)\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while deleting todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete todo\",\n        ) from exc\n\n# ------------------------------------------------------------------------------\n# Global Error Handler\n# ------------------------------------------------------------------------------\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Catch-all handler for unhandled exceptions.\n    Prevents leaking internal errors.\n    \"\"\"\n    logger.exception(\"Unhandled exception: %s\", exc)\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal Server Error\"},\n    )\n\n# ------------------------------------------------------------------------------\n# Application Entry Point\n# ------------------------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    logger.info(\"Starting Todo API server on port %d\", SERVER_PORT)\n    uvicorn.run(\n        \"todo_api:app\",\n        host=\"0.0.0.0\",\n        port=SERVER_PORT,\n        log_level=\"info\",\n        reload=False,\n    )\n```\n\n\n=== DEBUG DETAILS ===\n- Critic review skipped: critic agent not initialized or not enabled.\n=== END DEBUG DETAILS ===\n",
      "response_length": 10471
    },
    "gpt-4.1-nano": {
      "model": "gpt-4.1-nano",
      "success": true,
      "response": "```python\n#!/usr/bin/env python3\n\"\"\"\ntodo_api.py\n\nA production-ready, minimal REST API for a Todo List application using FastAPI and SQLite.\nFeatures:\n- CRUD endpoints for todo items\n- SQLite data model using SQLAlchemy ORM\n- Centralized error handling and structured logging\n- Simple API key authentication via request header\n\nUsage\n-----\n1. Install requirements:\n    pip install fastapi uvicorn sqlalchemy pydantic python-dotenv\n\n2. (Optional) Set environment variables for config (or use a `.env` file):\n    API_KEY=your_api_key_here\n    DATABASE_URL=sqlite:///./todos.db\n    PORT=8000\n\n3. Run the service:\n    python todo_api.py\n   or:\n    uvicorn todo_api:app --host 0.0.0.0 --port 8000\n\nAPI docs: http://localhost:8000/docs\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nfrom contextlib import contextmanager\nfrom typing import Generator, List, Optional\n\nfrom dotenv import load_dotenv\nfrom fastapi import Depends, FastAPI, Header, HTTPException, Request, Response, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field\nfrom sqlalchemy import Boolean, Column, Integer, String, Text, create_engine\nfrom sqlalchemy.exc import SQLAlchemyError\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\n\n# ------------------------------------------------------------------------------\n# Environment and Logging Configuration\n# ------------------------------------------------------------------------------\nload_dotenv()  # load variables from .env if present\n\nAPI_KEY: str = os.getenv(\"API_KEY\", \"secret-key\")\nAPI_KEY_HEADER = \"X-API-Key\"\nDATABASE_URL: str = os.getenv(\"DATABASE_URL\", \"sqlite:///./todos.db\")\nSERVER_PORT: int = int(os.getenv(\"PORT\", 8000))\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n)\nlogger = logging.getLogger(\"todo_api\")\n\n# ------------------------------------------------------------------------------\n# Database Setup\n# ------------------------------------------------------------------------------\n# When using SQLite, need to disable check_same_thread to allow multithreading concurrency in FastAPI\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False} if DATABASE_URL.startswith(\"sqlite\") else {},\n    pool_pre_ping=True,\n)\nSessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)\nBase = declarative_base()\n\nclass TodoORM(Base):\n    \"\"\"\n    SQLAlchemy ORM model for a Todo item.\n    \"\"\"\n    __tablename__ = \"todos\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String(128), nullable=False)\n    description = Column(Text, nullable=True)\n    completed = Column(Boolean, nullable=False, default=False)\n\n# Create database tables on startup if they don't exist\nBase.metadata.create_all(bind=engine)\n\n# ------------------------------------------------------------------------------\n# Pydantic Schemas\n# ------------------------------------------------------------------------------\nclass TodoBase(BaseModel):\n    title: str = Field(..., example=\"Buy groceries\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs\")\n    completed: bool = Field(False, example=False)\n\nclass TodoCreate(TodoBase):\n    \"\"\"Schema for creating a Todo item.\"\"\"\n    pass\n\nclass TodoUpdate(BaseModel):\n    \"\"\"Schema for updating a Todo item (all fields optional).\"\"\"\n    title: Optional[str] = Field(None, example=\"Buy groceries & fruit\")\n    description: Optional[str] = Field(None, example=\"Milk, Bread, Eggs, Apples\")\n    completed: Optional[bool] = Field(None, example=True)\n\nclass TodoOut(TodoBase):\n    \"\"\"Return schema for Todo items.\"\"\"\n    id: int\n\n    class Config:\n        orm_mode = True\n\n# ------------------------------------------------------------------------------\n# FastAPI App Initialization\n# ------------------------------------------------------------------------------\napp = FastAPI(\n    title=\"Todo List API\",\n    version=\"1.0.0\",\n    description=\"A simple, production-ready REST API for managing todo items with CRUD operations and API key authentication.\",\n)\n\n# ------------------------------------------------------------------------------\n# Dependency Helpers\n# ------------------------------------------------------------------------------\n@contextmanager\ndef db_session() -> Generator[Session, None, None]:\n    \"\"\"\n    Yield a SQLAlchemy Session and ensure rollback/close semantics.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n        db.commit()\n    except Exception:\n        db.rollback()\n        raise\n    finally:\n        db.close()\n\ndef get_db() -> Generator[Session, None, None]:\n    \"\"\"\n    FastAPI dependency for a database session.\n    \"\"\"\n    with db_session() as db:\n        yield db\n\ndef verify_api_key(x_api_key: str = Header(..., alias=API_KEY_HEADER)) -> None:\n    \"\"\"\n    Dependency: Ensures that the correct API key is sent in X-API-Key header.\n    Raises HTTP 401 if invalid/missing.\n    \"\"\"\n    if x_api_key != API_KEY:\n        logger.warning(\"Unauthorized API key attempted: %s\", x_api_key)\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid or missing API key\",\n            headers={\"WWW-Authenticate\": \"API Key\"},\n        )\n\n# ------------------------------------------------------------------------------\n# API Endpoints\n# ------------------------------------------------------------------------------\n@app.post(\n    \"/todos\",\n    response_model=TodoOut,\n    status_code=status.HTTP_201_CREATED,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Create a new todo\"\n)\ndef create_todo(todo_in: TodoCreate, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Create a new todo item.\n    \"\"\"\n    todo = TodoORM(**todo_in.dict())\n    try:\n        db.add(todo)\n        db.flush()  # assign id without committing yet\n        logger.info(\"Created todo (id=%s)\", todo.id)\n        return todo\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while creating todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to create todo\",\n        ) from exc\n\n@app.get(\n    \"/todos\",\n    response_model=List[TodoOut],\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"List all todos\"\n)\ndef list_todos(\n    skip: int = 0,\n    limit: int = 100,\n    db: Session = Depends(get_db),\n) -> List[TodoOut]:\n    \"\"\"\n    List todo items with pagination.\n    \"\"\"\n    todos = db.query(TodoORM).offset(skip).limit(limit).all()\n    logger.debug(\"Retrieved %d todos (skip=%d, limit=%d)\", len(todos), skip, limit)\n    return todos\n\n@app.get(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Get a todo by ID\"\n)\ndef get_todo(todo_id: int, db: Session = Depends(get_db)) -> TodoOut:\n    \"\"\"\n    Retrieve a single todo item by its ID.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if not todo:\n        logger.info(\"Todo not found (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    return todo\n\n@app.put(\n    \"/todos/{todo_id}\",\n    response_model=TodoOut,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Update a todo\"\n)\ndef update_todo(\n    todo_id: int,\n    todo_in: TodoUpdate,\n    db: Session = Depends(get_db),\n) -> TodoOut:\n    \"\"\"\n    Update a todo item by ID. Only fields provided will be updated.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if not todo:\n        logger.info(\"Todo not found for update (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    update_data = todo_in.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(todo, field, value)\n    try:\n        db.add(todo)\n        logger.info(\"Updated todo (id=%s)\", todo_id)\n        return todo\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while updating todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to update todo\",\n        ) from exc\n\n@app.delete(\n    \"/todos/{todo_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    dependencies=[Depends(verify_api_key)],\n    tags=[\"Todos\"],\n    summary=\"Delete a todo\"\n)\ndef delete_todo(todo_id: int, db: Session = Depends(get_db)) -> Response:\n    \"\"\"\n    Delete a todo item by its ID.\n    Returns 204 No Content on success.\n    \"\"\"\n    todo = db.get(TodoORM, todo_id)\n    if not todo:\n        logger.info(\"Todo not found for deletion (id=%s)\", todo_id)\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"Todo not found\",\n        )\n    try:\n        db.delete(todo)\n        logger.info(\"Deleted todo (id=%s)\", todo_id)\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n    except SQLAlchemyError as exc:\n        logger.exception(\"Database error while deleting todo: %s\", exc)\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=\"Failed to delete todo\",\n        ) from exc\n\n# ------------------------------------------------------------------------------\n# Global Error Handler\n# ------------------------------------------------------------------------------\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception) -> JSONResponse:\n    \"\"\"\n    Catch-all handler for unhandled exceptions.\n    Prevents leaking internal errors.\n    \"\"\"\n    logger.exception(\"Unhandled exception: %s\", exc)\n    return JSONResponse(\n        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n        content={\"detail\": \"Internal Server Error\"},\n    )\n\n# ------------------------------------------------------------------------------\n# Application Entry Point\n# ------------------------------------------------------------------------------\nif __name__ == \"__main__\":\n    import uvicorn\n\n    logger.info(\"Starting Todo API server on port %d\", SERVER_PORT)\n    uvicorn.run(\n        \"todo_api:app\",\n        host=\"0.0.0.0\",\n        port=SERVER_PORT,\n        log_level=\"info\",\n        reload=False,\n    )\n```\n\n=== DEBUG DETAILS ===\n- Critic review skipped: critic agent not initialized or not enabled.\n=== END DEBUG DETAILS ===\n",
      "response_length": 10556
    }
  }
}